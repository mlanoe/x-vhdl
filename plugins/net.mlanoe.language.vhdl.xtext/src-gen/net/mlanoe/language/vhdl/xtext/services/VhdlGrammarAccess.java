/*
* generated by Xtext
*/
package net.mlanoe.language.vhdl.xtext.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;


@Singleton
public class VhdlGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class ModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Model");
		private final Assignment cDesignAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cDesignDesignUnitParserRuleCall_0 = (RuleCall)cDesignAssignment.eContents().get(0);
		
		//Model:
		//	design+=DesignUnit*;
		public ParserRule getRule() { return rule; }

		//design+=DesignUnit*
		public Assignment getDesignAssignment() { return cDesignAssignment; }

		//DesignUnit
		public RuleCall getDesignDesignUnitParserRuleCall_0() { return cDesignDesignUnitParserRuleCall_0; }
	}

	public class DesignUnitElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DesignUnit");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Group cGroup_0_0 = (Group)cAlternatives_0.eContents().get(0);
		private final Keyword cLibraryKeyword_0_0_0 = (Keyword)cGroup_0_0.eContents().get(0);
		private final Assignment cLibraryAssignment_0_0_1 = (Assignment)cGroup_0_0.eContents().get(1);
		private final RuleCall cLibraryIdentifierParserRuleCall_0_0_1_0 = (RuleCall)cLibraryAssignment_0_0_1.eContents().get(0);
		private final Group cGroup_0_0_2 = (Group)cGroup_0_0.eContents().get(2);
		private final Keyword cCommaKeyword_0_0_2_0 = (Keyword)cGroup_0_0_2.eContents().get(0);
		private final Assignment cLibraryAssignment_0_0_2_1 = (Assignment)cGroup_0_0_2.eContents().get(1);
		private final RuleCall cLibraryIdentifierParserRuleCall_0_0_2_1_0 = (RuleCall)cLibraryAssignment_0_0_2_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_0_0_3 = (Keyword)cGroup_0_0.eContents().get(3);
		private final Group cGroup_0_1 = (Group)cAlternatives_0.eContents().get(1);
		private final Keyword cUseKeyword_0_1_0 = (Keyword)cGroup_0_1.eContents().get(0);
		private final Assignment cUseAssignment_0_1_1 = (Assignment)cGroup_0_1.eContents().get(1);
		private final RuleCall cUseNameParserRuleCall_0_1_1_0 = (RuleCall)cUseAssignment_0_1_1.eContents().get(0);
		private final Group cGroup_0_1_2 = (Group)cGroup_0_1.eContents().get(2);
		private final Keyword cCommaKeyword_0_1_2_0 = (Keyword)cGroup_0_1_2.eContents().get(0);
		private final Assignment cUseAssignment_0_1_2_1 = (Assignment)cGroup_0_1_2.eContents().get(1);
		private final RuleCall cUseNameParserRuleCall_0_1_2_1_0 = (RuleCall)cUseAssignment_0_1_2_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_0_1_3 = (Keyword)cGroup_0_1.eContents().get(3);
		private final Assignment cModuleAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cModuleModuleParserRuleCall_1_0 = (RuleCall)cModuleAssignment_1.eContents().get(0);
		
		//DesignUnit:
		//	("library" library+=Identifier ("," library+=Identifier)* ";" | "use" use+=Name ("," use+=Name)* ";")* module=Module;
		public ParserRule getRule() { return rule; }

		//("library" library+=Identifier ("," library+=Identifier)* ";" | "use" use+=Name ("," use+=Name)* ";")* module=Module
		public Group getGroup() { return cGroup; }

		//("library" library+=Identifier ("," library+=Identifier)* ";" | "use" use+=Name ("," use+=Name)* ";")*
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//"library" library+=Identifier ("," library+=Identifier)* ";"
		public Group getGroup_0_0() { return cGroup_0_0; }

		//"library"
		public Keyword getLibraryKeyword_0_0_0() { return cLibraryKeyword_0_0_0; }

		//library+=Identifier
		public Assignment getLibraryAssignment_0_0_1() { return cLibraryAssignment_0_0_1; }

		//Identifier
		public RuleCall getLibraryIdentifierParserRuleCall_0_0_1_0() { return cLibraryIdentifierParserRuleCall_0_0_1_0; }

		//("," library+=Identifier)*
		public Group getGroup_0_0_2() { return cGroup_0_0_2; }

		//","
		public Keyword getCommaKeyword_0_0_2_0() { return cCommaKeyword_0_0_2_0; }

		//library+=Identifier
		public Assignment getLibraryAssignment_0_0_2_1() { return cLibraryAssignment_0_0_2_1; }

		//Identifier
		public RuleCall getLibraryIdentifierParserRuleCall_0_0_2_1_0() { return cLibraryIdentifierParserRuleCall_0_0_2_1_0; }

		//";"
		public Keyword getSemicolonKeyword_0_0_3() { return cSemicolonKeyword_0_0_3; }

		//"use" use+=Name ("," use+=Name)* ";"
		public Group getGroup_0_1() { return cGroup_0_1; }

		//"use"
		public Keyword getUseKeyword_0_1_0() { return cUseKeyword_0_1_0; }

		//use+=Name
		public Assignment getUseAssignment_0_1_1() { return cUseAssignment_0_1_1; }

		//Name
		public RuleCall getUseNameParserRuleCall_0_1_1_0() { return cUseNameParserRuleCall_0_1_1_0; }

		//("," use+=Name)*
		public Group getGroup_0_1_2() { return cGroup_0_1_2; }

		//","
		public Keyword getCommaKeyword_0_1_2_0() { return cCommaKeyword_0_1_2_0; }

		//use+=Name
		public Assignment getUseAssignment_0_1_2_1() { return cUseAssignment_0_1_2_1; }

		//Name
		public RuleCall getUseNameParserRuleCall_0_1_2_1_0() { return cUseNameParserRuleCall_0_1_2_1_0; }

		//";"
		public Keyword getSemicolonKeyword_0_1_3() { return cSemicolonKeyword_0_1_3; }

		//module=Module
		public Assignment getModuleAssignment_1() { return cModuleAssignment_1; }

		//Module
		public RuleCall getModuleModuleParserRuleCall_1_0() { return cModuleModuleParserRuleCall_1_0; }
	}

	public class ModuleElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Module");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cArchitectureParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cPackageBodyParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cEntityParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cConfigurationParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cPackageParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		
		//Module:
		//	Architecture | PackageBody | Entity | Configuration | Package;
		public ParserRule getRule() { return rule; }

		//Architecture | PackageBody | Entity | Configuration | Package
		public Alternatives getAlternatives() { return cAlternatives; }

		//Architecture
		public RuleCall getArchitectureParserRuleCall_0() { return cArchitectureParserRuleCall_0; }

		//PackageBody
		public RuleCall getPackageBodyParserRuleCall_1() { return cPackageBodyParserRuleCall_1; }

		//Entity
		public RuleCall getEntityParserRuleCall_2() { return cEntityParserRuleCall_2; }

		//Configuration
		public RuleCall getConfigurationParserRuleCall_3() { return cConfigurationParserRuleCall_3; }

		//Package
		public RuleCall getPackageParserRuleCall_4() { return cPackageParserRuleCall_4; }
	}

	public class ArchitectureElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Architecture");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cArchitectureKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIdentifierNameParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cOfKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cOfAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cOfNameParserRuleCall_3_0 = (RuleCall)cOfAssignment_3.eContents().get(0);
		private final Keyword cIsKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cDeclarationAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cDeclarationBlockDeclarativeItemParserRuleCall_5_0 = (RuleCall)cDeclarationAssignment_5.eContents().get(0);
		private final Keyword cBeginKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Assignment cStatementAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cStatementArchitectureStatementParserRuleCall_7_0 = (RuleCall)cStatementAssignment_7.eContents().get(0);
		private final Keyword cEndKeyword_8 = (Keyword)cGroup.eContents().get(8);
		private final Keyword cArchitectureKeyword_9 = (Keyword)cGroup.eContents().get(9);
		private final RuleCall cIdentifierParserRuleCall_10 = (RuleCall)cGroup.eContents().get(10);
		private final Keyword cSemicolonKeyword_11 = (Keyword)cGroup.eContents().get(11);
		
		/// *
		// * architecture identifier of entity_name is
		// *    [ declarations]
		// * begin -- optional
		// *    [ statements]
		// * end architecture identifier ;  
		// * / Architecture:
		//	"architecture" name=IdentifierName "of" of=Name "is" declaration+=BlockDeclarativeItem* "begin"
		//	statement+=ArchitectureStatement* "end" "architecture"? Identifier? ";";
		public ParserRule getRule() { return rule; }

		//"architecture" name=IdentifierName "of" of=Name "is" declaration+=BlockDeclarativeItem* "begin"
		//statement+=ArchitectureStatement* "end" "architecture"? Identifier? ";"
		public Group getGroup() { return cGroup; }

		//"architecture"
		public Keyword getArchitectureKeyword_0() { return cArchitectureKeyword_0; }

		//name=IdentifierName
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//IdentifierName
		public RuleCall getNameIdentifierNameParserRuleCall_1_0() { return cNameIdentifierNameParserRuleCall_1_0; }

		//"of"
		public Keyword getOfKeyword_2() { return cOfKeyword_2; }

		//of=Name
		public Assignment getOfAssignment_3() { return cOfAssignment_3; }

		//Name
		public RuleCall getOfNameParserRuleCall_3_0() { return cOfNameParserRuleCall_3_0; }

		//"is"
		public Keyword getIsKeyword_4() { return cIsKeyword_4; }

		//declaration+=BlockDeclarativeItem*
		public Assignment getDeclarationAssignment_5() { return cDeclarationAssignment_5; }

		//BlockDeclarativeItem
		public RuleCall getDeclarationBlockDeclarativeItemParserRuleCall_5_0() { return cDeclarationBlockDeclarativeItemParserRuleCall_5_0; }

		//"begin"
		public Keyword getBeginKeyword_6() { return cBeginKeyword_6; }

		//statement+=ArchitectureStatement*
		public Assignment getStatementAssignment_7() { return cStatementAssignment_7; }

		//ArchitectureStatement
		public RuleCall getStatementArchitectureStatementParserRuleCall_7_0() { return cStatementArchitectureStatementParserRuleCall_7_0; }

		//"end"
		public Keyword getEndKeyword_8() { return cEndKeyword_8; }

		//"architecture"?
		public Keyword getArchitectureKeyword_9() { return cArchitectureKeyword_9; }

		//Identifier?
		public RuleCall getIdentifierParserRuleCall_10() { return cIdentifierParserRuleCall_10; }

		//";"
		public Keyword getSemicolonKeyword_11() { return cSemicolonKeyword_11; }
	}

	public class PackageBodyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PackageBody");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cPackageKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cBodyKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameIdentifierNameParserRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Keyword cIsKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cDeclarationAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cDeclarationPackageBodyDeclarativeItemParserRuleCall_4_0 = (RuleCall)cDeclarationAssignment_4.eContents().get(0);
		private final Keyword cEndKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Group cGroup_6 = (Group)cGroup.eContents().get(6);
		private final Keyword cPackageKeyword_6_0 = (Keyword)cGroup_6.eContents().get(0);
		private final Keyword cBodyKeyword_6_1 = (Keyword)cGroup_6.eContents().get(1);
		private final RuleCall cIdentifierParserRuleCall_7 = (RuleCall)cGroup.eContents().get(7);
		private final Keyword cSemicolonKeyword_8 = (Keyword)cGroup.eContents().get(8);
		
		/// *
		// * package body identifier is
		// *     [ declarations, see allowed list below ]
		// *  end package body identifier ;
		// * / PackageBody:
		//	"package" "body" name=IdentifierName "is" declaration+=PackageBodyDeclarativeItem* "end" ("package" "body")?
		//	Identifier? ";";
		public ParserRule getRule() { return rule; }

		//"package" "body" name=IdentifierName "is" declaration+=PackageBodyDeclarativeItem* "end" ("package" "body")? Identifier?
		//";"
		public Group getGroup() { return cGroup; }

		//"package"
		public Keyword getPackageKeyword_0() { return cPackageKeyword_0; }

		//"body"
		public Keyword getBodyKeyword_1() { return cBodyKeyword_1; }

		//name=IdentifierName
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }

		//IdentifierName
		public RuleCall getNameIdentifierNameParserRuleCall_2_0() { return cNameIdentifierNameParserRuleCall_2_0; }

		//"is"
		public Keyword getIsKeyword_3() { return cIsKeyword_3; }

		//declaration+=PackageBodyDeclarativeItem*
		public Assignment getDeclarationAssignment_4() { return cDeclarationAssignment_4; }

		//PackageBodyDeclarativeItem
		public RuleCall getDeclarationPackageBodyDeclarativeItemParserRuleCall_4_0() { return cDeclarationPackageBodyDeclarativeItemParserRuleCall_4_0; }

		//"end"
		public Keyword getEndKeyword_5() { return cEndKeyword_5; }

		//("package" "body")?
		public Group getGroup_6() { return cGroup_6; }

		//"package"
		public Keyword getPackageKeyword_6_0() { return cPackageKeyword_6_0; }

		//"body"
		public Keyword getBodyKeyword_6_1() { return cBodyKeyword_6_1; }

		//Identifier?
		public RuleCall getIdentifierParserRuleCall_7() { return cIdentifierParserRuleCall_7; }

		//";"
		public Keyword getSemicolonKeyword_8() { return cSemicolonKeyword_8; }
	}

	public class PackageElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Package");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cPackageKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIdentifierNameParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cIsKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cDeclarationAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cDeclarationPackageDeclarativeItemParserRuleCall_3_0 = (RuleCall)cDeclarationAssignment_3.eContents().get(0);
		private final Keyword cEndKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cPackageKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final RuleCall cIdentifierParserRuleCall_6 = (RuleCall)cGroup.eContents().get(6);
		private final Keyword cSemicolonKeyword_7 = (Keyword)cGroup.eContents().get(7);
		
		/// *
		// * package identifier is
		// *     [ declarations, see allowed list below ]
		// * end package identifier ;
		// * / Package:
		//	"package" name=IdentifierName "is" declaration+=PackageDeclarativeItem* "end" "package"? Identifier? ";";
		public ParserRule getRule() { return rule; }

		//"package" name=IdentifierName "is" declaration+=PackageDeclarativeItem* "end" "package"? Identifier? ";"
		public Group getGroup() { return cGroup; }

		//"package"
		public Keyword getPackageKeyword_0() { return cPackageKeyword_0; }

		//name=IdentifierName
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//IdentifierName
		public RuleCall getNameIdentifierNameParserRuleCall_1_0() { return cNameIdentifierNameParserRuleCall_1_0; }

		//"is"
		public Keyword getIsKeyword_2() { return cIsKeyword_2; }

		//declaration+=PackageDeclarativeItem*
		public Assignment getDeclarationAssignment_3() { return cDeclarationAssignment_3; }

		//PackageDeclarativeItem
		public RuleCall getDeclarationPackageDeclarativeItemParserRuleCall_3_0() { return cDeclarationPackageDeclarativeItemParserRuleCall_3_0; }

		//"end"
		public Keyword getEndKeyword_4() { return cEndKeyword_4; }

		//"package"?
		public Keyword getPackageKeyword_5() { return cPackageKeyword_5; }

		//Identifier?
		public RuleCall getIdentifierParserRuleCall_6() { return cIdentifierParserRuleCall_6; }

		//";"
		public Keyword getSemicolonKeyword_7() { return cSemicolonKeyword_7; }
	}

	public class EntityElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Entity");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cEntityKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIdentifierNameParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cIsKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cGenericAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cGenericGenericsParserRuleCall_3_0 = (RuleCall)cGenericAssignment_3.eContents().get(0);
		private final Assignment cPortAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cPortPortsParserRuleCall_4_0 = (RuleCall)cPortAssignment_4.eContents().get(0);
		private final Assignment cDeclarationAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cDeclarationEntityDeclarativeItemParserRuleCall_5_0 = (RuleCall)cDeclarationAssignment_5.eContents().get(0);
		private final Group cGroup_6 = (Group)cGroup.eContents().get(6);
		private final Keyword cBeginKeyword_6_0 = (Keyword)cGroup_6.eContents().get(0);
		private final Assignment cStatementAssignment_6_1 = (Assignment)cGroup_6.eContents().get(1);
		private final RuleCall cStatementEntityStatementParserRuleCall_6_1_0 = (RuleCall)cStatementAssignment_6_1.eContents().get(0);
		private final Keyword cEndKeyword_7 = (Keyword)cGroup.eContents().get(7);
		private final Keyword cEntityKeyword_8 = (Keyword)cGroup.eContents().get(8);
		private final RuleCall cIdentifierParserRuleCall_9 = (RuleCall)cGroup.eContents().get(9);
		private final Keyword cSemicolonKeyword_10 = (Keyword)cGroup.eContents().get(10);
		
		//Entity:
		//	"entity" name=IdentifierName "is" generic=Generics? port=Ports? declaration+=EntityDeclarativeItem* ("begin"
		//	statement+=EntityStatement*)? "end" "entity"? Identifier? ";";
		public ParserRule getRule() { return rule; }

		//"entity" name=IdentifierName "is" generic=Generics? port=Ports? declaration+=EntityDeclarativeItem* ("begin"
		//statement+=EntityStatement*)? "end" "entity"? Identifier? ";"
		public Group getGroup() { return cGroup; }

		//"entity"
		public Keyword getEntityKeyword_0() { return cEntityKeyword_0; }

		//name=IdentifierName
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//IdentifierName
		public RuleCall getNameIdentifierNameParserRuleCall_1_0() { return cNameIdentifierNameParserRuleCall_1_0; }

		//"is"
		public Keyword getIsKeyword_2() { return cIsKeyword_2; }

		//generic=Generics?
		public Assignment getGenericAssignment_3() { return cGenericAssignment_3; }

		//Generics
		public RuleCall getGenericGenericsParserRuleCall_3_0() { return cGenericGenericsParserRuleCall_3_0; }

		//port=Ports?
		public Assignment getPortAssignment_4() { return cPortAssignment_4; }

		//Ports
		public RuleCall getPortPortsParserRuleCall_4_0() { return cPortPortsParserRuleCall_4_0; }

		//declaration+=EntityDeclarativeItem*
		public Assignment getDeclarationAssignment_5() { return cDeclarationAssignment_5; }

		//EntityDeclarativeItem
		public RuleCall getDeclarationEntityDeclarativeItemParserRuleCall_5_0() { return cDeclarationEntityDeclarativeItemParserRuleCall_5_0; }

		//("begin" statement+=EntityStatement*)?
		public Group getGroup_6() { return cGroup_6; }

		//"begin"
		public Keyword getBeginKeyword_6_0() { return cBeginKeyword_6_0; }

		//statement+=EntityStatement*
		public Assignment getStatementAssignment_6_1() { return cStatementAssignment_6_1; }

		//EntityStatement
		public RuleCall getStatementEntityStatementParserRuleCall_6_1_0() { return cStatementEntityStatementParserRuleCall_6_1_0; }

		//"end"
		public Keyword getEndKeyword_7() { return cEndKeyword_7; }

		//"entity"?
		public Keyword getEntityKeyword_8() { return cEntityKeyword_8; }

		//Identifier?
		public RuleCall getIdentifierParserRuleCall_9() { return cIdentifierParserRuleCall_9; }

		//";"
		public Keyword getSemicolonKeyword_10() { return cSemicolonKeyword_10; }
	}

	public class ConfigurationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Configuration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cConfigurationKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIdentifierNameParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cOfKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cOfAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cOfNameParserRuleCall_3_0 = (RuleCall)cOfAssignment_3.eContents().get(0);
		private final Keyword cIsKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cDeclarationAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cDeclarationConfigurationDeclarativeItemParserRuleCall_5_0 = (RuleCall)cDeclarationAssignment_5.eContents().get(0);
		private final Assignment cBlockAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cBlockBlockConfigurationParserRuleCall_6_0 = (RuleCall)cBlockAssignment_6.eContents().get(0);
		private final Keyword cEndKeyword_7 = (Keyword)cGroup.eContents().get(7);
		private final Keyword cConfigurationKeyword_8 = (Keyword)cGroup.eContents().get(8);
		private final RuleCall cIdentifierParserRuleCall_9 = (RuleCall)cGroup.eContents().get(9);
		private final Keyword cSemicolonKeyword_10 = (Keyword)cGroup.eContents().get(10);
		
		//Configuration returns configuration::Configuration:
		//	"configuration" name=IdentifierName "of" of=Name "is" declaration+=ConfigurationDeclarativeItem*
		//	block=BlockConfiguration "end" "configuration"? Identifier? ";";
		public ParserRule getRule() { return rule; }

		//"configuration" name=IdentifierName "of" of=Name "is" declaration+=ConfigurationDeclarativeItem*
		//block=BlockConfiguration "end" "configuration"? Identifier? ";"
		public Group getGroup() { return cGroup; }

		//"configuration"
		public Keyword getConfigurationKeyword_0() { return cConfigurationKeyword_0; }

		//name=IdentifierName
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//IdentifierName
		public RuleCall getNameIdentifierNameParserRuleCall_1_0() { return cNameIdentifierNameParserRuleCall_1_0; }

		//"of"
		public Keyword getOfKeyword_2() { return cOfKeyword_2; }

		//of=Name
		public Assignment getOfAssignment_3() { return cOfAssignment_3; }

		//Name
		public RuleCall getOfNameParserRuleCall_3_0() { return cOfNameParserRuleCall_3_0; }

		//"is"
		public Keyword getIsKeyword_4() { return cIsKeyword_4; }

		//declaration+=ConfigurationDeclarativeItem*
		public Assignment getDeclarationAssignment_5() { return cDeclarationAssignment_5; }

		//ConfigurationDeclarativeItem
		public RuleCall getDeclarationConfigurationDeclarativeItemParserRuleCall_5_0() { return cDeclarationConfigurationDeclarativeItemParserRuleCall_5_0; }

		//block=BlockConfiguration
		public Assignment getBlockAssignment_6() { return cBlockAssignment_6; }

		//BlockConfiguration
		public RuleCall getBlockBlockConfigurationParserRuleCall_6_0() { return cBlockBlockConfigurationParserRuleCall_6_0; }

		//"end"
		public Keyword getEndKeyword_7() { return cEndKeyword_7; }

		//"configuration"?
		public Keyword getConfigurationKeyword_8() { return cConfigurationKeyword_8; }

		//Identifier?
		public RuleCall getIdentifierParserRuleCall_9() { return cIdentifierParserRuleCall_9; }

		//";"
		public Keyword getSemicolonKeyword_10() { return cSemicolonKeyword_10; }
	}

	public class UseClauseDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UseClauseDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cUseKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cUseAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cUseMultiNameParserRuleCall_1_0 = (RuleCall)cUseAssignment_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//UseClauseDeclaration returns declaration::UseClauseDeclaration:
		//	"use" use=MultiName ";";
		public ParserRule getRule() { return rule; }

		//"use" use=MultiName ";"
		public Group getGroup() { return cGroup; }

		//"use"
		public Keyword getUseKeyword_0() { return cUseKeyword_0; }

		//use=MultiName
		public Assignment getUseAssignment_1() { return cUseAssignment_1; }

		//MultiName
		public RuleCall getUseMultiNameParserRuleCall_1_0() { return cUseMultiNameParserRuleCall_1_0; }

		//";"
		public Keyword getSemicolonKeyword_2() { return cSemicolonKeyword_2; }
	}

	public class BlockDeclarativeItemElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BlockDeclarativeItem");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSubprogramDeclarationParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cTypeDeclarationParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cSubtypeDeclarationParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cConstantDeclarationParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cSignalDeclarationParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cVariableDeclarationParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cFileDeclarationParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cAliasDeclarationParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		private final RuleCall cComponentParserRuleCall_8 = (RuleCall)cAlternatives.eContents().get(8);
		private final RuleCall cAttributeDeclarationParserRuleCall_9 = (RuleCall)cAlternatives.eContents().get(9);
		private final RuleCall cAttributeSpecificationParserRuleCall_10 = (RuleCall)cAlternatives.eContents().get(10);
		private final RuleCall cConfigurationSpecificationParserRuleCall_11 = (RuleCall)cAlternatives.eContents().get(11);
		private final RuleCall cDisconnectionSpecificationParserRuleCall_12 = (RuleCall)cAlternatives.eContents().get(12);
		private final RuleCall cLimitDeclarationParserRuleCall_13 = (RuleCall)cAlternatives.eContents().get(13);
		private final RuleCall cUseClauseDeclarationParserRuleCall_14 = (RuleCall)cAlternatives.eContents().get(14);
		private final RuleCall cGroupTemplateDeclarationParserRuleCall_15 = (RuleCall)cAlternatives.eContents().get(15);
		private final RuleCall cGroupDeclarationParserRuleCall_16 = (RuleCall)cAlternatives.eContents().get(16);
		private final RuleCall cNatureDeclarationParserRuleCall_17 = (RuleCall)cAlternatives.eContents().get(17);
		private final RuleCall cSubnatureDeclarationParserRuleCall_18 = (RuleCall)cAlternatives.eContents().get(18);
		private final RuleCall cQuantityDeclarationParserRuleCall_19 = (RuleCall)cAlternatives.eContents().get(19);
		private final RuleCall cTerminalDeclarationParserRuleCall_20 = (RuleCall)cAlternatives.eContents().get(20);
		
		//BlockDeclarativeItem returns declaration::Declaration:
		//	SubprogramDeclaration | TypeDeclaration | SubtypeDeclaration | ConstantDeclaration | SignalDeclaration |
		//	VariableDeclaration | FileDeclaration | AliasDeclaration | Component | AttributeDeclaration | AttributeSpecification |
		//	ConfigurationSpecification | DisconnectionSpecification | LimitDeclaration | UseClauseDeclaration |
		//	GroupTemplateDeclaration | GroupDeclaration | NatureDeclaration | SubnatureDeclaration | QuantityDeclaration |
		//	TerminalDeclaration;
		public ParserRule getRule() { return rule; }

		//SubprogramDeclaration | TypeDeclaration | SubtypeDeclaration | ConstantDeclaration | SignalDeclaration |
		//VariableDeclaration | FileDeclaration | AliasDeclaration | Component | AttributeDeclaration | AttributeSpecification |
		//ConfigurationSpecification | DisconnectionSpecification | LimitDeclaration | UseClauseDeclaration |
		//GroupTemplateDeclaration | GroupDeclaration | NatureDeclaration | SubnatureDeclaration | QuantityDeclaration |
		//TerminalDeclaration
		public Alternatives getAlternatives() { return cAlternatives; }

		//SubprogramDeclaration
		public RuleCall getSubprogramDeclarationParserRuleCall_0() { return cSubprogramDeclarationParserRuleCall_0; }

		//TypeDeclaration
		public RuleCall getTypeDeclarationParserRuleCall_1() { return cTypeDeclarationParserRuleCall_1; }

		//SubtypeDeclaration
		public RuleCall getSubtypeDeclarationParserRuleCall_2() { return cSubtypeDeclarationParserRuleCall_2; }

		//ConstantDeclaration
		public RuleCall getConstantDeclarationParserRuleCall_3() { return cConstantDeclarationParserRuleCall_3; }

		//SignalDeclaration
		public RuleCall getSignalDeclarationParserRuleCall_4() { return cSignalDeclarationParserRuleCall_4; }

		//VariableDeclaration
		public RuleCall getVariableDeclarationParserRuleCall_5() { return cVariableDeclarationParserRuleCall_5; }

		//FileDeclaration
		public RuleCall getFileDeclarationParserRuleCall_6() { return cFileDeclarationParserRuleCall_6; }

		//AliasDeclaration
		public RuleCall getAliasDeclarationParserRuleCall_7() { return cAliasDeclarationParserRuleCall_7; }

		//Component
		public RuleCall getComponentParserRuleCall_8() { return cComponentParserRuleCall_8; }

		//AttributeDeclaration
		public RuleCall getAttributeDeclarationParserRuleCall_9() { return cAttributeDeclarationParserRuleCall_9; }

		//AttributeSpecification
		public RuleCall getAttributeSpecificationParserRuleCall_10() { return cAttributeSpecificationParserRuleCall_10; }

		//ConfigurationSpecification
		public RuleCall getConfigurationSpecificationParserRuleCall_11() { return cConfigurationSpecificationParserRuleCall_11; }

		//DisconnectionSpecification
		public RuleCall getDisconnectionSpecificationParserRuleCall_12() { return cDisconnectionSpecificationParserRuleCall_12; }

		//LimitDeclaration
		public RuleCall getLimitDeclarationParserRuleCall_13() { return cLimitDeclarationParserRuleCall_13; }

		//UseClauseDeclaration
		public RuleCall getUseClauseDeclarationParserRuleCall_14() { return cUseClauseDeclarationParserRuleCall_14; }

		//GroupTemplateDeclaration
		public RuleCall getGroupTemplateDeclarationParserRuleCall_15() { return cGroupTemplateDeclarationParserRuleCall_15; }

		//GroupDeclaration
		public RuleCall getGroupDeclarationParserRuleCall_16() { return cGroupDeclarationParserRuleCall_16; }

		//NatureDeclaration
		public RuleCall getNatureDeclarationParserRuleCall_17() { return cNatureDeclarationParserRuleCall_17; }

		//SubnatureDeclaration
		public RuleCall getSubnatureDeclarationParserRuleCall_18() { return cSubnatureDeclarationParserRuleCall_18; }

		//QuantityDeclaration
		public RuleCall getQuantityDeclarationParserRuleCall_19() { return cQuantityDeclarationParserRuleCall_19; }

		//TerminalDeclaration
		public RuleCall getTerminalDeclarationParserRuleCall_20() { return cTerminalDeclarationParserRuleCall_20; }
	}

	public class ConfigurationDeclarativeItemElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ConfigurationDeclarativeItem");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cUseClauseDeclarationParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cAttributeSpecificationParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cGroupDeclarationParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//ConfigurationDeclarativeItem returns declaration::Declaration:
		//	UseClauseDeclaration | AttributeSpecification | GroupDeclaration;
		public ParserRule getRule() { return rule; }

		//UseClauseDeclaration | AttributeSpecification | GroupDeclaration
		public Alternatives getAlternatives() { return cAlternatives; }

		//UseClauseDeclaration
		public RuleCall getUseClauseDeclarationParserRuleCall_0() { return cUseClauseDeclarationParserRuleCall_0; }

		//AttributeSpecification
		public RuleCall getAttributeSpecificationParserRuleCall_1() { return cAttributeSpecificationParserRuleCall_1; }

		//GroupDeclaration
		public RuleCall getGroupDeclarationParserRuleCall_2() { return cGroupDeclarationParserRuleCall_2; }
	}

	public class EntityDeclarativeItemElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EntityDeclarativeItem");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSubprogramDeclarationParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cTypeDeclarationParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cSubtypeDeclarationParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cConstantDeclarationParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cSignalDeclarationParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cVariableDeclarationParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cFileDeclarationParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cAliasDeclarationParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		private final RuleCall cAttributeDeclarationParserRuleCall_8 = (RuleCall)cAlternatives.eContents().get(8);
		private final RuleCall cAttributeSpecificationParserRuleCall_9 = (RuleCall)cAlternatives.eContents().get(9);
		private final RuleCall cDisconnectionSpecificationParserRuleCall_10 = (RuleCall)cAlternatives.eContents().get(10);
		private final RuleCall cLimitDeclarationParserRuleCall_11 = (RuleCall)cAlternatives.eContents().get(11);
		private final RuleCall cUseClauseDeclarationParserRuleCall_12 = (RuleCall)cAlternatives.eContents().get(12);
		private final RuleCall cGroupTemplateDeclarationParserRuleCall_13 = (RuleCall)cAlternatives.eContents().get(13);
		private final RuleCall cGroupDeclarationParserRuleCall_14 = (RuleCall)cAlternatives.eContents().get(14);
		private final RuleCall cNatureDeclarationParserRuleCall_15 = (RuleCall)cAlternatives.eContents().get(15);
		private final RuleCall cSubnatureDeclarationParserRuleCall_16 = (RuleCall)cAlternatives.eContents().get(16);
		private final RuleCall cQuantityDeclarationParserRuleCall_17 = (RuleCall)cAlternatives.eContents().get(17);
		private final RuleCall cTerminalDeclarationParserRuleCall_18 = (RuleCall)cAlternatives.eContents().get(18);
		
		//EntityDeclarativeItem returns declaration::Declaration:
		//	SubprogramDeclaration | TypeDeclaration | SubtypeDeclaration | ConstantDeclaration | SignalDeclaration |
		//	VariableDeclaration | FileDeclaration | AliasDeclaration | AttributeDeclaration | AttributeSpecification |
		//	DisconnectionSpecification | LimitDeclaration | UseClauseDeclaration | GroupTemplateDeclaration | GroupDeclaration |
		//	NatureDeclaration | SubnatureDeclaration | QuantityDeclaration | TerminalDeclaration;
		public ParserRule getRule() { return rule; }

		//SubprogramDeclaration | TypeDeclaration | SubtypeDeclaration | ConstantDeclaration | SignalDeclaration |
		//VariableDeclaration | FileDeclaration | AliasDeclaration | AttributeDeclaration | AttributeSpecification |
		//DisconnectionSpecification | LimitDeclaration | UseClauseDeclaration | GroupTemplateDeclaration | GroupDeclaration |
		//NatureDeclaration | SubnatureDeclaration | QuantityDeclaration | TerminalDeclaration
		public Alternatives getAlternatives() { return cAlternatives; }

		//SubprogramDeclaration
		public RuleCall getSubprogramDeclarationParserRuleCall_0() { return cSubprogramDeclarationParserRuleCall_0; }

		//TypeDeclaration
		public RuleCall getTypeDeclarationParserRuleCall_1() { return cTypeDeclarationParserRuleCall_1; }

		//SubtypeDeclaration
		public RuleCall getSubtypeDeclarationParserRuleCall_2() { return cSubtypeDeclarationParserRuleCall_2; }

		//ConstantDeclaration
		public RuleCall getConstantDeclarationParserRuleCall_3() { return cConstantDeclarationParserRuleCall_3; }

		//SignalDeclaration
		public RuleCall getSignalDeclarationParserRuleCall_4() { return cSignalDeclarationParserRuleCall_4; }

		//VariableDeclaration
		public RuleCall getVariableDeclarationParserRuleCall_5() { return cVariableDeclarationParserRuleCall_5; }

		//FileDeclaration
		public RuleCall getFileDeclarationParserRuleCall_6() { return cFileDeclarationParserRuleCall_6; }

		//AliasDeclaration
		public RuleCall getAliasDeclarationParserRuleCall_7() { return cAliasDeclarationParserRuleCall_7; }

		//AttributeDeclaration
		public RuleCall getAttributeDeclarationParserRuleCall_8() { return cAttributeDeclarationParserRuleCall_8; }

		//AttributeSpecification
		public RuleCall getAttributeSpecificationParserRuleCall_9() { return cAttributeSpecificationParserRuleCall_9; }

		//DisconnectionSpecification
		public RuleCall getDisconnectionSpecificationParserRuleCall_10() { return cDisconnectionSpecificationParserRuleCall_10; }

		//LimitDeclaration
		public RuleCall getLimitDeclarationParserRuleCall_11() { return cLimitDeclarationParserRuleCall_11; }

		//UseClauseDeclaration
		public RuleCall getUseClauseDeclarationParserRuleCall_12() { return cUseClauseDeclarationParserRuleCall_12; }

		//GroupTemplateDeclaration
		public RuleCall getGroupTemplateDeclarationParserRuleCall_13() { return cGroupTemplateDeclarationParserRuleCall_13; }

		//GroupDeclaration
		public RuleCall getGroupDeclarationParserRuleCall_14() { return cGroupDeclarationParserRuleCall_14; }

		//NatureDeclaration
		public RuleCall getNatureDeclarationParserRuleCall_15() { return cNatureDeclarationParserRuleCall_15; }

		//SubnatureDeclaration
		public RuleCall getSubnatureDeclarationParserRuleCall_16() { return cSubnatureDeclarationParserRuleCall_16; }

		//QuantityDeclaration
		public RuleCall getQuantityDeclarationParserRuleCall_17() { return cQuantityDeclarationParserRuleCall_17; }

		//TerminalDeclaration
		public RuleCall getTerminalDeclarationParserRuleCall_18() { return cTerminalDeclarationParserRuleCall_18; }
	}

	public class PackageBodyDeclarativeItemElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PackageBodyDeclarativeItem");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSubprogramDeclarationParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cTypeDeclarationParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cSubtypeDeclarationParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cConstantDeclarationParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cVariableDeclarationParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cFileDeclarationParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cAliasDeclarationParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cUseClauseDeclarationParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		private final RuleCall cGroupTemplateDeclarationParserRuleCall_8 = (RuleCall)cAlternatives.eContents().get(8);
		private final RuleCall cGroupDeclarationParserRuleCall_9 = (RuleCall)cAlternatives.eContents().get(9);
		
		//PackageBodyDeclarativeItem returns declaration::Declaration:
		//	SubprogramDeclaration | TypeDeclaration | SubtypeDeclaration | ConstantDeclaration | VariableDeclaration |
		//	FileDeclaration | AliasDeclaration | UseClauseDeclaration | GroupTemplateDeclaration | GroupDeclaration;
		public ParserRule getRule() { return rule; }

		//SubprogramDeclaration | TypeDeclaration | SubtypeDeclaration | ConstantDeclaration | VariableDeclaration |
		//FileDeclaration | AliasDeclaration | UseClauseDeclaration | GroupTemplateDeclaration | GroupDeclaration
		public Alternatives getAlternatives() { return cAlternatives; }

		//SubprogramDeclaration
		public RuleCall getSubprogramDeclarationParserRuleCall_0() { return cSubprogramDeclarationParserRuleCall_0; }

		//TypeDeclaration
		public RuleCall getTypeDeclarationParserRuleCall_1() { return cTypeDeclarationParserRuleCall_1; }

		//SubtypeDeclaration
		public RuleCall getSubtypeDeclarationParserRuleCall_2() { return cSubtypeDeclarationParserRuleCall_2; }

		//ConstantDeclaration
		public RuleCall getConstantDeclarationParserRuleCall_3() { return cConstantDeclarationParserRuleCall_3; }

		//VariableDeclaration
		public RuleCall getVariableDeclarationParserRuleCall_4() { return cVariableDeclarationParserRuleCall_4; }

		//FileDeclaration
		public RuleCall getFileDeclarationParserRuleCall_5() { return cFileDeclarationParserRuleCall_5; }

		//AliasDeclaration
		public RuleCall getAliasDeclarationParserRuleCall_6() { return cAliasDeclarationParserRuleCall_6; }

		//UseClauseDeclaration
		public RuleCall getUseClauseDeclarationParserRuleCall_7() { return cUseClauseDeclarationParserRuleCall_7; }

		//GroupTemplateDeclaration
		public RuleCall getGroupTemplateDeclarationParserRuleCall_8() { return cGroupTemplateDeclarationParserRuleCall_8; }

		//GroupDeclaration
		public RuleCall getGroupDeclarationParserRuleCall_9() { return cGroupDeclarationParserRuleCall_9; }
	}

	public class PackageDeclarativeItemElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PackageDeclarativeItem");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSubprogramDeclarationParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cTypeDeclarationParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cSubtypeDeclarationParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cConstantDeclarationParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cSignalDeclarationParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cVariableDeclarationParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cFileDeclarationParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cAliasDeclarationParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		private final RuleCall cComponentParserRuleCall_8 = (RuleCall)cAlternatives.eContents().get(8);
		private final RuleCall cAttributeDeclarationParserRuleCall_9 = (RuleCall)cAlternatives.eContents().get(9);
		private final RuleCall cAttributeSpecificationParserRuleCall_10 = (RuleCall)cAlternatives.eContents().get(10);
		private final RuleCall cDisconnectionSpecificationParserRuleCall_11 = (RuleCall)cAlternatives.eContents().get(11);
		private final RuleCall cUseClauseDeclarationParserRuleCall_12 = (RuleCall)cAlternatives.eContents().get(12);
		private final RuleCall cGroupTemplateDeclarationParserRuleCall_13 = (RuleCall)cAlternatives.eContents().get(13);
		private final RuleCall cGroupDeclarationParserRuleCall_14 = (RuleCall)cAlternatives.eContents().get(14);
		private final RuleCall cNatureDeclarationParserRuleCall_15 = (RuleCall)cAlternatives.eContents().get(15);
		private final RuleCall cSubnatureDeclarationParserRuleCall_16 = (RuleCall)cAlternatives.eContents().get(16);
		private final RuleCall cTerminalDeclarationParserRuleCall_17 = (RuleCall)cAlternatives.eContents().get(17);
		
		//PackageDeclarativeItem returns declaration::Declaration:
		//	SubprogramDeclaration | TypeDeclaration | SubtypeDeclaration | ConstantDeclaration | SignalDeclaration |
		//	VariableDeclaration | FileDeclaration | AliasDeclaration | Component | AttributeDeclaration | AttributeSpecification |
		//	DisconnectionSpecification | UseClauseDeclaration | GroupTemplateDeclaration | GroupDeclaration | NatureDeclaration |
		//	SubnatureDeclaration | TerminalDeclaration;
		public ParserRule getRule() { return rule; }

		//SubprogramDeclaration | TypeDeclaration | SubtypeDeclaration | ConstantDeclaration | SignalDeclaration |
		//VariableDeclaration | FileDeclaration | AliasDeclaration | Component | AttributeDeclaration | AttributeSpecification |
		//DisconnectionSpecification | UseClauseDeclaration | GroupTemplateDeclaration | GroupDeclaration | NatureDeclaration |
		//SubnatureDeclaration | TerminalDeclaration
		public Alternatives getAlternatives() { return cAlternatives; }

		//SubprogramDeclaration
		public RuleCall getSubprogramDeclarationParserRuleCall_0() { return cSubprogramDeclarationParserRuleCall_0; }

		//TypeDeclaration
		public RuleCall getTypeDeclarationParserRuleCall_1() { return cTypeDeclarationParserRuleCall_1; }

		//SubtypeDeclaration
		public RuleCall getSubtypeDeclarationParserRuleCall_2() { return cSubtypeDeclarationParserRuleCall_2; }

		//ConstantDeclaration
		public RuleCall getConstantDeclarationParserRuleCall_3() { return cConstantDeclarationParserRuleCall_3; }

		//SignalDeclaration
		public RuleCall getSignalDeclarationParserRuleCall_4() { return cSignalDeclarationParserRuleCall_4; }

		//VariableDeclaration
		public RuleCall getVariableDeclarationParserRuleCall_5() { return cVariableDeclarationParserRuleCall_5; }

		//FileDeclaration
		public RuleCall getFileDeclarationParserRuleCall_6() { return cFileDeclarationParserRuleCall_6; }

		//AliasDeclaration
		public RuleCall getAliasDeclarationParserRuleCall_7() { return cAliasDeclarationParserRuleCall_7; }

		//Component
		public RuleCall getComponentParserRuleCall_8() { return cComponentParserRuleCall_8; }

		//AttributeDeclaration
		public RuleCall getAttributeDeclarationParserRuleCall_9() { return cAttributeDeclarationParserRuleCall_9; }

		//AttributeSpecification
		public RuleCall getAttributeSpecificationParserRuleCall_10() { return cAttributeSpecificationParserRuleCall_10; }

		//DisconnectionSpecification
		public RuleCall getDisconnectionSpecificationParserRuleCall_11() { return cDisconnectionSpecificationParserRuleCall_11; }

		//UseClauseDeclaration
		public RuleCall getUseClauseDeclarationParserRuleCall_12() { return cUseClauseDeclarationParserRuleCall_12; }

		//GroupTemplateDeclaration
		public RuleCall getGroupTemplateDeclarationParserRuleCall_13() { return cGroupTemplateDeclarationParserRuleCall_13; }

		//GroupDeclaration
		public RuleCall getGroupDeclarationParserRuleCall_14() { return cGroupDeclarationParserRuleCall_14; }

		//NatureDeclaration
		public RuleCall getNatureDeclarationParserRuleCall_15() { return cNatureDeclarationParserRuleCall_15; }

		//SubnatureDeclaration
		public RuleCall getSubnatureDeclarationParserRuleCall_16() { return cSubnatureDeclarationParserRuleCall_16; }

		//TerminalDeclaration
		public RuleCall getTerminalDeclarationParserRuleCall_17() { return cTerminalDeclarationParserRuleCall_17; }
	}

	public class ProceduralDeclarativeItemElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ProceduralDeclarativeItem");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSubprogramDeclarationParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cTypeDeclarationParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cSubtypeDeclarationParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cConstantDeclarationParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cVariableDeclarationParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cAliasDeclarationParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cAttributeDeclarationParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cAttributeSpecificationParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		private final RuleCall cUseClauseDeclarationParserRuleCall_8 = (RuleCall)cAlternatives.eContents().get(8);
		private final RuleCall cGroupTemplateDeclarationParserRuleCall_9 = (RuleCall)cAlternatives.eContents().get(9);
		private final RuleCall cGroupDeclarationParserRuleCall_10 = (RuleCall)cAlternatives.eContents().get(10);
		
		//ProceduralDeclarativeItem returns declaration::Declaration:
		//	SubprogramDeclaration | TypeDeclaration | SubtypeDeclaration | ConstantDeclaration | VariableDeclaration |
		//	AliasDeclaration | AttributeDeclaration | AttributeSpecification | UseClauseDeclaration | GroupTemplateDeclaration |
		//	GroupDeclaration;
		public ParserRule getRule() { return rule; }

		//SubprogramDeclaration | TypeDeclaration | SubtypeDeclaration | ConstantDeclaration | VariableDeclaration |
		//AliasDeclaration | AttributeDeclaration | AttributeSpecification | UseClauseDeclaration | GroupTemplateDeclaration |
		//GroupDeclaration
		public Alternatives getAlternatives() { return cAlternatives; }

		//SubprogramDeclaration
		public RuleCall getSubprogramDeclarationParserRuleCall_0() { return cSubprogramDeclarationParserRuleCall_0; }

		//TypeDeclaration
		public RuleCall getTypeDeclarationParserRuleCall_1() { return cTypeDeclarationParserRuleCall_1; }

		//SubtypeDeclaration
		public RuleCall getSubtypeDeclarationParserRuleCall_2() { return cSubtypeDeclarationParserRuleCall_2; }

		//ConstantDeclaration
		public RuleCall getConstantDeclarationParserRuleCall_3() { return cConstantDeclarationParserRuleCall_3; }

		//VariableDeclaration
		public RuleCall getVariableDeclarationParserRuleCall_4() { return cVariableDeclarationParserRuleCall_4; }

		//AliasDeclaration
		public RuleCall getAliasDeclarationParserRuleCall_5() { return cAliasDeclarationParserRuleCall_5; }

		//AttributeDeclaration
		public RuleCall getAttributeDeclarationParserRuleCall_6() { return cAttributeDeclarationParserRuleCall_6; }

		//AttributeSpecification
		public RuleCall getAttributeSpecificationParserRuleCall_7() { return cAttributeSpecificationParserRuleCall_7; }

		//UseClauseDeclaration
		public RuleCall getUseClauseDeclarationParserRuleCall_8() { return cUseClauseDeclarationParserRuleCall_8; }

		//GroupTemplateDeclaration
		public RuleCall getGroupTemplateDeclarationParserRuleCall_9() { return cGroupTemplateDeclarationParserRuleCall_9; }

		//GroupDeclaration
		public RuleCall getGroupDeclarationParserRuleCall_10() { return cGroupDeclarationParserRuleCall_10; }
	}

	public class ProcessDeclarativeItemElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ProcessDeclarativeItem");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSubprogramDeclarationParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cTypeDeclarationParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cSubtypeDeclarationParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cConstantDeclarationParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cVariableDeclarationParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cFileDeclarationParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cAliasDeclarationParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cAttributeDeclarationParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		private final RuleCall cAttributeSpecificationParserRuleCall_8 = (RuleCall)cAlternatives.eContents().get(8);
		private final RuleCall cUseClauseDeclarationParserRuleCall_9 = (RuleCall)cAlternatives.eContents().get(9);
		private final RuleCall cGroupTemplateDeclarationParserRuleCall_10 = (RuleCall)cAlternatives.eContents().get(10);
		private final RuleCall cGroupDeclarationParserRuleCall_11 = (RuleCall)cAlternatives.eContents().get(11);
		
		//ProcessDeclarativeItem returns declaration::Declaration:
		//	SubprogramDeclaration | TypeDeclaration | SubtypeDeclaration | ConstantDeclaration | VariableDeclaration |
		//	FileDeclaration | AliasDeclaration | AttributeDeclaration | AttributeSpecification | UseClauseDeclaration |
		//	GroupTemplateDeclaration | GroupDeclaration;
		public ParserRule getRule() { return rule; }

		//SubprogramDeclaration | TypeDeclaration | SubtypeDeclaration | ConstantDeclaration | VariableDeclaration |
		//FileDeclaration | AliasDeclaration | AttributeDeclaration | AttributeSpecification | UseClauseDeclaration |
		//GroupTemplateDeclaration | GroupDeclaration
		public Alternatives getAlternatives() { return cAlternatives; }

		//SubprogramDeclaration
		public RuleCall getSubprogramDeclarationParserRuleCall_0() { return cSubprogramDeclarationParserRuleCall_0; }

		//TypeDeclaration
		public RuleCall getTypeDeclarationParserRuleCall_1() { return cTypeDeclarationParserRuleCall_1; }

		//SubtypeDeclaration
		public RuleCall getSubtypeDeclarationParserRuleCall_2() { return cSubtypeDeclarationParserRuleCall_2; }

		//ConstantDeclaration
		public RuleCall getConstantDeclarationParserRuleCall_3() { return cConstantDeclarationParserRuleCall_3; }

		//VariableDeclaration
		public RuleCall getVariableDeclarationParserRuleCall_4() { return cVariableDeclarationParserRuleCall_4; }

		//FileDeclaration
		public RuleCall getFileDeclarationParserRuleCall_5() { return cFileDeclarationParserRuleCall_5; }

		//AliasDeclaration
		public RuleCall getAliasDeclarationParserRuleCall_6() { return cAliasDeclarationParserRuleCall_6; }

		//AttributeDeclaration
		public RuleCall getAttributeDeclarationParserRuleCall_7() { return cAttributeDeclarationParserRuleCall_7; }

		//AttributeSpecification
		public RuleCall getAttributeSpecificationParserRuleCall_8() { return cAttributeSpecificationParserRuleCall_8; }

		//UseClauseDeclaration
		public RuleCall getUseClauseDeclarationParserRuleCall_9() { return cUseClauseDeclarationParserRuleCall_9; }

		//GroupTemplateDeclaration
		public RuleCall getGroupTemplateDeclarationParserRuleCall_10() { return cGroupTemplateDeclarationParserRuleCall_10; }

		//GroupDeclaration
		public RuleCall getGroupDeclarationParserRuleCall_11() { return cGroupDeclarationParserRuleCall_11; }
	}

	public class SubprogramDeclarativeItemElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SubprogramDeclarativeItem");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSubprogramDeclarationParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cTypeDeclarationParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cSubtypeDeclarationParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cConstantDeclarationParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cVariableDeclarationParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cFileDeclarationParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cAliasDeclarationParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cAttributeDeclarationParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		private final RuleCall cAttributeSpecificationParserRuleCall_8 = (RuleCall)cAlternatives.eContents().get(8);
		private final RuleCall cUseClauseDeclarationParserRuleCall_9 = (RuleCall)cAlternatives.eContents().get(9);
		private final RuleCall cGroupTemplateDeclarationParserRuleCall_10 = (RuleCall)cAlternatives.eContents().get(10);
		private final RuleCall cGroupDeclarationParserRuleCall_11 = (RuleCall)cAlternatives.eContents().get(11);
		
		//SubprogramDeclarativeItem returns declaration::Declaration:
		//	SubprogramDeclaration | TypeDeclaration | SubtypeDeclaration | ConstantDeclaration | VariableDeclaration |
		//	FileDeclaration | AliasDeclaration | AttributeDeclaration | AttributeSpecification | UseClauseDeclaration |
		//	GroupTemplateDeclaration | GroupDeclaration;
		public ParserRule getRule() { return rule; }

		//SubprogramDeclaration | TypeDeclaration | SubtypeDeclaration | ConstantDeclaration | VariableDeclaration |
		//FileDeclaration | AliasDeclaration | AttributeDeclaration | AttributeSpecification | UseClauseDeclaration |
		//GroupTemplateDeclaration | GroupDeclaration
		public Alternatives getAlternatives() { return cAlternatives; }

		//SubprogramDeclaration
		public RuleCall getSubprogramDeclarationParserRuleCall_0() { return cSubprogramDeclarationParserRuleCall_0; }

		//TypeDeclaration
		public RuleCall getTypeDeclarationParserRuleCall_1() { return cTypeDeclarationParserRuleCall_1; }

		//SubtypeDeclaration
		public RuleCall getSubtypeDeclarationParserRuleCall_2() { return cSubtypeDeclarationParserRuleCall_2; }

		//ConstantDeclaration
		public RuleCall getConstantDeclarationParserRuleCall_3() { return cConstantDeclarationParserRuleCall_3; }

		//VariableDeclaration
		public RuleCall getVariableDeclarationParserRuleCall_4() { return cVariableDeclarationParserRuleCall_4; }

		//FileDeclaration
		public RuleCall getFileDeclarationParserRuleCall_5() { return cFileDeclarationParserRuleCall_5; }

		//AliasDeclaration
		public RuleCall getAliasDeclarationParserRuleCall_6() { return cAliasDeclarationParserRuleCall_6; }

		//AttributeDeclaration
		public RuleCall getAttributeDeclarationParserRuleCall_7() { return cAttributeDeclarationParserRuleCall_7; }

		//AttributeSpecification
		public RuleCall getAttributeSpecificationParserRuleCall_8() { return cAttributeSpecificationParserRuleCall_8; }

		//UseClauseDeclaration
		public RuleCall getUseClauseDeclarationParserRuleCall_9() { return cUseClauseDeclarationParserRuleCall_9; }

		//GroupTemplateDeclaration
		public RuleCall getGroupTemplateDeclarationParserRuleCall_10() { return cGroupTemplateDeclarationParserRuleCall_10; }

		//GroupDeclaration
		public RuleCall getGroupDeclarationParserRuleCall_11() { return cGroupDeclarationParserRuleCall_11; }
	}

	public class ArchitectureStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ArchitectureStatement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cProcessStatementParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cConfigurationInstantiationStatementParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cBlockStatementParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cConcurrentAssertionStatementParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cSimultaneousProceduralStatementParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cSimultaneousCaseStatementParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cSimultaneousIfStatementParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cConcurrentBreakStatementParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		private final RuleCall cEntityInstantiationStatementParserRuleCall_8 = (RuleCall)cAlternatives.eContents().get(8);
		private final RuleCall cConcurrentProcedureCallStatementParserRuleCall_9 = (RuleCall)cAlternatives.eContents().get(9);
		private final RuleCall cSelectedSignalAssignmentStatementParserRuleCall_10 = (RuleCall)cAlternatives.eContents().get(10);
		private final RuleCall cComponentInstantiationStatementParserRuleCall_11 = (RuleCall)cAlternatives.eContents().get(11);
		private final RuleCall cGenerateStatementParserRuleCall_12 = (RuleCall)cAlternatives.eContents().get(12);
		private final RuleCall cConditionalSignalAssignmentStatementParserRuleCall_13 = (RuleCall)cAlternatives.eContents().get(13);
		private final RuleCall cSimpleSimultaneousStatementParserRuleCall_14 = (RuleCall)cAlternatives.eContents().get(14);
		
		//ArchitectureStatement returns statement::Statement:
		//	ProcessStatement | ConfigurationInstantiationStatement | BlockStatement | ConcurrentAssertionStatement |
		//	SimultaneousProceduralStatement | SimultaneousCaseStatement | SimultaneousIfStatement | ConcurrentBreakStatement |
		//	EntityInstantiationStatement | ConcurrentProcedureCallStatement | SelectedSignalAssignmentStatement |
		//	ComponentInstantiationStatement | GenerateStatement | ConditionalSignalAssignmentStatement |
		//	SimpleSimultaneousStatement;
		public ParserRule getRule() { return rule; }

		//ProcessStatement | ConfigurationInstantiationStatement | BlockStatement | ConcurrentAssertionStatement |
		//SimultaneousProceduralStatement | SimultaneousCaseStatement | SimultaneousIfStatement | ConcurrentBreakStatement |
		//EntityInstantiationStatement | ConcurrentProcedureCallStatement | SelectedSignalAssignmentStatement |
		//ComponentInstantiationStatement | GenerateStatement | ConditionalSignalAssignmentStatement |
		//SimpleSimultaneousStatement
		public Alternatives getAlternatives() { return cAlternatives; }

		//ProcessStatement
		public RuleCall getProcessStatementParserRuleCall_0() { return cProcessStatementParserRuleCall_0; }

		//ConfigurationInstantiationStatement
		public RuleCall getConfigurationInstantiationStatementParserRuleCall_1() { return cConfigurationInstantiationStatementParserRuleCall_1; }

		//BlockStatement
		public RuleCall getBlockStatementParserRuleCall_2() { return cBlockStatementParserRuleCall_2; }

		//ConcurrentAssertionStatement
		public RuleCall getConcurrentAssertionStatementParserRuleCall_3() { return cConcurrentAssertionStatementParserRuleCall_3; }

		//SimultaneousProceduralStatement
		public RuleCall getSimultaneousProceduralStatementParserRuleCall_4() { return cSimultaneousProceduralStatementParserRuleCall_4; }

		//SimultaneousCaseStatement
		public RuleCall getSimultaneousCaseStatementParserRuleCall_5() { return cSimultaneousCaseStatementParserRuleCall_5; }

		//SimultaneousIfStatement
		public RuleCall getSimultaneousIfStatementParserRuleCall_6() { return cSimultaneousIfStatementParserRuleCall_6; }

		//ConcurrentBreakStatement
		public RuleCall getConcurrentBreakStatementParserRuleCall_7() { return cConcurrentBreakStatementParserRuleCall_7; }

		//EntityInstantiationStatement
		public RuleCall getEntityInstantiationStatementParserRuleCall_8() { return cEntityInstantiationStatementParserRuleCall_8; }

		//ConcurrentProcedureCallStatement
		public RuleCall getConcurrentProcedureCallStatementParserRuleCall_9() { return cConcurrentProcedureCallStatementParserRuleCall_9; }

		//SelectedSignalAssignmentStatement
		public RuleCall getSelectedSignalAssignmentStatementParserRuleCall_10() { return cSelectedSignalAssignmentStatementParserRuleCall_10; }

		//ComponentInstantiationStatement
		public RuleCall getComponentInstantiationStatementParserRuleCall_11() { return cComponentInstantiationStatementParserRuleCall_11; }

		//GenerateStatement
		public RuleCall getGenerateStatementParserRuleCall_12() { return cGenerateStatementParserRuleCall_12; }

		//ConditionalSignalAssignmentStatement
		public RuleCall getConditionalSignalAssignmentStatementParserRuleCall_13() { return cConditionalSignalAssignmentStatementParserRuleCall_13; }

		//SimpleSimultaneousStatement
		public RuleCall getSimpleSimultaneousStatementParserRuleCall_14() { return cSimpleSimultaneousStatementParserRuleCall_14; }
	}

	public class AccessTypeDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AccessTypeDefinition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cAccessKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTypeSubtypeIndicationParserRuleCall_1_0 = (RuleCall)cTypeAssignment_1.eContents().get(0);
		
		/// *
		// * ACCESS subtype_indication;
		// * / AccessTypeDefinition returns type::AccessTypeDefinition:
		//	"access" type=SubtypeIndication;
		public ParserRule getRule() { return rule; }

		//"access" type=SubtypeIndication
		public Group getGroup() { return cGroup; }

		//"access"
		public Keyword getAccessKeyword_0() { return cAccessKeyword_0; }

		//type=SubtypeIndication
		public Assignment getTypeAssignment_1() { return cTypeAssignment_1; }

		//SubtypeIndication
		public RuleCall getTypeSubtypeIndicationParserRuleCall_1_0() { return cTypeSubtypeIndicationParserRuleCall_1_0; }
	}

	public class ArrayNatureDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ArrayNatureDefinition");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cUnconstrainedArrayNatureDefinitionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cConstrainedArrayNatureDefinitionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//ArrayNatureDefinition returns nature::ArrayNatureDefinition:
		//	UnconstrainedArrayNatureDefinition | ConstrainedArrayNatureDefinition;
		public ParserRule getRule() { return rule; }

		//UnconstrainedArrayNatureDefinition | ConstrainedArrayNatureDefinition
		public Alternatives getAlternatives() { return cAlternatives; }

		//UnconstrainedArrayNatureDefinition
		public RuleCall getUnconstrainedArrayNatureDefinitionParserRuleCall_0() { return cUnconstrainedArrayNatureDefinitionParserRuleCall_0; }

		//ConstrainedArrayNatureDefinition
		public RuleCall getConstrainedArrayNatureDefinitionParserRuleCall_1() { return cConstrainedArrayNatureDefinitionParserRuleCall_1; }
	}

	public class ArrayTypeDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ArrayTypeDefinition");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cUnconstrainedArrayTypeDefinitionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cConstrainedArrayTypeDefinitionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//ArrayTypeDefinition returns type::ArrayTypeDefinition:
		//	UnconstrainedArrayTypeDefinition | ConstrainedArrayTypeDefinition;
		public ParserRule getRule() { return rule; }

		//UnconstrainedArrayTypeDefinition | ConstrainedArrayTypeDefinition
		public Alternatives getAlternatives() { return cAlternatives; }

		//UnconstrainedArrayTypeDefinition
		public RuleCall getUnconstrainedArrayTypeDefinitionParserRuleCall_0() { return cUnconstrainedArrayTypeDefinitionParserRuleCall_0; }

		//ConstrainedArrayTypeDefinition
		public RuleCall getConstrainedArrayTypeDefinitionParserRuleCall_1() { return cConstrainedArrayTypeDefinitionParserRuleCall_1; }
	}

	public class LabelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Label");
		private final RuleCall cIdentifierParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//Label:
		//	Identifier;
		public ParserRule getRule() { return rule; }

		//Identifier
		public RuleCall getIdentifierParserRuleCall() { return cIdentifierParserRuleCall; }
	}

	public class AssertionStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AssertionStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cGroup.eContents().get(0);
		private final Assignment cLabelAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final RuleCall cLabelLabelParserRuleCall_0_0_0 = (RuleCall)cLabelAssignment_0_0.eContents().get(0);
		private final Keyword cColonKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Keyword cAssertKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cConditionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cConditionExpressionParserRuleCall_2_0 = (RuleCall)cConditionAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cReportKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cReportAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cReportExpressionParserRuleCall_3_1_0 = (RuleCall)cReportAssignment_3_1.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cSeverityKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cSeverityAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cSeverityExpressionParserRuleCall_4_1_0 = (RuleCall)cSeverityAssignment_4_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		/// *
		// * [ label: ] assert boolean_condition [ report string ] [ severity name ] ;
		// * / AssertionStatement returns statement::AssertionStatement:
		//	(label=Label ":")? "assert" condition=Expression ("report" report=Expression)? ("severity" severity=Expression)? ";";
		public ParserRule getRule() { return rule; }

		//(label=Label ":")? "assert" condition=Expression ("report" report=Expression)? ("severity" severity=Expression)? ";"
		public Group getGroup() { return cGroup; }

		//(label=Label ":")?
		public Group getGroup_0() { return cGroup_0; }

		//label=Label
		public Assignment getLabelAssignment_0_0() { return cLabelAssignment_0_0; }

		//Label
		public RuleCall getLabelLabelParserRuleCall_0_0_0() { return cLabelLabelParserRuleCall_0_0_0; }

		//":"
		public Keyword getColonKeyword_0_1() { return cColonKeyword_0_1; }

		//"assert"
		public Keyword getAssertKeyword_1() { return cAssertKeyword_1; }

		//condition=Expression
		public Assignment getConditionAssignment_2() { return cConditionAssignment_2; }

		//Expression
		public RuleCall getConditionExpressionParserRuleCall_2_0() { return cConditionExpressionParserRuleCall_2_0; }

		//("report" report=Expression)?
		public Group getGroup_3() { return cGroup_3; }

		//"report"
		public Keyword getReportKeyword_3_0() { return cReportKeyword_3_0; }

		//report=Expression
		public Assignment getReportAssignment_3_1() { return cReportAssignment_3_1; }

		//Expression
		public RuleCall getReportExpressionParserRuleCall_3_1_0() { return cReportExpressionParserRuleCall_3_1_0; }

		//("severity" severity=Expression)?
		public Group getGroup_4() { return cGroup_4; }

		//"severity"
		public Keyword getSeverityKeyword_4_0() { return cSeverityKeyword_4_0; }

		//severity=Expression
		public Assignment getSeverityAssignment_4_1() { return cSeverityAssignment_4_1; }

		//Expression
		public RuleCall getSeverityExpressionParserRuleCall_4_1_0() { return cSeverityExpressionParserRuleCall_4_1_0; }

		//";"
		public Keyword getSemicolonKeyword_5() { return cSemicolonKeyword_5; }
	}

	public class ConcurrentAssertionStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ConcurrentAssertionStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cGroup.eContents().get(0);
		private final Assignment cLabelAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final RuleCall cLabelLabelParserRuleCall_0_0_0 = (RuleCall)cLabelAssignment_0_0.eContents().get(0);
		private final Keyword cColonKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Assignment cPostponedAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Keyword cPostponedPostponedKeyword_1_0 = (Keyword)cPostponedAssignment_1.eContents().get(0);
		private final Keyword cAssertKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cConditionAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cConditionExpressionParserRuleCall_3_0 = (RuleCall)cConditionAssignment_3.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cReportKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cReportAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cReportExpressionParserRuleCall_4_1_0 = (RuleCall)cReportAssignment_4_1.eContents().get(0);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cSeverityKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Assignment cSeverityAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cSeverityExpressionParserRuleCall_5_1_0 = (RuleCall)cSeverityAssignment_5_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		/// *
		// * [ label: ] [postponed] assert boolean_condition [ report string ] [ severity name ] ;
		// * / ConcurrentAssertionStatement returns statement::AssertionStatement:
		//	(label=Label ":")? postponed?="postponed"? "assert" condition=Expression ("report" report=Expression)? ("severity"
		//	severity=Expression)? ";";
		public ParserRule getRule() { return rule; }

		//(label=Label ":")? postponed?="postponed"? "assert" condition=Expression ("report" report=Expression)? ("severity"
		//severity=Expression)? ";"
		public Group getGroup() { return cGroup; }

		//(label=Label ":")?
		public Group getGroup_0() { return cGroup_0; }

		//label=Label
		public Assignment getLabelAssignment_0_0() { return cLabelAssignment_0_0; }

		//Label
		public RuleCall getLabelLabelParserRuleCall_0_0_0() { return cLabelLabelParserRuleCall_0_0_0; }

		//":"
		public Keyword getColonKeyword_0_1() { return cColonKeyword_0_1; }

		//postponed?="postponed"?
		public Assignment getPostponedAssignment_1() { return cPostponedAssignment_1; }

		//"postponed"
		public Keyword getPostponedPostponedKeyword_1_0() { return cPostponedPostponedKeyword_1_0; }

		//"assert"
		public Keyword getAssertKeyword_2() { return cAssertKeyword_2; }

		//condition=Expression
		public Assignment getConditionAssignment_3() { return cConditionAssignment_3; }

		//Expression
		public RuleCall getConditionExpressionParserRuleCall_3_0() { return cConditionExpressionParserRuleCall_3_0; }

		//("report" report=Expression)?
		public Group getGroup_4() { return cGroup_4; }

		//"report"
		public Keyword getReportKeyword_4_0() { return cReportKeyword_4_0; }

		//report=Expression
		public Assignment getReportAssignment_4_1() { return cReportAssignment_4_1; }

		//Expression
		public RuleCall getReportExpressionParserRuleCall_4_1_0() { return cReportExpressionParserRuleCall_4_1_0; }

		//("severity" severity=Expression)?
		public Group getGroup_5() { return cGroup_5; }

		//"severity"
		public Keyword getSeverityKeyword_5_0() { return cSeverityKeyword_5_0; }

		//severity=Expression
		public Assignment getSeverityAssignment_5_1() { return cSeverityAssignment_5_1; }

		//Expression
		public RuleCall getSeverityExpressionParserRuleCall_5_1_0() { return cSeverityExpressionParserRuleCall_5_1_0; }

		//";"
		public Keyword getSemicolonKeyword_6() { return cSemicolonKeyword_6; }
	}

	public class ParameterElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Parameter");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cAssociationExpressionAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Assignment cChoiceAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cChoiceChoicesParserRuleCall_0_1_0 = (RuleCall)cChoiceAssignment_0_1.eContents().get(0);
		private final Keyword cEqualsSignGreaterThanSignKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final Alternatives cAlternatives_0_3 = (Alternatives)cGroup_0.eContents().get(3);
		private final Assignment cExpressionAssignment_0_3_0 = (Assignment)cAlternatives_0_3.eContents().get(0);
		private final RuleCall cExpressionExpressionParserRuleCall_0_3_0_0 = (RuleCall)cExpressionAssignment_0_3_0.eContents().get(0);
		private final Keyword cOpenKeyword_0_3_1 = (Keyword)cAlternatives_0_3.eContents().get(1);
		private final RuleCall cExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cOpenParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//Parameter returns expression::Expression:
		//	{expression::AssociationExpression} choice=Choices "=>" (expression=Expression | "open") | Expression | Open;
		public ParserRule getRule() { return rule; }

		//{expression::AssociationExpression} choice=Choices "=>" (expression=Expression | "open") | Expression | Open
		public Alternatives getAlternatives() { return cAlternatives; }

		//{expression::AssociationExpression} choice=Choices "=>" (expression=Expression | "open")
		public Group getGroup_0() { return cGroup_0; }

		//{expression::AssociationExpression}
		public Action getAssociationExpressionAction_0_0() { return cAssociationExpressionAction_0_0; }

		//choice=Choices
		public Assignment getChoiceAssignment_0_1() { return cChoiceAssignment_0_1; }

		//Choices
		public RuleCall getChoiceChoicesParserRuleCall_0_1_0() { return cChoiceChoicesParserRuleCall_0_1_0; }

		//"=>"
		public Keyword getEqualsSignGreaterThanSignKeyword_0_2() { return cEqualsSignGreaterThanSignKeyword_0_2; }

		//expression=Expression | "open"
		public Alternatives getAlternatives_0_3() { return cAlternatives_0_3; }

		//expression=Expression
		public Assignment getExpressionAssignment_0_3_0() { return cExpressionAssignment_0_3_0; }

		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_0_3_0_0() { return cExpressionExpressionParserRuleCall_0_3_0_0; }

		//"open"
		public Keyword getOpenKeyword_0_3_1() { return cOpenKeyword_0_3_1; }

		//Expression
		public RuleCall getExpressionParserRuleCall_1() { return cExpressionParserRuleCall_1; }

		//Open
		public RuleCall getOpenParserRuleCall_2() { return cOpenParserRuleCall_2; }
	}

	public class ChoicesElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Choices");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cChoiceParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cMultiExpressionExpressionAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cGroup_1.eContents().get(1);
		private final Keyword cVerticalLineKeyword_1_1_0 = (Keyword)cGroup_1_1.eContents().get(0);
		private final Assignment cExpressionAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cExpressionChoiceParserRuleCall_1_1_1_0 = (RuleCall)cExpressionAssignment_1_1_1.eContents().get(0);
		
		//Choices returns expression::Expression:
		//	Choice ({expression::MultiExpression.expression+=current} ("|" expression+=Choice)+)?;
		public ParserRule getRule() { return rule; }

		//Choice ({expression::MultiExpression.expression+=current} ("|" expression+=Choice)+)?
		public Group getGroup() { return cGroup; }

		//Choice
		public RuleCall getChoiceParserRuleCall_0() { return cChoiceParserRuleCall_0; }

		//({expression::MultiExpression.expression+=current} ("|" expression+=Choice)+)?
		public Group getGroup_1() { return cGroup_1; }

		//{expression::MultiExpression.expression+=current}
		public Action getMultiExpressionExpressionAction_1_0() { return cMultiExpressionExpressionAction_1_0; }

		//("|" expression+=Choice)+
		public Group getGroup_1_1() { return cGroup_1_1; }

		//"|"
		public Keyword getVerticalLineKeyword_1_1_0() { return cVerticalLineKeyword_1_1_0; }

		//expression+=Choice
		public Assignment getExpressionAssignment_1_1_1() { return cExpressionAssignment_1_1_1; }

		//Choice
		public RuleCall getExpressionChoiceParserRuleCall_1_1_1_0() { return cExpressionChoiceParserRuleCall_1_1_1_0; }
	}

	public class ChoiceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Choice");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cRangeSpecificationParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cSubtypeIndicationExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cSimpleExpressionParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cOthersParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//Choice returns expression::Expression:
		//	RangeSpecification | SubtypeIndicationExpression | SimpleExpression | Others;
		public ParserRule getRule() { return rule; }

		//RangeSpecification | SubtypeIndicationExpression | SimpleExpression | Others
		public Alternatives getAlternatives() { return cAlternatives; }

		//RangeSpecification
		public RuleCall getRangeSpecificationParserRuleCall_0() { return cRangeSpecificationParserRuleCall_0; }

		//SubtypeIndicationExpression
		public RuleCall getSubtypeIndicationExpressionParserRuleCall_1() { return cSubtypeIndicationExpressionParserRuleCall_1; }

		//SimpleExpression
		public RuleCall getSimpleExpressionParserRuleCall_2() { return cSimpleExpressionParserRuleCall_2; }

		//Others
		public RuleCall getOthersParserRuleCall_3() { return cOthersParserRuleCall_3; }
	}

	public class OpenElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Open");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cOpenExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cOpenKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//Open returns expression::OpenExpression:
		//	{expression::OpenExpression} "open";
		public ParserRule getRule() { return rule; }

		//{expression::OpenExpression} "open"
		public Group getGroup() { return cGroup; }

		//{expression::OpenExpression}
		public Action getOpenExpressionAction_0() { return cOpenExpressionAction_0; }

		//"open"
		public Keyword getOpenKeyword_1() { return cOpenKeyword_1; }
	}

	public class AttributeDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AttributeDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cAttributeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIdentifierNameParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cTypeAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cTypeIdentifierNameParserRuleCall_3_0 = (RuleCall)cTypeAssignment_3.eContents().get(0);
		private final Keyword cSemicolonKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		/// *
		// * attribute identifier : type_mark ;
		// * / AttributeDeclaration returns declaration::AttributeDeclaration:
		//	"attribute" name=IdentifierName ":" type=IdentifierName ";";
		public ParserRule getRule() { return rule; }

		//"attribute" name=IdentifierName ":" type=IdentifierName ";"
		public Group getGroup() { return cGroup; }

		//"attribute"
		public Keyword getAttributeKeyword_0() { return cAttributeKeyword_0; }

		//name=IdentifierName
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//IdentifierName
		public RuleCall getNameIdentifierNameParserRuleCall_1_0() { return cNameIdentifierNameParserRuleCall_1_0; }

		//":"
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }

		//type=IdentifierName
		public Assignment getTypeAssignment_3() { return cTypeAssignment_3; }

		//IdentifierName
		public RuleCall getTypeIdentifierNameParserRuleCall_3_0() { return cTypeIdentifierNameParserRuleCall_3_0; }

		//";"
		public Keyword getSemicolonKeyword_4() { return cSemicolonKeyword_4; }
	}

	public class AttributeSpecificationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AttributeSpecification");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cAttributeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameAttributeDesignatorParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cOfKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cEntityAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cEntityAttributeEntityParserRuleCall_3_0 = (RuleCall)cEntityAssignment_3.eContents().get(0);
		private final Keyword cColonKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cClassAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cClassEntityClassEnumRuleCall_5_0 = (RuleCall)cClassAssignment_5.eContents().get(0);
		private final Keyword cIsKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Assignment cIsAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cIsExpressionParserRuleCall_7_0 = (RuleCall)cIsAssignment_7.eContents().get(0);
		private final Keyword cSemicolonKeyword_8 = (Keyword)cGroup.eContents().get(8);
		
		/// *
		// * attribute_specification = "attribute" attribute_designator "of" entity_specification "is" expression ";"
		// *  entity_specification = entity_name_list ":" entity_class
		// * / AttributeSpecification returns declaration::AttributeSpecification:
		//	"attribute" name=AttributeDesignator "of" entity=AttributeEntity ":" class=EntityClass "is" is=Expression ";";
		public ParserRule getRule() { return rule; }

		//"attribute" name=AttributeDesignator "of" entity=AttributeEntity ":" class=EntityClass "is" is=Expression ";"
		public Group getGroup() { return cGroup; }

		//"attribute"
		public Keyword getAttributeKeyword_0() { return cAttributeKeyword_0; }

		//name=AttributeDesignator
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//AttributeDesignator
		public RuleCall getNameAttributeDesignatorParserRuleCall_1_0() { return cNameAttributeDesignatorParserRuleCall_1_0; }

		//"of"
		public Keyword getOfKeyword_2() { return cOfKeyword_2; }

		//entity=AttributeEntity
		public Assignment getEntityAssignment_3() { return cEntityAssignment_3; }

		//AttributeEntity
		public RuleCall getEntityAttributeEntityParserRuleCall_3_0() { return cEntityAttributeEntityParserRuleCall_3_0; }

		//":"
		public Keyword getColonKeyword_4() { return cColonKeyword_4; }

		//class=EntityClass
		public Assignment getClassAssignment_5() { return cClassAssignment_5; }

		//EntityClass
		public RuleCall getClassEntityClassEnumRuleCall_5_0() { return cClassEntityClassEnumRuleCall_5_0; }

		//"is"
		public Keyword getIsKeyword_6() { return cIsKeyword_6; }

		//is=Expression
		public Assignment getIsAssignment_7() { return cIsAssignment_7; }

		//Expression
		public RuleCall getIsExpressionParserRuleCall_7_0() { return cIsExpressionParserRuleCall_7_0; }

		//";"
		public Keyword getSemicolonKeyword_8() { return cSemicolonKeyword_8; }
	}

	public class AttributeDesignatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AttributeDesignator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIdentifierNameParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cIdentifierExpressionAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cValueAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cValueRangeKeyword_1_1_0 = (Keyword)cValueAssignment_1_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Action cIdentifierExpressionAction_2_0 = (Action)cGroup_2.eContents().get(0);
		private final Assignment cValueAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final Keyword cValueAcrossKeyword_2_1_0 = (Keyword)cValueAssignment_2_1.eContents().get(0);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final Action cIdentifierExpressionAction_3_0 = (Action)cGroup_3.eContents().get(0);
		private final Assignment cValueAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final Keyword cValueThroughKeyword_3_1_0 = (Keyword)cValueAssignment_3_1.eContents().get(0);
		private final Group cGroup_4 = (Group)cAlternatives.eContents().get(4);
		private final Action cIdentifierExpressionAction_4_0 = (Action)cGroup_4.eContents().get(0);
		private final Assignment cValueAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final Keyword cValueReferenceKeyword_4_1_0 = (Keyword)cValueAssignment_4_1.eContents().get(0);
		private final Group cGroup_5 = (Group)cAlternatives.eContents().get(5);
		private final Action cIdentifierExpressionAction_5_0 = (Action)cGroup_5.eContents().get(0);
		private final Assignment cValueAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final Keyword cValueToleranceKeyword_5_1_0 = (Keyword)cValueAssignment_5_1.eContents().get(0);
		
		//AttributeDesignator returns Name:
		//	IdentifierName | {expression::IdentifierExpression} value="range" | {expression::IdentifierExpression} value="across"
		//	| {expression::IdentifierExpression} value="through" | {expression::IdentifierExpression} value="reference" |
		//	{expression::IdentifierExpression} value="tolerance";
		public ParserRule getRule() { return rule; }

		//IdentifierName | {expression::IdentifierExpression} value="range" | {expression::IdentifierExpression} value="across" |
		//{expression::IdentifierExpression} value="through" | {expression::IdentifierExpression} value="reference" |
		//{expression::IdentifierExpression} value="tolerance"
		public Alternatives getAlternatives() { return cAlternatives; }

		//IdentifierName
		public RuleCall getIdentifierNameParserRuleCall_0() { return cIdentifierNameParserRuleCall_0; }

		//{expression::IdentifierExpression} value="range"
		public Group getGroup_1() { return cGroup_1; }

		//{expression::IdentifierExpression}
		public Action getIdentifierExpressionAction_1_0() { return cIdentifierExpressionAction_1_0; }

		//value="range"
		public Assignment getValueAssignment_1_1() { return cValueAssignment_1_1; }

		//"range"
		public Keyword getValueRangeKeyword_1_1_0() { return cValueRangeKeyword_1_1_0; }

		//{expression::IdentifierExpression} value="across"
		public Group getGroup_2() { return cGroup_2; }

		//{expression::IdentifierExpression}
		public Action getIdentifierExpressionAction_2_0() { return cIdentifierExpressionAction_2_0; }

		//value="across"
		public Assignment getValueAssignment_2_1() { return cValueAssignment_2_1; }

		//"across"
		public Keyword getValueAcrossKeyword_2_1_0() { return cValueAcrossKeyword_2_1_0; }

		//{expression::IdentifierExpression} value="through"
		public Group getGroup_3() { return cGroup_3; }

		//{expression::IdentifierExpression}
		public Action getIdentifierExpressionAction_3_0() { return cIdentifierExpressionAction_3_0; }

		//value="through"
		public Assignment getValueAssignment_3_1() { return cValueAssignment_3_1; }

		//"through"
		public Keyword getValueThroughKeyword_3_1_0() { return cValueThroughKeyword_3_1_0; }

		//{expression::IdentifierExpression} value="reference"
		public Group getGroup_4() { return cGroup_4; }

		//{expression::IdentifierExpression}
		public Action getIdentifierExpressionAction_4_0() { return cIdentifierExpressionAction_4_0; }

		//value="reference"
		public Assignment getValueAssignment_4_1() { return cValueAssignment_4_1; }

		//"reference"
		public Keyword getValueReferenceKeyword_4_1_0() { return cValueReferenceKeyword_4_1_0; }

		//{expression::IdentifierExpression} value="tolerance"
		public Group getGroup_5() { return cGroup_5; }

		//{expression::IdentifierExpression}
		public Action getIdentifierExpressionAction_5_0() { return cIdentifierExpressionAction_5_0; }

		//value="tolerance"
		public Assignment getValueAssignment_5_1() { return cValueAssignment_5_1; }

		//"tolerance"
		public Keyword getValueToleranceKeyword_5_1_0() { return cValueToleranceKeyword_5_1_0; }
	}

	public class AttributeEntityElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AttributeEntity");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAttributeEntityDesignatorParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cNameListNameAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cGroup_1.eContents().get(1);
		private final Keyword cCommaKeyword_1_1_0 = (Keyword)cGroup_1_1.eContents().get(0);
		private final Assignment cNameAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cNameAttributeEntityDesignatorParserRuleCall_1_1_1_0 = (RuleCall)cNameAssignment_1_1_1.eContents().get(0);
		
		/// *
		// * entity_name_list = entity_designator { "," entity_designator }
		// *                  | "others"
		// *                  | "all"
		// * / AttributeEntity returns MultiName:
		//	AttributeEntityDesignator ({NameList.name+=current} ("," name+=AttributeEntityDesignator)+)?;
		public ParserRule getRule() { return rule; }

		//AttributeEntityDesignator ({NameList.name+=current} ("," name+=AttributeEntityDesignator)+)?
		public Group getGroup() { return cGroup; }

		//AttributeEntityDesignator
		public RuleCall getAttributeEntityDesignatorParserRuleCall_0() { return cAttributeEntityDesignatorParserRuleCall_0; }

		//({NameList.name+=current} ("," name+=AttributeEntityDesignator)+)?
		public Group getGroup_1() { return cGroup_1; }

		//{NameList.name+=current}
		public Action getNameListNameAction_1_0() { return cNameListNameAction_1_0; }

		//("," name+=AttributeEntityDesignator)+
		public Group getGroup_1_1() { return cGroup_1_1; }

		//","
		public Keyword getCommaKeyword_1_1_0() { return cCommaKeyword_1_1_0; }

		//name+=AttributeEntityDesignator
		public Assignment getNameAssignment_1_1_1() { return cNameAssignment_1_1_1; }

		//AttributeEntityDesignator
		public RuleCall getNameAttributeEntityDesignatorParserRuleCall_1_1_1_0() { return cNameAttributeEntityDesignatorParserRuleCall_1_1_1_0; }
	}

	public class AttributeEntityDesignatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AttributeEntityDesignator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final RuleCall cIdentifierNameParserRuleCall_0_0 = (RuleCall)cGroup_0.eContents().get(0);
		private final Group cGroup_0_1 = (Group)cGroup_0.eContents().get(1);
		private final Action cSignatureExpressionNameAction_0_1_0 = (Action)cGroup_0_1.eContents().get(0);
		private final Assignment cSignatureAssignment_0_1_1 = (Assignment)cGroup_0_1.eContents().get(1);
		private final RuleCall cSignatureSignatureParserRuleCall_0_1_1_0 = (RuleCall)cSignatureAssignment_0_1_1.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final RuleCall cCharacterNameParserRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cGroup_1.eContents().get(1);
		private final Action cSignatureExpressionNameAction_1_1_0 = (Action)cGroup_1_1.eContents().get(0);
		private final Assignment cSignatureAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cSignatureSignatureParserRuleCall_1_1_1_0 = (RuleCall)cSignatureAssignment_1_1_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final RuleCall cStringNameParserRuleCall_2_0 = (RuleCall)cGroup_2.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Action cSignatureExpressionNameAction_2_1_0 = (Action)cGroup_2_1.eContents().get(0);
		private final Assignment cSignatureAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cSignatureSignatureParserRuleCall_2_1_1_0 = (RuleCall)cSignatureAssignment_2_1_1.eContents().get(0);
		private final RuleCall cOthersParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cAllParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		
		//AttributeEntityDesignator returns Name:
		//	IdentifierName ({expression::SignatureExpression.name=current} signature=Signature)? | CharacterName
		//	({expression::SignatureExpression.name=current} signature=Signature)? | StringName
		//	({expression::SignatureExpression.name=current} signature=Signature)? | Others | All;
		public ParserRule getRule() { return rule; }

		//IdentifierName ({expression::SignatureExpression.name=current} signature=Signature)? | CharacterName
		//({expression::SignatureExpression.name=current} signature=Signature)? | StringName
		//({expression::SignatureExpression.name=current} signature=Signature)? | Others | All
		public Alternatives getAlternatives() { return cAlternatives; }

		//IdentifierName ({expression::SignatureExpression.name=current} signature=Signature)?
		public Group getGroup_0() { return cGroup_0; }

		//IdentifierName
		public RuleCall getIdentifierNameParserRuleCall_0_0() { return cIdentifierNameParserRuleCall_0_0; }

		//({expression::SignatureExpression.name=current} signature=Signature)?
		public Group getGroup_0_1() { return cGroup_0_1; }

		//{expression::SignatureExpression.name=current}
		public Action getSignatureExpressionNameAction_0_1_0() { return cSignatureExpressionNameAction_0_1_0; }

		//signature=Signature
		public Assignment getSignatureAssignment_0_1_1() { return cSignatureAssignment_0_1_1; }

		//Signature
		public RuleCall getSignatureSignatureParserRuleCall_0_1_1_0() { return cSignatureSignatureParserRuleCall_0_1_1_0; }

		//CharacterName ({expression::SignatureExpression.name=current} signature=Signature)?
		public Group getGroup_1() { return cGroup_1; }

		//CharacterName
		public RuleCall getCharacterNameParserRuleCall_1_0() { return cCharacterNameParserRuleCall_1_0; }

		//({expression::SignatureExpression.name=current} signature=Signature)?
		public Group getGroup_1_1() { return cGroup_1_1; }

		//{expression::SignatureExpression.name=current}
		public Action getSignatureExpressionNameAction_1_1_0() { return cSignatureExpressionNameAction_1_1_0; }

		//signature=Signature
		public Assignment getSignatureAssignment_1_1_1() { return cSignatureAssignment_1_1_1; }

		//Signature
		public RuleCall getSignatureSignatureParserRuleCall_1_1_1_0() { return cSignatureSignatureParserRuleCall_1_1_1_0; }

		//StringName ({expression::SignatureExpression.name=current} signature=Signature)?
		public Group getGroup_2() { return cGroup_2; }

		//StringName
		public RuleCall getStringNameParserRuleCall_2_0() { return cStringNameParserRuleCall_2_0; }

		//({expression::SignatureExpression.name=current} signature=Signature)?
		public Group getGroup_2_1() { return cGroup_2_1; }

		//{expression::SignatureExpression.name=current}
		public Action getSignatureExpressionNameAction_2_1_0() { return cSignatureExpressionNameAction_2_1_0; }

		//signature=Signature
		public Assignment getSignatureAssignment_2_1_1() { return cSignatureAssignment_2_1_1; }

		//Signature
		public RuleCall getSignatureSignatureParserRuleCall_2_1_1_0() { return cSignatureSignatureParserRuleCall_2_1_1_0; }

		//Others
		public RuleCall getOthersParserRuleCall_3() { return cOthersParserRuleCall_3; }

		//All
		public RuleCall getAllParserRuleCall_4() { return cAllParserRuleCall_4; }
	}

	public class NameSignatureElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NameSignature");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cNameParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cSignatureExpressionNameAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cSignatureAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cSignatureSignatureParserRuleCall_1_1_0 = (RuleCall)cSignatureAssignment_1_1.eContents().get(0);
		
		//NameSignature returns Name:
		//	Name ({expression::SignatureExpression.name=current} signature=Signature)?;
		public ParserRule getRule() { return rule; }

		//Name ({expression::SignatureExpression.name=current} signature=Signature)?
		public Group getGroup() { return cGroup; }

		//Name
		public RuleCall getNameParserRuleCall_0() { return cNameParserRuleCall_0; }

		//({expression::SignatureExpression.name=current} signature=Signature)?
		public Group getGroup_1() { return cGroup_1; }

		//{expression::SignatureExpression.name=current}
		public Action getSignatureExpressionNameAction_1_0() { return cSignatureExpressionNameAction_1_0; }

		//signature=Signature
		public Assignment getSignatureAssignment_1_1() { return cSignatureAssignment_1_1; }

		//Signature
		public RuleCall getSignatureSignatureParserRuleCall_1_1_0() { return cSignatureSignatureParserRuleCall_1_1_0; }
	}

	public class BlockConfigurationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BlockConfiguration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cForKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameNameParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cUseKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cUseAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cUseNameParserRuleCall_2_1_0 = (RuleCall)cUseAssignment_2_1.eContents().get(0);
		private final Group cGroup_2_2 = (Group)cGroup_2.eContents().get(2);
		private final Keyword cCommaKeyword_2_2_0 = (Keyword)cGroup_2_2.eContents().get(0);
		private final Assignment cUseAssignment_2_2_1 = (Assignment)cGroup_2_2.eContents().get(1);
		private final RuleCall cUseNameParserRuleCall_2_2_1_0 = (RuleCall)cUseAssignment_2_2_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_2_3 = (Keyword)cGroup_2.eContents().get(3);
		private final Assignment cItemAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cItemConfigurationItemParserRuleCall_3_0 = (RuleCall)cItemAssignment_3.eContents().get(0);
		private final Keyword cEndKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cForKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Keyword cSemicolonKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//BlockConfiguration returns configuration::BlockConfiguration:
		//	"for" name=Name ("use" use+=Name ("," use+=Name)* ";")* item+=ConfigurationItem* "end" "for" ";";
		public ParserRule getRule() { return rule; }

		//"for" name=Name ("use" use+=Name ("," use+=Name)* ";")* item+=ConfigurationItem* "end" "for" ";"
		public Group getGroup() { return cGroup; }

		//"for"
		public Keyword getForKeyword_0() { return cForKeyword_0; }

		//name=Name
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//Name
		public RuleCall getNameNameParserRuleCall_1_0() { return cNameNameParserRuleCall_1_0; }

		//("use" use+=Name ("," use+=Name)* ";")*
		public Group getGroup_2() { return cGroup_2; }

		//"use"
		public Keyword getUseKeyword_2_0() { return cUseKeyword_2_0; }

		//use+=Name
		public Assignment getUseAssignment_2_1() { return cUseAssignment_2_1; }

		//Name
		public RuleCall getUseNameParserRuleCall_2_1_0() { return cUseNameParserRuleCall_2_1_0; }

		//("," use+=Name)*
		public Group getGroup_2_2() { return cGroup_2_2; }

		//","
		public Keyword getCommaKeyword_2_2_0() { return cCommaKeyword_2_2_0; }

		//use+=Name
		public Assignment getUseAssignment_2_2_1() { return cUseAssignment_2_2_1; }

		//Name
		public RuleCall getUseNameParserRuleCall_2_2_1_0() { return cUseNameParserRuleCall_2_2_1_0; }

		//";"
		public Keyword getSemicolonKeyword_2_3() { return cSemicolonKeyword_2_3; }

		//item+=ConfigurationItem*
		public Assignment getItemAssignment_3() { return cItemAssignment_3; }

		//ConfigurationItem
		public RuleCall getItemConfigurationItemParserRuleCall_3_0() { return cItemConfigurationItemParserRuleCall_3_0; }

		//"end"
		public Keyword getEndKeyword_4() { return cEndKeyword_4; }

		//"for"
		public Keyword getForKeyword_5() { return cForKeyword_5; }

		//";"
		public Keyword getSemicolonKeyword_6() { return cSemicolonKeyword_6; }
	}

	public class BlockStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BlockStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLabelAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLabelLabelParserRuleCall_0_0 = (RuleCall)cLabelAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cBlockKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cLeftParenthesisKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cGuardAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cGuardExpressionParserRuleCall_3_1_0 = (RuleCall)cGuardAssignment_3_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3_2 = (Keyword)cGroup_3.eContents().get(2);
		private final Keyword cIsKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Assignment cGenericAssignment_5_0 = (Assignment)cGroup_5.eContents().get(0);
		private final RuleCall cGenericGenericsParserRuleCall_5_0_0 = (RuleCall)cGenericAssignment_5_0.eContents().get(0);
		private final Group cGroup_5_1 = (Group)cGroup_5.eContents().get(1);
		private final Assignment cGenericMapAssignment_5_1_0 = (Assignment)cGroup_5_1.eContents().get(0);
		private final RuleCall cGenericMapGenericMapsParserRuleCall_5_1_0_0 = (RuleCall)cGenericMapAssignment_5_1_0.eContents().get(0);
		private final Keyword cSemicolonKeyword_5_1_1 = (Keyword)cGroup_5_1.eContents().get(1);
		private final Group cGroup_6 = (Group)cGroup.eContents().get(6);
		private final Assignment cPortAssignment_6_0 = (Assignment)cGroup_6.eContents().get(0);
		private final RuleCall cPortPortsParserRuleCall_6_0_0 = (RuleCall)cPortAssignment_6_0.eContents().get(0);
		private final Group cGroup_6_1 = (Group)cGroup_6.eContents().get(1);
		private final Assignment cPortMapAssignment_6_1_0 = (Assignment)cGroup_6_1.eContents().get(0);
		private final RuleCall cPortMapPortMapsParserRuleCall_6_1_0_0 = (RuleCall)cPortMapAssignment_6_1_0.eContents().get(0);
		private final Keyword cSemicolonKeyword_6_1_1 = (Keyword)cGroup_6_1.eContents().get(1);
		private final Assignment cDeclarationAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cDeclarationBlockDeclarativeItemParserRuleCall_7_0 = (RuleCall)cDeclarationAssignment_7.eContents().get(0);
		private final Keyword cBeginKeyword_8 = (Keyword)cGroup.eContents().get(8);
		private final Assignment cStatementAssignment_9 = (Assignment)cGroup.eContents().get(9);
		private final RuleCall cStatementArchitectureStatementParserRuleCall_9_0 = (RuleCall)cStatementAssignment_9.eContents().get(0);
		private final Keyword cEndKeyword_10 = (Keyword)cGroup.eContents().get(10);
		private final Keyword cBlockKeyword_11 = (Keyword)cGroup.eContents().get(11);
		private final RuleCall cIdentifierParserRuleCall_12 = (RuleCall)cGroup.eContents().get(12);
		private final Keyword cSemicolonKeyword_13 = (Keyword)cGroup.eContents().get(13);
		
		/// *
		// * label : block [ ( guard expression ) ] [ is ]
		// *            [ generic clause [ generic map aspect ; ] ]
		// *            [ port clause [ port map aspect ; ] ]
		// *            [ block declarative items ]
		// *         begin
		// *            concurrent statements
		// *         end block [ label ] ;
		// * / BlockStatement returns statement::BlockStatement:
		//	label=Label ":" "block" ("(" guard=Expression ")")? "is"? (generic=Generics (genericMap=GenericMaps ";")?)?
		//	(port=Ports (portMap=PortMaps ";")?)? declaration+=BlockDeclarativeItem* "begin" statement+=ArchitectureStatement*
		//	"end" "block" Identifier? ";";
		public ParserRule getRule() { return rule; }

		//label=Label ":" "block" ("(" guard=Expression ")")? "is"? (generic=Generics (genericMap=GenericMaps ";")?)? (port=Ports
		//(portMap=PortMaps ";")?)? declaration+=BlockDeclarativeItem* "begin" statement+=ArchitectureStatement* "end" "block"
		//Identifier? ";"
		public Group getGroup() { return cGroup; }

		//label=Label
		public Assignment getLabelAssignment_0() { return cLabelAssignment_0; }

		//Label
		public RuleCall getLabelLabelParserRuleCall_0_0() { return cLabelLabelParserRuleCall_0_0; }

		//":"
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }

		//"block"
		public Keyword getBlockKeyword_2() { return cBlockKeyword_2; }

		//("(" guard=Expression ")")?
		public Group getGroup_3() { return cGroup_3; }

		//"("
		public Keyword getLeftParenthesisKeyword_3_0() { return cLeftParenthesisKeyword_3_0; }

		//guard=Expression
		public Assignment getGuardAssignment_3_1() { return cGuardAssignment_3_1; }

		//Expression
		public RuleCall getGuardExpressionParserRuleCall_3_1_0() { return cGuardExpressionParserRuleCall_3_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3_2() { return cRightParenthesisKeyword_3_2; }

		//"is"?
		public Keyword getIsKeyword_4() { return cIsKeyword_4; }

		//(generic=Generics (genericMap=GenericMaps ";")?)?
		public Group getGroup_5() { return cGroup_5; }

		//generic=Generics
		public Assignment getGenericAssignment_5_0() { return cGenericAssignment_5_0; }

		//Generics
		public RuleCall getGenericGenericsParserRuleCall_5_0_0() { return cGenericGenericsParserRuleCall_5_0_0; }

		//(genericMap=GenericMaps ";")?
		public Group getGroup_5_1() { return cGroup_5_1; }

		//genericMap=GenericMaps
		public Assignment getGenericMapAssignment_5_1_0() { return cGenericMapAssignment_5_1_0; }

		//GenericMaps
		public RuleCall getGenericMapGenericMapsParserRuleCall_5_1_0_0() { return cGenericMapGenericMapsParserRuleCall_5_1_0_0; }

		//";"
		public Keyword getSemicolonKeyword_5_1_1() { return cSemicolonKeyword_5_1_1; }

		//(port=Ports (portMap=PortMaps ";")?)?
		public Group getGroup_6() { return cGroup_6; }

		//port=Ports
		public Assignment getPortAssignment_6_0() { return cPortAssignment_6_0; }

		//Ports
		public RuleCall getPortPortsParserRuleCall_6_0_0() { return cPortPortsParserRuleCall_6_0_0; }

		//(portMap=PortMaps ";")?
		public Group getGroup_6_1() { return cGroup_6_1; }

		//portMap=PortMaps
		public Assignment getPortMapAssignment_6_1_0() { return cPortMapAssignment_6_1_0; }

		//PortMaps
		public RuleCall getPortMapPortMapsParserRuleCall_6_1_0_0() { return cPortMapPortMapsParserRuleCall_6_1_0_0; }

		//";"
		public Keyword getSemicolonKeyword_6_1_1() { return cSemicolonKeyword_6_1_1; }

		//declaration+=BlockDeclarativeItem*
		public Assignment getDeclarationAssignment_7() { return cDeclarationAssignment_7; }

		//BlockDeclarativeItem
		public RuleCall getDeclarationBlockDeclarativeItemParserRuleCall_7_0() { return cDeclarationBlockDeclarativeItemParserRuleCall_7_0; }

		//"begin"
		public Keyword getBeginKeyword_8() { return cBeginKeyword_8; }

		//statement+=ArchitectureStatement*
		public Assignment getStatementAssignment_9() { return cStatementAssignment_9; }

		//ArchitectureStatement
		public RuleCall getStatementArchitectureStatementParserRuleCall_9_0() { return cStatementArchitectureStatementParserRuleCall_9_0; }

		//"end"
		public Keyword getEndKeyword_10() { return cEndKeyword_10; }

		//"block"
		public Keyword getBlockKeyword_11() { return cBlockKeyword_11; }

		//Identifier?
		public RuleCall getIdentifierParserRuleCall_12() { return cIdentifierParserRuleCall_12; }

		//";"
		public Keyword getSemicolonKeyword_13() { return cSemicolonKeyword_13; }
	}

	public class BreakStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BreakStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBreakStatementAction_0 = (Action)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cLabelAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cLabelLabelParserRuleCall_1_0_0 = (RuleCall)cLabelAssignment_1_0.eContents().get(0);
		private final Keyword cColonKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Keyword cBreakKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Assignment cBreakAssignment_3_0 = (Assignment)cGroup_3.eContents().get(0);
		private final RuleCall cBreakBreakStatementItemParserRuleCall_3_0_0 = (RuleCall)cBreakAssignment_3_0.eContents().get(0);
		private final Group cGroup_3_1 = (Group)cGroup_3.eContents().get(1);
		private final Keyword cCommaKeyword_3_1_0 = (Keyword)cGroup_3_1.eContents().get(0);
		private final Assignment cBreakAssignment_3_1_1 = (Assignment)cGroup_3_1.eContents().get(1);
		private final RuleCall cBreakBreakStatementItemParserRuleCall_3_1_1_0 = (RuleCall)cBreakAssignment_3_1_1.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cWhenKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cWhenAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cWhenExpressionParserRuleCall_4_1_0 = (RuleCall)cWhenAssignment_4_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//BreakStatement returns statement::BreakStatement:
		//	{statement::BreakStatement} (label=Label ":")? "break" (break+=BreakStatementItem ("," break+=BreakStatementItem)*)?
		//	("when" when=Expression)? ";";
		public ParserRule getRule() { return rule; }

		//{statement::BreakStatement} (label=Label ":")? "break" (break+=BreakStatementItem ("," break+=BreakStatementItem)*)?
		//("when" when=Expression)? ";"
		public Group getGroup() { return cGroup; }

		//{statement::BreakStatement}
		public Action getBreakStatementAction_0() { return cBreakStatementAction_0; }

		//(label=Label ":")?
		public Group getGroup_1() { return cGroup_1; }

		//label=Label
		public Assignment getLabelAssignment_1_0() { return cLabelAssignment_1_0; }

		//Label
		public RuleCall getLabelLabelParserRuleCall_1_0_0() { return cLabelLabelParserRuleCall_1_0_0; }

		//":"
		public Keyword getColonKeyword_1_1() { return cColonKeyword_1_1; }

		//"break"
		public Keyword getBreakKeyword_2() { return cBreakKeyword_2; }

		//(break+=BreakStatementItem ("," break+=BreakStatementItem)*)?
		public Group getGroup_3() { return cGroup_3; }

		//break+=BreakStatementItem
		public Assignment getBreakAssignment_3_0() { return cBreakAssignment_3_0; }

		//BreakStatementItem
		public RuleCall getBreakBreakStatementItemParserRuleCall_3_0_0() { return cBreakBreakStatementItemParserRuleCall_3_0_0; }

		//("," break+=BreakStatementItem)*
		public Group getGroup_3_1() { return cGroup_3_1; }

		//","
		public Keyword getCommaKeyword_3_1_0() { return cCommaKeyword_3_1_0; }

		//break+=BreakStatementItem
		public Assignment getBreakAssignment_3_1_1() { return cBreakAssignment_3_1_1; }

		//BreakStatementItem
		public RuleCall getBreakBreakStatementItemParserRuleCall_3_1_1_0() { return cBreakBreakStatementItemParserRuleCall_3_1_1_0; }

		//("when" when=Expression)?
		public Group getGroup_4() { return cGroup_4; }

		//"when"
		public Keyword getWhenKeyword_4_0() { return cWhenKeyword_4_0; }

		//when=Expression
		public Assignment getWhenAssignment_4_1() { return cWhenAssignment_4_1; }

		//Expression
		public RuleCall getWhenExpressionParserRuleCall_4_1_0() { return cWhenExpressionParserRuleCall_4_1_0; }

		//";"
		public Keyword getSemicolonKeyword_5() { return cSemicolonKeyword_5; }
	}

	public class ConcurrentBreakStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ConcurrentBreakStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBreakStatementAction_0 = (Action)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cLabelAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cLabelLabelParserRuleCall_1_0_0 = (RuleCall)cLabelAssignment_1_0.eContents().get(0);
		private final Keyword cColonKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Keyword cBreakKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Assignment cBreakAssignment_3_0 = (Assignment)cGroup_3.eContents().get(0);
		private final RuleCall cBreakBreakStatementItemParserRuleCall_3_0_0 = (RuleCall)cBreakAssignment_3_0.eContents().get(0);
		private final Group cGroup_3_1 = (Group)cGroup_3.eContents().get(1);
		private final Keyword cCommaKeyword_3_1_0 = (Keyword)cGroup_3_1.eContents().get(0);
		private final Assignment cBreakAssignment_3_1_1 = (Assignment)cGroup_3_1.eContents().get(1);
		private final RuleCall cBreakBreakStatementItemParserRuleCall_3_1_1_0 = (RuleCall)cBreakAssignment_3_1_1.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cOnKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cSensitivityAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cSensitivityMultiNameParserRuleCall_4_1_0 = (RuleCall)cSensitivityAssignment_4_1.eContents().get(0);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cWhenKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Assignment cWhenAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cWhenExpressionParserRuleCall_5_1_0 = (RuleCall)cWhenAssignment_5_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//ConcurrentBreakStatement returns statement::BreakStatement:
		//	{statement::BreakStatement} (label=Label ":")? "break" (break+=BreakStatementItem ("," break+=BreakStatementItem)*)?
		//	("on" sensitivity=MultiName)? ("when" when=Expression)? ";";
		public ParserRule getRule() { return rule; }

		//{statement::BreakStatement} (label=Label ":")? "break" (break+=BreakStatementItem ("," break+=BreakStatementItem)*)?
		//("on" sensitivity=MultiName)? ("when" when=Expression)? ";"
		public Group getGroup() { return cGroup; }

		//{statement::BreakStatement}
		public Action getBreakStatementAction_0() { return cBreakStatementAction_0; }

		//(label=Label ":")?
		public Group getGroup_1() { return cGroup_1; }

		//label=Label
		public Assignment getLabelAssignment_1_0() { return cLabelAssignment_1_0; }

		//Label
		public RuleCall getLabelLabelParserRuleCall_1_0_0() { return cLabelLabelParserRuleCall_1_0_0; }

		//":"
		public Keyword getColonKeyword_1_1() { return cColonKeyword_1_1; }

		//"break"
		public Keyword getBreakKeyword_2() { return cBreakKeyword_2; }

		//(break+=BreakStatementItem ("," break+=BreakStatementItem)*)?
		public Group getGroup_3() { return cGroup_3; }

		//break+=BreakStatementItem
		public Assignment getBreakAssignment_3_0() { return cBreakAssignment_3_0; }

		//BreakStatementItem
		public RuleCall getBreakBreakStatementItemParserRuleCall_3_0_0() { return cBreakBreakStatementItemParserRuleCall_3_0_0; }

		//("," break+=BreakStatementItem)*
		public Group getGroup_3_1() { return cGroup_3_1; }

		//","
		public Keyword getCommaKeyword_3_1_0() { return cCommaKeyword_3_1_0; }

		//break+=BreakStatementItem
		public Assignment getBreakAssignment_3_1_1() { return cBreakAssignment_3_1_1; }

		//BreakStatementItem
		public RuleCall getBreakBreakStatementItemParserRuleCall_3_1_1_0() { return cBreakBreakStatementItemParserRuleCall_3_1_1_0; }

		//("on" sensitivity=MultiName)?
		public Group getGroup_4() { return cGroup_4; }

		//"on"
		public Keyword getOnKeyword_4_0() { return cOnKeyword_4_0; }

		//sensitivity=MultiName
		public Assignment getSensitivityAssignment_4_1() { return cSensitivityAssignment_4_1; }

		//MultiName
		public RuleCall getSensitivityMultiNameParserRuleCall_4_1_0() { return cSensitivityMultiNameParserRuleCall_4_1_0; }

		//("when" when=Expression)?
		public Group getGroup_5() { return cGroup_5; }

		//"when"
		public Keyword getWhenKeyword_5_0() { return cWhenKeyword_5_0; }

		//when=Expression
		public Assignment getWhenAssignment_5_1() { return cWhenAssignment_5_1; }

		//Expression
		public RuleCall getWhenExpressionParserRuleCall_5_1_0() { return cWhenExpressionParserRuleCall_5_1_0; }

		//";"
		public Keyword getSemicolonKeyword_6() { return cSemicolonKeyword_6; }
	}

	public class BreakStatementItemElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BreakStatementItem");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cGroup.eContents().get(0);
		private final Keyword cForKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Assignment cNameAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cNameNameParserRuleCall_0_1_0 = (RuleCall)cNameAssignment_0_1.eContents().get(0);
		private final Keyword cUseKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final Assignment cUseAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cUseNameParserRuleCall_1_0 = (RuleCall)cUseAssignment_1.eContents().get(0);
		private final Keyword cEqualsSignGreaterThanSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cArrowAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cArrowExpressionParserRuleCall_3_0 = (RuleCall)cArrowAssignment_3.eContents().get(0);
		
		//BreakStatementItem returns statement::BreakStatementItem:
		//	("for" name=Name "use")? use=Name "=>" arrow=Expression;
		public ParserRule getRule() { return rule; }

		//("for" name=Name "use")? use=Name "=>" arrow=Expression
		public Group getGroup() { return cGroup; }

		//("for" name=Name "use")?
		public Group getGroup_0() { return cGroup_0; }

		//"for"
		public Keyword getForKeyword_0_0() { return cForKeyword_0_0; }

		//name=Name
		public Assignment getNameAssignment_0_1() { return cNameAssignment_0_1; }

		//Name
		public RuleCall getNameNameParserRuleCall_0_1_0() { return cNameNameParserRuleCall_0_1_0; }

		//"use"
		public Keyword getUseKeyword_0_2() { return cUseKeyword_0_2; }

		//use=Name
		public Assignment getUseAssignment_1() { return cUseAssignment_1; }

		//Name
		public RuleCall getUseNameParserRuleCall_1_0() { return cUseNameParserRuleCall_1_0; }

		//"=>"
		public Keyword getEqualsSignGreaterThanSignKeyword_2() { return cEqualsSignGreaterThanSignKeyword_2; }

		//arrow=Expression
		public Assignment getArrowAssignment_3() { return cArrowAssignment_3; }

		//Expression
		public RuleCall getArrowExpressionParserRuleCall_3_0() { return cArrowExpressionParserRuleCall_3_0; }
	}

	public class CaseStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CaseStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cGroup.eContents().get(0);
		private final Assignment cLabelAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final RuleCall cLabelLabelParserRuleCall_0_0_0 = (RuleCall)cLabelAssignment_0_0.eContents().get(0);
		private final Keyword cColonKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Keyword cCaseKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cCaseAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cCaseExpressionParserRuleCall_2_0 = (RuleCall)cCaseAssignment_2.eContents().get(0);
		private final Keyword cIsKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cWhenAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cWhenCaseAlternativeParserRuleCall_4_0 = (RuleCall)cWhenAssignment_4.eContents().get(0);
		private final Keyword cEndKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Keyword cCaseKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final RuleCall cIdentifierParserRuleCall_7 = (RuleCall)cGroup.eContents().get(7);
		private final Keyword cSemicolonKeyword_8 = (Keyword)cGroup.eContents().get(8);
		
		/// *
		// * [ label: ] case  expression  is
		// *              when choice1 =>
		// *                 sequence-of-statements
		// *              when choice2 =>            \_ optional
		// *                 sequence-of-statements  /
		// *              ...
		// *
		// *              when others =>             \_ optional if all choices covered
		// *                 sequence-of-statements  /
		// *            end case [ label ] ;
		// * / CaseStatement returns statement::CaseStatement:
		//	(label=Label ":")? "case" case=Expression "is" when+=CaseAlternative+ "end" "case" Identifier? ";";
		public ParserRule getRule() { return rule; }

		//(label=Label ":")? "case" case=Expression "is" when+=CaseAlternative+ "end" "case" Identifier? ";"
		public Group getGroup() { return cGroup; }

		//(label=Label ":")?
		public Group getGroup_0() { return cGroup_0; }

		//label=Label
		public Assignment getLabelAssignment_0_0() { return cLabelAssignment_0_0; }

		//Label
		public RuleCall getLabelLabelParserRuleCall_0_0_0() { return cLabelLabelParserRuleCall_0_0_0; }

		//":"
		public Keyword getColonKeyword_0_1() { return cColonKeyword_0_1; }

		//"case"
		public Keyword getCaseKeyword_1() { return cCaseKeyword_1; }

		//case=Expression
		public Assignment getCaseAssignment_2() { return cCaseAssignment_2; }

		//Expression
		public RuleCall getCaseExpressionParserRuleCall_2_0() { return cCaseExpressionParserRuleCall_2_0; }

		//"is"
		public Keyword getIsKeyword_3() { return cIsKeyword_3; }

		//when+=CaseAlternative+
		public Assignment getWhenAssignment_4() { return cWhenAssignment_4; }

		//CaseAlternative
		public RuleCall getWhenCaseAlternativeParserRuleCall_4_0() { return cWhenCaseAlternativeParserRuleCall_4_0; }

		//"end"
		public Keyword getEndKeyword_5() { return cEndKeyword_5; }

		//"case"
		public Keyword getCaseKeyword_6() { return cCaseKeyword_6; }

		//Identifier?
		public RuleCall getIdentifierParserRuleCall_7() { return cIdentifierParserRuleCall_7; }

		//";"
		public Keyword getSemicolonKeyword_8() { return cSemicolonKeyword_8; }
	}

	public class CaseAlternativeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CaseAlternative");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cWhenKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cChoiceAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cChoiceChoicesParserRuleCall_1_0 = (RuleCall)cChoiceAssignment_1.eContents().get(0);
		private final Keyword cEqualsSignGreaterThanSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cStatementAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cStatementSequentialStatementParserRuleCall_3_0 = (RuleCall)cStatementAssignment_3.eContents().get(0);
		
		//CaseAlternative returns statement::CaseAlternative:
		//	"when" choice=Choices "=>" statement+=SequentialStatement*;
		public ParserRule getRule() { return rule; }

		//"when" choice=Choices "=>" statement+=SequentialStatement*
		public Group getGroup() { return cGroup; }

		//"when"
		public Keyword getWhenKeyword_0() { return cWhenKeyword_0; }

		//choice=Choices
		public Assignment getChoiceAssignment_1() { return cChoiceAssignment_1; }

		//Choices
		public RuleCall getChoiceChoicesParserRuleCall_1_0() { return cChoiceChoicesParserRuleCall_1_0; }

		//"=>"
		public Keyword getEqualsSignGreaterThanSignKeyword_2() { return cEqualsSignGreaterThanSignKeyword_2; }

		//statement+=SequentialStatement*
		public Assignment getStatementAssignment_3() { return cStatementAssignment_3; }

		//SequentialStatement
		public RuleCall getStatementSequentialStatementParserRuleCall_3_0() { return cStatementSequentialStatementParserRuleCall_3_0; }
	}

	public class AllElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "All");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cAllExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cAllKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//All returns expression::AllExpression:
		//	{expression::AllExpression} "all";
		public ParserRule getRule() { return rule; }

		//{expression::AllExpression} "all"
		public Group getGroup() { return cGroup; }

		//{expression::AllExpression}
		public Action getAllExpressionAction_0() { return cAllExpressionAction_0; }

		//"all"
		public Keyword getAllKeyword_1() { return cAllKeyword_1; }
	}

	public class OthersElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Others");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cOthersExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cOthersKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//Others returns expression::OthersExpression:
		//	{expression::OthersExpression} "others";
		public ParserRule getRule() { return rule; }

		//{expression::OthersExpression} "others"
		public Group getGroup() { return cGroup; }

		//{expression::OthersExpression}
		public Action getOthersExpressionAction_0() { return cOthersExpressionAction_0; }

		//"others"
		public Keyword getOthersKeyword_1() { return cOthersKeyword_1; }
	}

	public class UnaffectedElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Unaffected");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cUnaffectedExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cUnaffectedKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//Unaffected returns expression::UnaffectedExpression:
		//	{expression::UnaffectedExpression} "unaffected";
		public ParserRule getRule() { return rule; }

		//{expression::UnaffectedExpression} "unaffected"
		public Group getGroup() { return cGroup; }

		//{expression::UnaffectedExpression}
		public Action getUnaffectedExpressionAction_0() { return cUnaffectedExpressionAction_0; }

		//"unaffected"
		public Keyword getUnaffectedKeyword_1() { return cUnaffectedKeyword_1; }
	}

	public class ComponentConfigurationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ComponentConfiguration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cForKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cListAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cListInstantiationListParserRuleCall_1_0 = (RuleCall)cListAssignment_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cComponentAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cComponentNameParserRuleCall_3_0 = (RuleCall)cComponentAssignment_3.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Group cGroup_4_0 = (Group)cGroup_4.eContents().get(0);
		private final Keyword cUseKeyword_4_0_0 = (Keyword)cGroup_4_0.eContents().get(0);
		private final Alternatives cAlternatives_4_0_1 = (Alternatives)cGroup_4_0.eContents().get(1);
		private final Group cGroup_4_0_1_0 = (Group)cAlternatives_4_0_1.eContents().get(0);
		private final Keyword cEntityKeyword_4_0_1_0_0 = (Keyword)cGroup_4_0_1_0.eContents().get(0);
		private final Assignment cEntityAssignment_4_0_1_0_1 = (Assignment)cGroup_4_0_1_0.eContents().get(1);
		private final RuleCall cEntityNameParserRuleCall_4_0_1_0_1_0 = (RuleCall)cEntityAssignment_4_0_1_0_1.eContents().get(0);
		private final Group cGroup_4_0_1_1 = (Group)cAlternatives_4_0_1.eContents().get(1);
		private final Keyword cConfigurationKeyword_4_0_1_1_0 = (Keyword)cGroup_4_0_1_1.eContents().get(0);
		private final Assignment cConfigurationAssignment_4_0_1_1_1 = (Assignment)cGroup_4_0_1_1.eContents().get(1);
		private final RuleCall cConfigurationNameParserRuleCall_4_0_1_1_1_0 = (RuleCall)cConfigurationAssignment_4_0_1_1_1.eContents().get(0);
		private final Keyword cOpenKeyword_4_0_1_2 = (Keyword)cAlternatives_4_0_1.eContents().get(2);
		private final Assignment cGenericMapAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cGenericMapGenericMapsParserRuleCall_4_1_0 = (RuleCall)cGenericMapAssignment_4_1.eContents().get(0);
		private final Assignment cPortMapAssignment_4_2 = (Assignment)cGroup_4.eContents().get(2);
		private final RuleCall cPortMapPortMapsParserRuleCall_4_2_0 = (RuleCall)cPortMapAssignment_4_2.eContents().get(0);
		private final Keyword cSemicolonKeyword_4_3 = (Keyword)cGroup_4.eContents().get(3);
		private final Assignment cBlockAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cBlockBlockConfigurationParserRuleCall_5_0 = (RuleCall)cBlockAssignment_5.eContents().get(0);
		private final Keyword cEndKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Keyword cForKeyword_7 = (Keyword)cGroup.eContents().get(7);
		private final Keyword cSemicolonKeyword_8 = (Keyword)cGroup.eContents().get(8);
		
		//ComponentConfiguration returns configuration::ComponentConfiguration:
		//	"for" list=InstantiationList ":" component=Name (("use" ("entity" entity=Name | "configuration" configuration=Name |
		//	"open"))? genericMap=GenericMaps? portMap=PortMaps? ";")? block=BlockConfiguration? "end" "for" ";";
		public ParserRule getRule() { return rule; }

		//"for" list=InstantiationList ":" component=Name (("use" ("entity" entity=Name | "configuration" configuration=Name |
		//"open"))? genericMap=GenericMaps? portMap=PortMaps? ";")? block=BlockConfiguration? "end" "for" ";"
		public Group getGroup() { return cGroup; }

		//"for"
		public Keyword getForKeyword_0() { return cForKeyword_0; }

		//list=InstantiationList
		public Assignment getListAssignment_1() { return cListAssignment_1; }

		//InstantiationList
		public RuleCall getListInstantiationListParserRuleCall_1_0() { return cListInstantiationListParserRuleCall_1_0; }

		//":"
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }

		//component=Name
		public Assignment getComponentAssignment_3() { return cComponentAssignment_3; }

		//Name
		public RuleCall getComponentNameParserRuleCall_3_0() { return cComponentNameParserRuleCall_3_0; }

		//(("use" ("entity" entity=Name | "configuration" configuration=Name | "open"))? genericMap=GenericMaps? portMap=PortMaps?
		//";")?
		public Group getGroup_4() { return cGroup_4; }

		//("use" ("entity" entity=Name | "configuration" configuration=Name | "open"))?
		public Group getGroup_4_0() { return cGroup_4_0; }

		//"use"
		public Keyword getUseKeyword_4_0_0() { return cUseKeyword_4_0_0; }

		//"entity" entity=Name | "configuration" configuration=Name | "open"
		public Alternatives getAlternatives_4_0_1() { return cAlternatives_4_0_1; }

		//"entity" entity=Name
		public Group getGroup_4_0_1_0() { return cGroup_4_0_1_0; }

		//"entity"
		public Keyword getEntityKeyword_4_0_1_0_0() { return cEntityKeyword_4_0_1_0_0; }

		//entity=Name
		public Assignment getEntityAssignment_4_0_1_0_1() { return cEntityAssignment_4_0_1_0_1; }

		//Name
		public RuleCall getEntityNameParserRuleCall_4_0_1_0_1_0() { return cEntityNameParserRuleCall_4_0_1_0_1_0; }

		//"configuration" configuration=Name
		public Group getGroup_4_0_1_1() { return cGroup_4_0_1_1; }

		//"configuration"
		public Keyword getConfigurationKeyword_4_0_1_1_0() { return cConfigurationKeyword_4_0_1_1_0; }

		//configuration=Name
		public Assignment getConfigurationAssignment_4_0_1_1_1() { return cConfigurationAssignment_4_0_1_1_1; }

		//Name
		public RuleCall getConfigurationNameParserRuleCall_4_0_1_1_1_0() { return cConfigurationNameParserRuleCall_4_0_1_1_1_0; }

		//"open"
		public Keyword getOpenKeyword_4_0_1_2() { return cOpenKeyword_4_0_1_2; }

		//genericMap=GenericMaps?
		public Assignment getGenericMapAssignment_4_1() { return cGenericMapAssignment_4_1; }

		//GenericMaps
		public RuleCall getGenericMapGenericMapsParserRuleCall_4_1_0() { return cGenericMapGenericMapsParserRuleCall_4_1_0; }

		//portMap=PortMaps?
		public Assignment getPortMapAssignment_4_2() { return cPortMapAssignment_4_2; }

		//PortMaps
		public RuleCall getPortMapPortMapsParserRuleCall_4_2_0() { return cPortMapPortMapsParserRuleCall_4_2_0; }

		//";"
		public Keyword getSemicolonKeyword_4_3() { return cSemicolonKeyword_4_3; }

		//block=BlockConfiguration?
		public Assignment getBlockAssignment_5() { return cBlockAssignment_5; }

		//BlockConfiguration
		public RuleCall getBlockBlockConfigurationParserRuleCall_5_0() { return cBlockBlockConfigurationParserRuleCall_5_0; }

		//"end"
		public Keyword getEndKeyword_6() { return cEndKeyword_6; }

		//"for"
		public Keyword getForKeyword_7() { return cForKeyword_7; }

		//";"
		public Keyword getSemicolonKeyword_8() { return cSemicolonKeyword_8; }
	}

	public class ComponentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Component");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cComponentKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIdentifierNameParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cIsKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cGenericAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cGenericGenericsParserRuleCall_3_0 = (RuleCall)cGenericAssignment_3.eContents().get(0);
		private final Assignment cPortAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cPortPortsParserRuleCall_4_0 = (RuleCall)cPortAssignment_4.eContents().get(0);
		private final Keyword cEndKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Keyword cComponentKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final RuleCall cIdentifierParserRuleCall_7 = (RuleCall)cGroup.eContents().get(7);
		private final Keyword cSemicolonKeyword_8 = (Keyword)cGroup.eContents().get(8);
		
		/// *
		// * component component_name is
		// *    generic ( generic_variable_declarations ) ; -- optional
		// *    port ( input_and_output_variable_declarations ) ;
		// * end component component_name ;
		// * / Component:
		//	"component" name=IdentifierName "is"? generic=Generics? port=Ports? "end" "component" Identifier? ";";
		public ParserRule getRule() { return rule; }

		//"component" name=IdentifierName "is"? generic=Generics? port=Ports? "end" "component" Identifier? ";"
		public Group getGroup() { return cGroup; }

		//"component"
		public Keyword getComponentKeyword_0() { return cComponentKeyword_0; }

		//name=IdentifierName
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//IdentifierName
		public RuleCall getNameIdentifierNameParserRuleCall_1_0() { return cNameIdentifierNameParserRuleCall_1_0; }

		//"is"?
		public Keyword getIsKeyword_2() { return cIsKeyword_2; }

		//generic=Generics?
		public Assignment getGenericAssignment_3() { return cGenericAssignment_3; }

		//Generics
		public RuleCall getGenericGenericsParserRuleCall_3_0() { return cGenericGenericsParserRuleCall_3_0; }

		//port=Ports?
		public Assignment getPortAssignment_4() { return cPortAssignment_4; }

		//Ports
		public RuleCall getPortPortsParserRuleCall_4_0() { return cPortPortsParserRuleCall_4_0; }

		//"end"
		public Keyword getEndKeyword_5() { return cEndKeyword_5; }

		//"component"
		public Keyword getComponentKeyword_6() { return cComponentKeyword_6; }

		//Identifier?
		public RuleCall getIdentifierParserRuleCall_7() { return cIdentifierParserRuleCall_7; }

		//";"
		public Keyword getSemicolonKeyword_8() { return cSemicolonKeyword_8; }
	}

	public class ComponentInstantiationStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ComponentInstantiationStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLabelAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLabelLabelParserRuleCall_0_0 = (RuleCall)cLabelAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cComponentKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cNameAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNameNameParserRuleCall_3_0 = (RuleCall)cNameAssignment_3.eContents().get(0);
		private final Assignment cGenericMapAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cGenericMapGenericMapsParserRuleCall_4_0 = (RuleCall)cGenericMapAssignment_4.eContents().get(0);
		private final Assignment cPortMapAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cPortMapPortMapsParserRuleCall_5_0 = (RuleCall)cPortMapAssignment_5.eContents().get(0);
		private final Keyword cSemicolonKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		/// *
		// * part_name: entity  library_name.entity_name(architecture_name)
		// *            port map ( actual arguments ) ; 
		// *
		// *            optional (architecture_name)
		// * part_name: component_name
		// *            port map ( actual arguments ) ;
		// * / ComponentInstantiationStatement returns statement::ComponentInstantiationStatement:
		//	label=Label ":" "component"? name=Name genericMap=GenericMaps? portMap=PortMaps? ";";
		public ParserRule getRule() { return rule; }

		//label=Label ":" "component"? name=Name genericMap=GenericMaps? portMap=PortMaps? ";"
		public Group getGroup() { return cGroup; }

		//label=Label
		public Assignment getLabelAssignment_0() { return cLabelAssignment_0; }

		//Label
		public RuleCall getLabelLabelParserRuleCall_0_0() { return cLabelLabelParserRuleCall_0_0; }

		//":"
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }

		//"component"?
		public Keyword getComponentKeyword_2() { return cComponentKeyword_2; }

		//name=Name
		public Assignment getNameAssignment_3() { return cNameAssignment_3; }

		//Name
		public RuleCall getNameNameParserRuleCall_3_0() { return cNameNameParserRuleCall_3_0; }

		//genericMap=GenericMaps?
		public Assignment getGenericMapAssignment_4() { return cGenericMapAssignment_4; }

		//GenericMaps
		public RuleCall getGenericMapGenericMapsParserRuleCall_4_0() { return cGenericMapGenericMapsParserRuleCall_4_0; }

		//portMap=PortMaps?
		public Assignment getPortMapAssignment_5() { return cPortMapAssignment_5; }

		//PortMaps
		public RuleCall getPortMapPortMapsParserRuleCall_5_0() { return cPortMapPortMapsParserRuleCall_5_0; }

		//";"
		public Keyword getSemicolonKeyword_6() { return cSemicolonKeyword_6; }
	}

	public class EntityInstantiationStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EntityInstantiationStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLabelAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLabelLabelParserRuleCall_0_0 = (RuleCall)cLabelAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cEntityKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cNameAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNameNameParserRuleCall_3_0 = (RuleCall)cNameAssignment_3.eContents().get(0);
		private final Assignment cGenericMapAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cGenericMapGenericMapsParserRuleCall_4_0 = (RuleCall)cGenericMapAssignment_4.eContents().get(0);
		private final Assignment cPortMapAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cPortMapPortMapsParserRuleCall_5_0 = (RuleCall)cPortMapAssignment_5.eContents().get(0);
		private final Keyword cSemicolonKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//EntityInstantiationStatement returns statement::EntityInstantiationStatement:
		//	label=Label ":" "entity" name=Name genericMap=GenericMaps? portMap=PortMaps? ";";
		public ParserRule getRule() { return rule; }

		//label=Label ":" "entity" name=Name genericMap=GenericMaps? portMap=PortMaps? ";"
		public Group getGroup() { return cGroup; }

		//label=Label
		public Assignment getLabelAssignment_0() { return cLabelAssignment_0; }

		//Label
		public RuleCall getLabelLabelParserRuleCall_0_0() { return cLabelLabelParserRuleCall_0_0; }

		//":"
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }

		//"entity"
		public Keyword getEntityKeyword_2() { return cEntityKeyword_2; }

		//name=Name
		public Assignment getNameAssignment_3() { return cNameAssignment_3; }

		//Name
		public RuleCall getNameNameParserRuleCall_3_0() { return cNameNameParserRuleCall_3_0; }

		//genericMap=GenericMaps?
		public Assignment getGenericMapAssignment_4() { return cGenericMapAssignment_4; }

		//GenericMaps
		public RuleCall getGenericMapGenericMapsParserRuleCall_4_0() { return cGenericMapGenericMapsParserRuleCall_4_0; }

		//portMap=PortMaps?
		public Assignment getPortMapAssignment_5() { return cPortMapAssignment_5; }

		//PortMaps
		public RuleCall getPortMapPortMapsParserRuleCall_5_0() { return cPortMapPortMapsParserRuleCall_5_0; }

		//";"
		public Keyword getSemicolonKeyword_6() { return cSemicolonKeyword_6; }
	}

	public class ConfigurationInstantiationStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ConfigurationInstantiationStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLabelAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLabelLabelParserRuleCall_0_0 = (RuleCall)cLabelAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cConfigurationKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cNameAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNameNameParserRuleCall_3_0 = (RuleCall)cNameAssignment_3.eContents().get(0);
		private final Assignment cGenericMapAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cGenericMapGenericMapsParserRuleCall_4_0 = (RuleCall)cGenericMapAssignment_4.eContents().get(0);
		private final Assignment cPortMapAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cPortMapPortMapsParserRuleCall_5_0 = (RuleCall)cPortMapAssignment_5.eContents().get(0);
		private final Keyword cSemicolonKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//ConfigurationInstantiationStatement returns statement::ConfigurationInstantiationStatement:
		//	label=Label ":" "configuration" name=Name genericMap=GenericMaps? portMap=PortMaps? ";";
		public ParserRule getRule() { return rule; }

		//label=Label ":" "configuration" name=Name genericMap=GenericMaps? portMap=PortMaps? ";"
		public Group getGroup() { return cGroup; }

		//label=Label
		public Assignment getLabelAssignment_0() { return cLabelAssignment_0; }

		//Label
		public RuleCall getLabelLabelParserRuleCall_0_0() { return cLabelLabelParserRuleCall_0_0; }

		//":"
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }

		//"configuration"
		public Keyword getConfigurationKeyword_2() { return cConfigurationKeyword_2; }

		//name=Name
		public Assignment getNameAssignment_3() { return cNameAssignment_3; }

		//Name
		public RuleCall getNameNameParserRuleCall_3_0() { return cNameNameParserRuleCall_3_0; }

		//genericMap=GenericMaps?
		public Assignment getGenericMapAssignment_4() { return cGenericMapAssignment_4; }

		//GenericMaps
		public RuleCall getGenericMapGenericMapsParserRuleCall_4_0() { return cGenericMapGenericMapsParserRuleCall_4_0; }

		//portMap=PortMaps?
		public Assignment getPortMapAssignment_5() { return cPortMapAssignment_5; }

		//PortMaps
		public RuleCall getPortMapPortMapsParserRuleCall_5_0() { return cPortMapPortMapsParserRuleCall_5_0; }

		//";"
		public Keyword getSemicolonKeyword_6() { return cSemicolonKeyword_6; }
	}

	public class CompositeNatureDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CompositeNatureDefinition");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cArrayNatureDefinitionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cRecordNatureDefinitionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//CompositeNatureDefinition returns nature::CompositeNatureDefinition:
		//	ArrayNatureDefinition | RecordNatureDefinition;
		public ParserRule getRule() { return rule; }

		//ArrayNatureDefinition | RecordNatureDefinition
		public Alternatives getAlternatives() { return cAlternatives; }

		//ArrayNatureDefinition
		public RuleCall getArrayNatureDefinitionParserRuleCall_0() { return cArrayNatureDefinitionParserRuleCall_0; }

		//RecordNatureDefinition
		public RuleCall getRecordNatureDefinitionParserRuleCall_1() { return cRecordNatureDefinitionParserRuleCall_1; }
	}

	public class CompositeTypeDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CompositeTypeDefinition");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cArrayTypeDefinitionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cRecordTypeDefinitionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//CompositeTypeDefinition returns type::CompositeTypeDefinition:
		//	ArrayTypeDefinition | RecordTypeDefinition;
		public ParserRule getRule() { return rule; }

		//ArrayTypeDefinition | RecordTypeDefinition
		public Alternatives getAlternatives() { return cAlternatives; }

		//ArrayTypeDefinition
		public RuleCall getArrayTypeDefinitionParserRuleCall_0() { return cArrayTypeDefinitionParserRuleCall_0; }

		//RecordTypeDefinition
		public RuleCall getRecordTypeDefinitionParserRuleCall_1() { return cRecordTypeDefinitionParserRuleCall_1; }
	}

	public class SelectedSignalAssignmentStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SelectedSignalAssignmentStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cGroup.eContents().get(0);
		private final Assignment cLabelAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final RuleCall cLabelLabelParserRuleCall_0_0_0 = (RuleCall)cLabelAssignment_0_0.eContents().get(0);
		private final Keyword cColonKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Assignment cPostponedAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Keyword cPostponedPostponedKeyword_1_0 = (Keyword)cPostponedAssignment_1.eContents().get(0);
		private final Keyword cWithKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cSelectedAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cSelectedExpressionParserRuleCall_3_0 = (RuleCall)cSelectedAssignment_3.eContents().get(0);
		private final Keyword cSelectKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cTargetAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cTargetTargetParserRuleCall_5_0 = (RuleCall)cTargetAssignment_5.eContents().get(0);
		private final Keyword cLessThanSignEqualsSignKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Assignment cGuardedAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final Keyword cGuardedGuardedKeyword_7_0 = (Keyword)cGuardedAssignment_7.eContents().get(0);
		private final Assignment cDelayAssignment_8 = (Assignment)cGroup.eContents().get(8);
		private final RuleCall cDelayDelayMechanismParserRuleCall_8_0 = (RuleCall)cDelayAssignment_8.eContents().get(0);
		private final Assignment cWaveformAssignment_9 = (Assignment)cGroup.eContents().get(9);
		private final RuleCall cWaveformConditionalWaveformParserRuleCall_9_0 = (RuleCall)cWaveformAssignment_9.eContents().get(0);
		private final Group cGroup_10 = (Group)cGroup.eContents().get(10);
		private final Keyword cCommaKeyword_10_0 = (Keyword)cGroup_10.eContents().get(0);
		private final Assignment cWaveformAssignment_10_1 = (Assignment)cGroup_10.eContents().get(1);
		private final RuleCall cWaveformConditionalWaveformParserRuleCall_10_1_0 = (RuleCall)cWaveformAssignment_10_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_11 = (Keyword)cGroup.eContents().get(11);
		
		/// *
		// * [ label : ] [ postponed ] selected_signal_assignment_statement ;
		// *
		// * with expression select target <=
		// *            waveform when choice [, waveform when choice ] ;
		// * / SelectedSignalAssignmentStatement returns statement::SelectedSignalAssignmentStatement:
		//	(label=Label ":")? postponed?="postponed"? "with" selected=Expression "select" target=Target "<=" guarded?="guarded"?
		//	delay=DelayMechanism? waveform+=ConditionalWaveform ("," waveform+=ConditionalWaveform)* ";";
		public ParserRule getRule() { return rule; }

		//(label=Label ":")? postponed?="postponed"? "with" selected=Expression "select" target=Target "<=" guarded?="guarded"?
		//delay=DelayMechanism? waveform+=ConditionalWaveform ("," waveform+=ConditionalWaveform)* ";"
		public Group getGroup() { return cGroup; }

		//(label=Label ":")?
		public Group getGroup_0() { return cGroup_0; }

		//label=Label
		public Assignment getLabelAssignment_0_0() { return cLabelAssignment_0_0; }

		//Label
		public RuleCall getLabelLabelParserRuleCall_0_0_0() { return cLabelLabelParserRuleCall_0_0_0; }

		//":"
		public Keyword getColonKeyword_0_1() { return cColonKeyword_0_1; }

		//postponed?="postponed"?
		public Assignment getPostponedAssignment_1() { return cPostponedAssignment_1; }

		//"postponed"
		public Keyword getPostponedPostponedKeyword_1_0() { return cPostponedPostponedKeyword_1_0; }

		//"with"
		public Keyword getWithKeyword_2() { return cWithKeyword_2; }

		//selected=Expression
		public Assignment getSelectedAssignment_3() { return cSelectedAssignment_3; }

		//Expression
		public RuleCall getSelectedExpressionParserRuleCall_3_0() { return cSelectedExpressionParserRuleCall_3_0; }

		//"select"
		public Keyword getSelectKeyword_4() { return cSelectKeyword_4; }

		//target=Target
		public Assignment getTargetAssignment_5() { return cTargetAssignment_5; }

		//Target
		public RuleCall getTargetTargetParserRuleCall_5_0() { return cTargetTargetParserRuleCall_5_0; }

		//"<="
		public Keyword getLessThanSignEqualsSignKeyword_6() { return cLessThanSignEqualsSignKeyword_6; }

		//guarded?="guarded"?
		public Assignment getGuardedAssignment_7() { return cGuardedAssignment_7; }

		//"guarded"
		public Keyword getGuardedGuardedKeyword_7_0() { return cGuardedGuardedKeyword_7_0; }

		//delay=DelayMechanism?
		public Assignment getDelayAssignment_8() { return cDelayAssignment_8; }

		//DelayMechanism
		public RuleCall getDelayDelayMechanismParserRuleCall_8_0() { return cDelayDelayMechanismParserRuleCall_8_0; }

		//waveform+=ConditionalWaveform
		public Assignment getWaveformAssignment_9() { return cWaveformAssignment_9; }

		//ConditionalWaveform
		public RuleCall getWaveformConditionalWaveformParserRuleCall_9_0() { return cWaveformConditionalWaveformParserRuleCall_9_0; }

		//("," waveform+=ConditionalWaveform)*
		public Group getGroup_10() { return cGroup_10; }

		//","
		public Keyword getCommaKeyword_10_0() { return cCommaKeyword_10_0; }

		//waveform+=ConditionalWaveform
		public Assignment getWaveformAssignment_10_1() { return cWaveformAssignment_10_1; }

		//ConditionalWaveform
		public RuleCall getWaveformConditionalWaveformParserRuleCall_10_1_0() { return cWaveformConditionalWaveformParserRuleCall_10_1_0; }

		//";"
		public Keyword getSemicolonKeyword_11() { return cSemicolonKeyword_11; }
	}

	public class ConditionalSignalAssignmentStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ConditionalSignalAssignmentStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cGroup.eContents().get(0);
		private final Assignment cLabelAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final RuleCall cLabelLabelParserRuleCall_0_0_0 = (RuleCall)cLabelAssignment_0_0.eContents().get(0);
		private final Keyword cColonKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Assignment cPostponedAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Keyword cPostponedPostponedKeyword_1_0 = (Keyword)cPostponedAssignment_1.eContents().get(0);
		private final Assignment cTargetAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTargetTargetParserRuleCall_2_0 = (RuleCall)cTargetAssignment_2.eContents().get(0);
		private final Keyword cLessThanSignEqualsSignKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cGuardedAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final Keyword cGuardedGuardedKeyword_4_0 = (Keyword)cGuardedAssignment_4.eContents().get(0);
		private final Assignment cDelayAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cDelayDelayMechanismParserRuleCall_5_0 = (RuleCall)cDelayAssignment_5.eContents().get(0);
		private final Assignment cWaveformAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cWaveformConditionalWaveformParserRuleCall_6_0 = (RuleCall)cWaveformAssignment_6.eContents().get(0);
		private final Group cGroup_7 = (Group)cGroup.eContents().get(7);
		private final Keyword cElseKeyword_7_0 = (Keyword)cGroup_7.eContents().get(0);
		private final Assignment cWaveformAssignment_7_1 = (Assignment)cGroup_7.eContents().get(1);
		private final RuleCall cWaveformConditionalWaveformParserRuleCall_7_1_0 = (RuleCall)cWaveformAssignment_7_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_8 = (Keyword)cGroup.eContents().get(8);
		
		/// *
		// * [ label : ] [ postponed ] conditional_signal_assignment_statement ;
		// *
		// * target <= waveform when choice; -- choice is a boolean expression
		// * target <= waveform when choice else waveform;
		// * / ConditionalSignalAssignmentStatement returns statement::ConditionalSignalAssignmentStatement:
		//	(label=Label ":")? postponed?="postponed"? target=Target "<=" guarded?="guarded"? delay=DelayMechanism?
		//	waveform+=ConditionalWaveform ("else" waveform+=ConditionalWaveform)* ";";
		public ParserRule getRule() { return rule; }

		//(label=Label ":")? postponed?="postponed"? target=Target "<=" guarded?="guarded"? delay=DelayMechanism?
		//waveform+=ConditionalWaveform ("else" waveform+=ConditionalWaveform)* ";"
		public Group getGroup() { return cGroup; }

		//(label=Label ":")?
		public Group getGroup_0() { return cGroup_0; }

		//label=Label
		public Assignment getLabelAssignment_0_0() { return cLabelAssignment_0_0; }

		//Label
		public RuleCall getLabelLabelParserRuleCall_0_0_0() { return cLabelLabelParserRuleCall_0_0_0; }

		//":"
		public Keyword getColonKeyword_0_1() { return cColonKeyword_0_1; }

		//postponed?="postponed"?
		public Assignment getPostponedAssignment_1() { return cPostponedAssignment_1; }

		//"postponed"
		public Keyword getPostponedPostponedKeyword_1_0() { return cPostponedPostponedKeyword_1_0; }

		//target=Target
		public Assignment getTargetAssignment_2() { return cTargetAssignment_2; }

		//Target
		public RuleCall getTargetTargetParserRuleCall_2_0() { return cTargetTargetParserRuleCall_2_0; }

		//"<="
		public Keyword getLessThanSignEqualsSignKeyword_3() { return cLessThanSignEqualsSignKeyword_3; }

		//guarded?="guarded"?
		public Assignment getGuardedAssignment_4() { return cGuardedAssignment_4; }

		//"guarded"
		public Keyword getGuardedGuardedKeyword_4_0() { return cGuardedGuardedKeyword_4_0; }

		//delay=DelayMechanism?
		public Assignment getDelayAssignment_5() { return cDelayAssignment_5; }

		//DelayMechanism
		public RuleCall getDelayDelayMechanismParserRuleCall_5_0() { return cDelayDelayMechanismParserRuleCall_5_0; }

		//waveform+=ConditionalWaveform
		public Assignment getWaveformAssignment_6() { return cWaveformAssignment_6; }

		//ConditionalWaveform
		public RuleCall getWaveformConditionalWaveformParserRuleCall_6_0() { return cWaveformConditionalWaveformParserRuleCall_6_0; }

		//(=> "else" waveform+=ConditionalWaveform)*
		public Group getGroup_7() { return cGroup_7; }

		//=> "else"
		public Keyword getElseKeyword_7_0() { return cElseKeyword_7_0; }

		//waveform+=ConditionalWaveform
		public Assignment getWaveformAssignment_7_1() { return cWaveformAssignment_7_1; }

		//ConditionalWaveform
		public RuleCall getWaveformConditionalWaveformParserRuleCall_7_1_0() { return cWaveformConditionalWaveformParserRuleCall_7_1_0; }

		//";"
		public Keyword getSemicolonKeyword_8() { return cSemicolonKeyword_8; }
	}

	public class SequentialSignalAssignmentStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SequentialSignalAssignmentStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cGroup.eContents().get(0);
		private final Assignment cLabelAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final RuleCall cLabelLabelParserRuleCall_0_0_0 = (RuleCall)cLabelAssignment_0_0.eContents().get(0);
		private final Keyword cColonKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Assignment cPostponedAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Keyword cPostponedPostponedKeyword_1_0 = (Keyword)cPostponedAssignment_1.eContents().get(0);
		private final Assignment cTargetAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTargetTargetParserRuleCall_2_0 = (RuleCall)cTargetAssignment_2.eContents().get(0);
		private final Keyword cLessThanSignEqualsSignKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cGuardedAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final Keyword cGuardedGuardedKeyword_4_0 = (Keyword)cGuardedAssignment_4.eContents().get(0);
		private final Assignment cDelayAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cDelayDelayMechanismParserRuleCall_5_0 = (RuleCall)cDelayAssignment_5.eContents().get(0);
		private final Assignment cWaveformAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cWaveformWaveformsParserRuleCall_6_0 = (RuleCall)cWaveformAssignment_6.eContents().get(0);
		private final Keyword cSemicolonKeyword_7 = (Keyword)cGroup.eContents().get(7);
		
		/// *
		// * sequential signal assignment statement
		// *
		// * [ label : ] target "<=" [ "guarded" ] [ delay_mechanism ] waveform ";".
		// * / SequentialSignalAssignmentStatement returns statement::SequentialSignalAssignmentStatement:
		//	(label=Label ":")? postponed?="postponed"? target=Target "<=" guarded?="guarded"? delay=DelayMechanism?
		//	waveform=Waveforms ";";
		public ParserRule getRule() { return rule; }

		//(label=Label ":")? postponed?="postponed"? target=Target "<=" guarded?="guarded"? delay=DelayMechanism?
		//waveform=Waveforms ";"
		public Group getGroup() { return cGroup; }

		//(label=Label ":")?
		public Group getGroup_0() { return cGroup_0; }

		//label=Label
		public Assignment getLabelAssignment_0_0() { return cLabelAssignment_0_0; }

		//Label
		public RuleCall getLabelLabelParserRuleCall_0_0_0() { return cLabelLabelParserRuleCall_0_0_0; }

		//":"
		public Keyword getColonKeyword_0_1() { return cColonKeyword_0_1; }

		//postponed?="postponed"?
		public Assignment getPostponedAssignment_1() { return cPostponedAssignment_1; }

		//"postponed"
		public Keyword getPostponedPostponedKeyword_1_0() { return cPostponedPostponedKeyword_1_0; }

		//target=Target
		public Assignment getTargetAssignment_2() { return cTargetAssignment_2; }

		//Target
		public RuleCall getTargetTargetParserRuleCall_2_0() { return cTargetTargetParserRuleCall_2_0; }

		//"<="
		public Keyword getLessThanSignEqualsSignKeyword_3() { return cLessThanSignEqualsSignKeyword_3; }

		//guarded?="guarded"?
		public Assignment getGuardedAssignment_4() { return cGuardedAssignment_4; }

		//"guarded"
		public Keyword getGuardedGuardedKeyword_4_0() { return cGuardedGuardedKeyword_4_0; }

		//delay=DelayMechanism?
		public Assignment getDelayAssignment_5() { return cDelayAssignment_5; }

		//DelayMechanism
		public RuleCall getDelayDelayMechanismParserRuleCall_5_0() { return cDelayDelayMechanismParserRuleCall_5_0; }

		//waveform=Waveforms
		public Assignment getWaveformAssignment_6() { return cWaveformAssignment_6; }

		//Waveforms
		public RuleCall getWaveformWaveformsParserRuleCall_6_0() { return cWaveformWaveformsParserRuleCall_6_0; }

		//";"
		public Keyword getSemicolonKeyword_7() { return cSemicolonKeyword_7; }
	}

	public class VariableAssignmentStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "VariableAssignmentStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cGroup.eContents().get(0);
		private final Group cGroup_0_0 = (Group)cGroup_0.eContents().get(0);
		private final Group cGroup_0_0_0 = (Group)cGroup_0_0.eContents().get(0);
		private final Assignment cLabelAssignment_0_0_0_0 = (Assignment)cGroup_0_0_0.eContents().get(0);
		private final RuleCall cLabelLabelParserRuleCall_0_0_0_0_0 = (RuleCall)cLabelAssignment_0_0_0_0.eContents().get(0);
		private final Keyword cColonKeyword_0_0_0_1 = (Keyword)cGroup_0_0_0.eContents().get(1);
		private final Assignment cTargetAssignment_0_0_1 = (Assignment)cGroup_0_0.eContents().get(1);
		private final RuleCall cTargetTargetParserRuleCall_0_0_1_0 = (RuleCall)cTargetAssignment_0_0_1.eContents().get(0);
		private final Keyword cColonEqualsSignKeyword_0_0_2 = (Keyword)cGroup_0_0.eContents().get(2);
		private final Assignment cInitialAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cInitialExpressionParserRuleCall_1_0 = (RuleCall)cInitialAssignment_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		/// *
		// * [ label: ] target := expression ;
		// * / VariableAssignmentStatement returns statement::VariableAssignmentStatement:
		//	=> ((label=Label ":")? target=Target ":=") initial=Expression ";";
		public ParserRule getRule() { return rule; }

		//=> ((label=Label ":")? target=Target ":=") initial=Expression ";"
		public Group getGroup() { return cGroup; }

		//=> ((label=Label ":")? target=Target ":=")
		public Group getGroup_0() { return cGroup_0; }

		//(label=Label ":")? target=Target ":="
		public Group getGroup_0_0() { return cGroup_0_0; }

		//(label=Label ":")?
		public Group getGroup_0_0_0() { return cGroup_0_0_0; }

		//label=Label
		public Assignment getLabelAssignment_0_0_0_0() { return cLabelAssignment_0_0_0_0; }

		//Label
		public RuleCall getLabelLabelParserRuleCall_0_0_0_0_0() { return cLabelLabelParserRuleCall_0_0_0_0_0; }

		//":"
		public Keyword getColonKeyword_0_0_0_1() { return cColonKeyword_0_0_0_1; }

		//target=Target
		public Assignment getTargetAssignment_0_0_1() { return cTargetAssignment_0_0_1; }

		//Target
		public RuleCall getTargetTargetParserRuleCall_0_0_1_0() { return cTargetTargetParserRuleCall_0_0_1_0; }

		//":="
		public Keyword getColonEqualsSignKeyword_0_0_2() { return cColonEqualsSignKeyword_0_0_2; }

		//initial=Expression
		public Assignment getInitialAssignment_1() { return cInitialAssignment_1; }

		//Expression
		public RuleCall getInitialExpressionParserRuleCall_1_0() { return cInitialExpressionParserRuleCall_1_0; }

		//";"
		public Keyword getSemicolonKeyword_2() { return cSemicolonKeyword_2; }
	}

	public class SimpleSimultaneousStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SimpleSimultaneousStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cGroup.eContents().get(0);
		private final Group cGroup_0_0 = (Group)cGroup_0.eContents().get(0);
		private final Group cGroup_0_0_0 = (Group)cGroup_0_0.eContents().get(0);
		private final Assignment cLabelAssignment_0_0_0_0 = (Assignment)cGroup_0_0_0.eContents().get(0);
		private final RuleCall cLabelLabelParserRuleCall_0_0_0_0_0 = (RuleCall)cLabelAssignment_0_0_0_0.eContents().get(0);
		private final Keyword cColonKeyword_0_0_0_1 = (Keyword)cGroup_0_0_0.eContents().get(1);
		private final Assignment cLeftAssignment_0_0_1 = (Assignment)cGroup_0_0.eContents().get(1);
		private final RuleCall cLeftSimpleExpressionParserRuleCall_0_0_1_0 = (RuleCall)cLeftAssignment_0_0_1.eContents().get(0);
		private final Keyword cEqualsSignEqualsSignKeyword_0_0_2 = (Keyword)cGroup_0_0.eContents().get(2);
		private final Assignment cRightAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cRightSimpleExpressionParserRuleCall_1_0 = (RuleCall)cRightAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cToleranceKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cToleranceAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cToleranceExpressionParserRuleCall_2_1_0 = (RuleCall)cToleranceAssignment_2_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//SimpleSimultaneousStatement returns statement::SimpleSimultaneousStatement:
		//	=> ((label=Label ":")? left=SimpleExpression "==") right=SimpleExpression ("tolerance" tolerance=Expression)? ";";
		public ParserRule getRule() { return rule; }

		//=> ((label=Label ":")? left=SimpleExpression "==") right=SimpleExpression ("tolerance" tolerance=Expression)? ";"
		public Group getGroup() { return cGroup; }

		//=> ((label=Label ":")? left=SimpleExpression "==")
		public Group getGroup_0() { return cGroup_0; }

		//(label=Label ":")? left=SimpleExpression "=="
		public Group getGroup_0_0() { return cGroup_0_0; }

		//(label=Label ":")?
		public Group getGroup_0_0_0() { return cGroup_0_0_0; }

		//label=Label
		public Assignment getLabelAssignment_0_0_0_0() { return cLabelAssignment_0_0_0_0; }

		//Label
		public RuleCall getLabelLabelParserRuleCall_0_0_0_0_0() { return cLabelLabelParserRuleCall_0_0_0_0_0; }

		//":"
		public Keyword getColonKeyword_0_0_0_1() { return cColonKeyword_0_0_0_1; }

		//left=SimpleExpression
		public Assignment getLeftAssignment_0_0_1() { return cLeftAssignment_0_0_1; }

		//SimpleExpression
		public RuleCall getLeftSimpleExpressionParserRuleCall_0_0_1_0() { return cLeftSimpleExpressionParserRuleCall_0_0_1_0; }

		//"=="
		public Keyword getEqualsSignEqualsSignKeyword_0_0_2() { return cEqualsSignEqualsSignKeyword_0_0_2; }

		//right=SimpleExpression
		public Assignment getRightAssignment_1() { return cRightAssignment_1; }

		//SimpleExpression
		public RuleCall getRightSimpleExpressionParserRuleCall_1_0() { return cRightSimpleExpressionParserRuleCall_1_0; }

		//("tolerance" tolerance=Expression)?
		public Group getGroup_2() { return cGroup_2; }

		//"tolerance"
		public Keyword getToleranceKeyword_2_0() { return cToleranceKeyword_2_0; }

		//tolerance=Expression
		public Assignment getToleranceAssignment_2_1() { return cToleranceAssignment_2_1; }

		//Expression
		public RuleCall getToleranceExpressionParserRuleCall_2_1_0() { return cToleranceExpressionParserRuleCall_2_1_0; }

		//";"
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}

	public class ConditionalWaveformElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ConditionalWaveform");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cWaveformsParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cConditionalWaveformExpressionExpressionAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cWhenKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cChoiceAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cChoiceChoicesParserRuleCall_1_2_0 = (RuleCall)cChoiceAssignment_1_2.eContents().get(0);
		
		//ConditionalWaveform returns expression::Expression:
		//	Waveforms ({expression::ConditionalWaveformExpression.expression=current} "when" choice=Choices)?;
		public ParserRule getRule() { return rule; }

		//Waveforms ({expression::ConditionalWaveformExpression.expression=current} "when" choice=Choices)?
		public Group getGroup() { return cGroup; }

		//Waveforms
		public RuleCall getWaveformsParserRuleCall_0() { return cWaveformsParserRuleCall_0; }

		//({expression::ConditionalWaveformExpression.expression=current} "when" choice=Choices)?
		public Group getGroup_1() { return cGroup_1; }

		//{expression::ConditionalWaveformExpression.expression=current}
		public Action getConditionalWaveformExpressionExpressionAction_1_0() { return cConditionalWaveformExpressionExpressionAction_1_0; }

		//"when"
		public Keyword getWhenKeyword_1_1() { return cWhenKeyword_1_1; }

		//choice=Choices
		public Assignment getChoiceAssignment_1_2() { return cChoiceAssignment_1_2; }

		//Choices
		public RuleCall getChoiceChoicesParserRuleCall_1_2_0() { return cChoiceChoicesParserRuleCall_1_2_0; }
	}

	public class WaveformsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Waveforms");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cUnaffectedParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final RuleCall cWaveformParserRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cGroup_1.eContents().get(1);
		private final Action cMultiExpressionExpressionAction_1_1_0 = (Action)cGroup_1_1.eContents().get(0);
		private final Group cGroup_1_1_1 = (Group)cGroup_1_1.eContents().get(1);
		private final Keyword cCommaKeyword_1_1_1_0 = (Keyword)cGroup_1_1_1.eContents().get(0);
		private final Assignment cExpressionAssignment_1_1_1_1 = (Assignment)cGroup_1_1_1.eContents().get(1);
		private final RuleCall cExpressionWaveformParserRuleCall_1_1_1_1_0 = (RuleCall)cExpressionAssignment_1_1_1_1.eContents().get(0);
		
		//Waveforms returns expression::Expression:
		//	Unaffected | Waveform ({expression::MultiExpression.expression+=current} ("," expression+=Waveform)+)?;
		public ParserRule getRule() { return rule; }

		//Unaffected | Waveform ({expression::MultiExpression.expression+=current} ("," expression+=Waveform)+)?
		public Alternatives getAlternatives() { return cAlternatives; }

		//Unaffected
		public RuleCall getUnaffectedParserRuleCall_0() { return cUnaffectedParserRuleCall_0; }

		//Waveform ({expression::MultiExpression.expression+=current} ("," expression+=Waveform)+)?
		public Group getGroup_1() { return cGroup_1; }

		//Waveform
		public RuleCall getWaveformParserRuleCall_1_0() { return cWaveformParserRuleCall_1_0; }

		//({expression::MultiExpression.expression+=current} ("," expression+=Waveform)+)?
		public Group getGroup_1_1() { return cGroup_1_1; }

		//{expression::MultiExpression.expression+=current}
		public Action getMultiExpressionExpressionAction_1_1_0() { return cMultiExpressionExpressionAction_1_1_0; }

		//("," expression+=Waveform)+
		public Group getGroup_1_1_1() { return cGroup_1_1_1; }

		//","
		public Keyword getCommaKeyword_1_1_1_0() { return cCommaKeyword_1_1_1_0; }

		//expression+=Waveform
		public Assignment getExpressionAssignment_1_1_1_1() { return cExpressionAssignment_1_1_1_1; }

		//Waveform
		public RuleCall getExpressionWaveformParserRuleCall_1_1_1_1_0() { return cExpressionWaveformParserRuleCall_1_1_1_1_0; }
	}

	public class ConfigurationItemElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ConfigurationItem");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cBlockConfigurationParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cComponentConfigurationParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//ConfigurationItem returns configuration::ConfigurationItem:
		//	BlockConfiguration | ComponentConfiguration;
		public ParserRule getRule() { return rule; }

		//BlockConfiguration | ComponentConfiguration
		public Alternatives getAlternatives() { return cAlternatives; }

		//BlockConfiguration
		public RuleCall getBlockConfigurationParserRuleCall_0() { return cBlockConfigurationParserRuleCall_0; }

		//ComponentConfiguration
		public RuleCall getComponentConfigurationParserRuleCall_1() { return cComponentConfigurationParserRuleCall_1; }
	}

	public class ConfigurationSpecificationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ConfigurationSpecification");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cForKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cListAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cListInstantiationListParserRuleCall_1_0 = (RuleCall)cListAssignment_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cComponentAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cComponentNameParserRuleCall_3_0 = (RuleCall)cComponentAssignment_3.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cUseKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Alternatives cAlternatives_4_1 = (Alternatives)cGroup_4.eContents().get(1);
		private final Group cGroup_4_1_0 = (Group)cAlternatives_4_1.eContents().get(0);
		private final Keyword cEntityKeyword_4_1_0_0 = (Keyword)cGroup_4_1_0.eContents().get(0);
		private final Assignment cEntityAssignment_4_1_0_1 = (Assignment)cGroup_4_1_0.eContents().get(1);
		private final RuleCall cEntityNameParserRuleCall_4_1_0_1_0 = (RuleCall)cEntityAssignment_4_1_0_1.eContents().get(0);
		private final Group cGroup_4_1_1 = (Group)cAlternatives_4_1.eContents().get(1);
		private final Keyword cConfigurationKeyword_4_1_1_0 = (Keyword)cGroup_4_1_1.eContents().get(0);
		private final Assignment cConfigurationAssignment_4_1_1_1 = (Assignment)cGroup_4_1_1.eContents().get(1);
		private final RuleCall cConfigurationNameParserRuleCall_4_1_1_1_0 = (RuleCall)cConfigurationAssignment_4_1_1_1.eContents().get(0);
		private final Keyword cOpenKeyword_4_1_2 = (Keyword)cAlternatives_4_1.eContents().get(2);
		private final Assignment cGenericMapAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cGenericMapGenericMapsParserRuleCall_5_0 = (RuleCall)cGenericMapAssignment_5.eContents().get(0);
		private final Assignment cPortMapAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cPortMapPortMapsParserRuleCall_6_0 = (RuleCall)cPortMapAssignment_6.eContents().get(0);
		private final Keyword cSemicolonKeyword_7 = (Keyword)cGroup.eContents().get(7);
		
		//ConfigurationSpecification returns declaration::ConfigurationSpecification:
		//	"for" list=InstantiationList ":" component=Name ("use" ("entity" entity=Name | "configuration" configuration=Name |
		//	"open"))? genericMap=GenericMaps? portMap=PortMaps? ";";
		public ParserRule getRule() { return rule; }

		//"for" list=InstantiationList ":" component=Name ("use" ("entity" entity=Name | "configuration" configuration=Name |
		//"open"))? genericMap=GenericMaps? portMap=PortMaps? ";"
		public Group getGroup() { return cGroup; }

		//"for"
		public Keyword getForKeyword_0() { return cForKeyword_0; }

		//list=InstantiationList
		public Assignment getListAssignment_1() { return cListAssignment_1; }

		//InstantiationList
		public RuleCall getListInstantiationListParserRuleCall_1_0() { return cListInstantiationListParserRuleCall_1_0; }

		//":"
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }

		//component=Name
		public Assignment getComponentAssignment_3() { return cComponentAssignment_3; }

		//Name
		public RuleCall getComponentNameParserRuleCall_3_0() { return cComponentNameParserRuleCall_3_0; }

		//("use" ("entity" entity=Name | "configuration" configuration=Name | "open"))?
		public Group getGroup_4() { return cGroup_4; }

		//"use"
		public Keyword getUseKeyword_4_0() { return cUseKeyword_4_0; }

		//"entity" entity=Name | "configuration" configuration=Name | "open"
		public Alternatives getAlternatives_4_1() { return cAlternatives_4_1; }

		//"entity" entity=Name
		public Group getGroup_4_1_0() { return cGroup_4_1_0; }

		//"entity"
		public Keyword getEntityKeyword_4_1_0_0() { return cEntityKeyword_4_1_0_0; }

		//entity=Name
		public Assignment getEntityAssignment_4_1_0_1() { return cEntityAssignment_4_1_0_1; }

		//Name
		public RuleCall getEntityNameParserRuleCall_4_1_0_1_0() { return cEntityNameParserRuleCall_4_1_0_1_0; }

		//"configuration" configuration=Name
		public Group getGroup_4_1_1() { return cGroup_4_1_1; }

		//"configuration"
		public Keyword getConfigurationKeyword_4_1_1_0() { return cConfigurationKeyword_4_1_1_0; }

		//configuration=Name
		public Assignment getConfigurationAssignment_4_1_1_1() { return cConfigurationAssignment_4_1_1_1; }

		//Name
		public RuleCall getConfigurationNameParserRuleCall_4_1_1_1_0() { return cConfigurationNameParserRuleCall_4_1_1_1_0; }

		//"open"
		public Keyword getOpenKeyword_4_1_2() { return cOpenKeyword_4_1_2; }

		//genericMap=GenericMaps?
		public Assignment getGenericMapAssignment_5() { return cGenericMapAssignment_5; }

		//GenericMaps
		public RuleCall getGenericMapGenericMapsParserRuleCall_5_0() { return cGenericMapGenericMapsParserRuleCall_5_0; }

		//portMap=PortMaps?
		public Assignment getPortMapAssignment_6() { return cPortMapAssignment_6; }

		//PortMaps
		public RuleCall getPortMapPortMapsParserRuleCall_6_0() { return cPortMapPortMapsParserRuleCall_6_0; }

		//";"
		public Keyword getSemicolonKeyword_7() { return cSemicolonKeyword_7; }
	}

	public class DelayMechanismElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DelayMechanism");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cTransportMechanismParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cRejectMechanismParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//DelayMechanism returns statement::DelayMechanism:
		//	TransportMechanism | RejectMechanism;
		public ParserRule getRule() { return rule; }

		//TransportMechanism | RejectMechanism
		public Alternatives getAlternatives() { return cAlternatives; }

		//TransportMechanism
		public RuleCall getTransportMechanismParserRuleCall_0() { return cTransportMechanismParserRuleCall_0; }

		//RejectMechanism
		public RuleCall getRejectMechanismParserRuleCall_1() { return cRejectMechanismParserRuleCall_1; }
	}

	public class RejectMechanismElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RejectMechanism");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cRejectMechanismAction_0 = (Action)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cRejectKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cRejectAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRejectExpressionParserRuleCall_1_1_0 = (RuleCall)cRejectAssignment_1_1.eContents().get(0);
		private final Keyword cInertialKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//RejectMechanism returns statement::RejectMechanism:
		//	{statement::RejectMechanism} ("reject" reject=Expression)? "inertial";
		public ParserRule getRule() { return rule; }

		//{statement::RejectMechanism} ("reject" reject=Expression)? "inertial"
		public Group getGroup() { return cGroup; }

		//{statement::RejectMechanism}
		public Action getRejectMechanismAction_0() { return cRejectMechanismAction_0; }

		//("reject" reject=Expression)?
		public Group getGroup_1() { return cGroup_1; }

		//"reject"
		public Keyword getRejectKeyword_1_0() { return cRejectKeyword_1_0; }

		//reject=Expression
		public Assignment getRejectAssignment_1_1() { return cRejectAssignment_1_1; }

		//Expression
		public RuleCall getRejectExpressionParserRuleCall_1_1_0() { return cRejectExpressionParserRuleCall_1_1_0; }

		//"inertial"
		public Keyword getInertialKeyword_2() { return cInertialKeyword_2; }
	}

	public class TransportMechanismElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TransportMechanism");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cTransportMechanismAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cTransportKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//TransportMechanism returns statement::TransportMechanism:
		//	{statement::TransportMechanism} "transport";
		public ParserRule getRule() { return rule; }

		//{statement::TransportMechanism} "transport"
		public Group getGroup() { return cGroup; }

		//{statement::TransportMechanism}
		public Action getTransportMechanismAction_0() { return cTransportMechanismAction_0; }

		//"transport"
		public Keyword getTransportKeyword_1() { return cTransportKeyword_1; }
	}

	public class DisconnectionSpecificationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DisconnectionSpecification");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDisconnectKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cDisconnectAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cDisconnectMultiNameParserRuleCall_1_0 = (RuleCall)cDisconnectAssignment_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cTypeAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cTypeNameParserRuleCall_3_0 = (RuleCall)cTypeAssignment_3.eContents().get(0);
		private final Keyword cAfterKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cAfterAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cAfterExpressionParserRuleCall_5_0 = (RuleCall)cAfterAssignment_5.eContents().get(0);
		private final Keyword cSemicolonKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		/// *
		// * disconnection_specification = "disconnect" guarded_signal_specification "after" time_expression ";".
		// *
		// * guarded_signal_specification = guarded_signal_list ":" type_mark.
		// * / DisconnectionSpecification returns declaration::DisconnectionSpecification:
		//	"disconnect" disconnect=MultiName ":" type=Name "after" after=Expression ";";
		public ParserRule getRule() { return rule; }

		//"disconnect" disconnect=MultiName ":" type=Name "after" after=Expression ";"
		public Group getGroup() { return cGroup; }

		//"disconnect"
		public Keyword getDisconnectKeyword_0() { return cDisconnectKeyword_0; }

		//disconnect=MultiName
		public Assignment getDisconnectAssignment_1() { return cDisconnectAssignment_1; }

		//MultiName
		public RuleCall getDisconnectMultiNameParserRuleCall_1_0() { return cDisconnectMultiNameParserRuleCall_1_0; }

		//":"
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }

		//type=Name
		public Assignment getTypeAssignment_3() { return cTypeAssignment_3; }

		//Name
		public RuleCall getTypeNameParserRuleCall_3_0() { return cTypeNameParserRuleCall_3_0; }

		//"after"
		public Keyword getAfterKeyword_4() { return cAfterKeyword_4; }

		//after=Expression
		public Assignment getAfterAssignment_5() { return cAfterAssignment_5; }

		//Expression
		public RuleCall getAfterExpressionParserRuleCall_5_0() { return cAfterExpressionParserRuleCall_5_0; }

		//";"
		public Keyword getSemicolonKeyword_6() { return cSemicolonKeyword_6; }
	}

	public class MultiNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MultiName");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cNameParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cNameListNameAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cGroup_1.eContents().get(1);
		private final Keyword cCommaKeyword_1_1_0 = (Keyword)cGroup_1_1.eContents().get(0);
		private final Assignment cNameAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cNameNameParserRuleCall_1_1_1_0 = (RuleCall)cNameAssignment_1_1_1.eContents().get(0);
		
		//MultiName:
		//	Name ({NameList.name+=current} ("," name+=Name)+)?;
		public ParserRule getRule() { return rule; }

		//Name ({NameList.name+=current} ("," name+=Name)+)?
		public Group getGroup() { return cGroup; }

		//Name
		public RuleCall getNameParserRuleCall_0() { return cNameParserRuleCall_0; }

		//({NameList.name+=current} ("," name+=Name)+)?
		public Group getGroup_1() { return cGroup_1; }

		//{NameList.name+=current}
		public Action getNameListNameAction_1_0() { return cNameListNameAction_1_0; }

		//("," name+=Name)+
		public Group getGroup_1_1() { return cGroup_1_1; }

		//","
		public Keyword getCommaKeyword_1_1_0() { return cCommaKeyword_1_1_0; }

		//name+=Name
		public Assignment getNameAssignment_1_1_1() { return cNameAssignment_1_1_1; }

		//Name
		public RuleCall getNameNameParserRuleCall_1_1_1_0() { return cNameNameParserRuleCall_1_1_1_0; }
	}

	public class MultiIdentifierNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MultiIdentifierName");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cIdentifierNameParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cNameListNameAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cGroup_1.eContents().get(1);
		private final Keyword cCommaKeyword_1_1_0 = (Keyword)cGroup_1_1.eContents().get(0);
		private final Assignment cNameAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cNameIdentifierNameParserRuleCall_1_1_1_0 = (RuleCall)cNameAssignment_1_1_1.eContents().get(0);
		
		//MultiIdentifierName returns MultiName:
		//	IdentifierName ({NameList.name+=current} ("," name+=IdentifierName)+)?;
		public ParserRule getRule() { return rule; }

		//IdentifierName ({NameList.name+=current} ("," name+=IdentifierName)+)?
		public Group getGroup() { return cGroup; }

		//IdentifierName
		public RuleCall getIdentifierNameParserRuleCall_0() { return cIdentifierNameParserRuleCall_0; }

		//({NameList.name+=current} ("," name+=IdentifierName)+)?
		public Group getGroup_1() { return cGroup_1; }

		//{NameList.name+=current}
		public Action getNameListNameAction_1_0() { return cNameListNameAction_1_0; }

		//("," name+=IdentifierName)+
		public Group getGroup_1_1() { return cGroup_1_1; }

		//","
		public Keyword getCommaKeyword_1_1_0() { return cCommaKeyword_1_1_0; }

		//name+=IdentifierName
		public Assignment getNameAssignment_1_1_1() { return cNameAssignment_1_1_1; }

		//IdentifierName
		public RuleCall getNameIdentifierNameParserRuleCall_1_1_1_0() { return cNameIdentifierNameParserRuleCall_1_1_1_0; }
	}

	public class InstantiationListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "InstantiationList");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cMultiIdentifierNameParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cOthersParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cAllParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//InstantiationList returns MultiName:
		//	MultiIdentifierName | Others | All;
		public ParserRule getRule() { return rule; }

		//MultiIdentifierName | Others | All
		public Alternatives getAlternatives() { return cAlternatives; }

		//MultiIdentifierName
		public RuleCall getMultiIdentifierNameParserRuleCall_0() { return cMultiIdentifierNameParserRuleCall_0; }

		//Others
		public RuleCall getOthersParserRuleCall_1() { return cOthersParserRuleCall_1; }

		//All
		public RuleCall getAllParserRuleCall_2() { return cAllParserRuleCall_2; }
	}

	public class EntityStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EntityStatement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cConcurrentAssertionStatementParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cProcessStatementParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cConcurrentProcedureCallStatementParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//EntityStatement returns statement::Statement:
		//	ConcurrentAssertionStatement | ProcessStatement | ConcurrentProcedureCallStatement;
		public ParserRule getRule() { return rule; }

		//ConcurrentAssertionStatement | ProcessStatement | ConcurrentProcedureCallStatement
		public Alternatives getAlternatives() { return cAlternatives; }

		//ConcurrentAssertionStatement
		public RuleCall getConcurrentAssertionStatementParserRuleCall_0() { return cConcurrentAssertionStatementParserRuleCall_0; }

		//ProcessStatement
		public RuleCall getProcessStatementParserRuleCall_1() { return cProcessStatementParserRuleCall_1; }

		//ConcurrentProcedureCallStatement
		public RuleCall getConcurrentProcedureCallStatementParserRuleCall_2() { return cConcurrentProcedureCallStatementParserRuleCall_2; }
	}

	public class EnumerationTypeDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EnumerationTypeDefinition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cLiteralAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLiteralEnumerationLiteralParserRuleCall_1_0 = (RuleCall)cLiteralAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cLiteralAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cLiteralEnumerationLiteralParserRuleCall_2_1_0 = (RuleCall)cLiteralAssignment_2_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//EnumerationTypeDefinition returns type::EnumerationTypeDefinition:
		//	"(" literal+=EnumerationLiteral ("," literal+=EnumerationLiteral)* ")";
		public ParserRule getRule() { return rule; }

		//"(" literal+=EnumerationLiteral ("," literal+=EnumerationLiteral)* ")"
		public Group getGroup() { return cGroup; }

		//"("
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }

		//literal+=EnumerationLiteral
		public Assignment getLiteralAssignment_1() { return cLiteralAssignment_1; }

		//EnumerationLiteral
		public RuleCall getLiteralEnumerationLiteralParserRuleCall_1_0() { return cLiteralEnumerationLiteralParserRuleCall_1_0; }

		//("," literal+=EnumerationLiteral)*
		public Group getGroup_2() { return cGroup_2; }

		//","
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }

		//literal+=EnumerationLiteral
		public Assignment getLiteralAssignment_2_1() { return cLiteralAssignment_2_1; }

		//EnumerationLiteral
		public RuleCall getLiteralEnumerationLiteralParserRuleCall_2_1_0() { return cLiteralEnumerationLiteralParserRuleCall_2_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}

	public class EnumerationLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EnumerationLiteral");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIdentifierNameParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cCharacterNameParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//EnumerationLiteral returns type::EnumerationLiteral:
		//	IdentifierName | CharacterName;
		public ParserRule getRule() { return rule; }

		//IdentifierName | CharacterName
		public Alternatives getAlternatives() { return cAlternatives; }

		//IdentifierName
		public RuleCall getIdentifierNameParserRuleCall_0() { return cIdentifierNameParserRuleCall_0; }

		//CharacterName
		public RuleCall getCharacterNameParserRuleCall_1() { return cCharacterNameParserRuleCall_1; }
	}

	public class ExitStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ExitStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cExitStatementAction_0 = (Action)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cLabelAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cLabelLabelParserRuleCall_1_0_0 = (RuleCall)cLabelAssignment_1_0.eContents().get(0);
		private final Keyword cColonKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Keyword cExitKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cExitAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cExitIdentifierParserRuleCall_3_0 = (RuleCall)cExitAssignment_3.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cWhenKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cWhenAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cWhenExpressionParserRuleCall_4_1_0 = (RuleCall)cWhenAssignment_4_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		/// *
		// * [ label: ] exit [ label2 ] [ when condition ] ;
		// * / ExitStatement returns statement::ExitStatement:
		//	{statement::ExitStatement} (label=Label ":")? "exit" exit=Identifier? ("when" when=Expression)? ";";
		public ParserRule getRule() { return rule; }

		//{statement::ExitStatement} (label=Label ":")? "exit" exit=Identifier? ("when" when=Expression)? ";"
		public Group getGroup() { return cGroup; }

		//{statement::ExitStatement}
		public Action getExitStatementAction_0() { return cExitStatementAction_0; }

		//(label=Label ":")?
		public Group getGroup_1() { return cGroup_1; }

		//label=Label
		public Assignment getLabelAssignment_1_0() { return cLabelAssignment_1_0; }

		//Label
		public RuleCall getLabelLabelParserRuleCall_1_0_0() { return cLabelLabelParserRuleCall_1_0_0; }

		//":"
		public Keyword getColonKeyword_1_1() { return cColonKeyword_1_1; }

		//"exit"
		public Keyword getExitKeyword_2() { return cExitKeyword_2; }

		//exit=Identifier?
		public Assignment getExitAssignment_3() { return cExitAssignment_3; }

		//Identifier
		public RuleCall getExitIdentifierParserRuleCall_3_0() { return cExitIdentifierParserRuleCall_3_0; }

		//("when" when=Expression)?
		public Group getGroup_4() { return cGroup_4; }

		//"when"
		public Keyword getWhenKeyword_4_0() { return cWhenKeyword_4_0; }

		//when=Expression
		public Assignment getWhenAssignment_4_1() { return cWhenAssignment_4_1; }

		//Expression
		public RuleCall getWhenExpressionParserRuleCall_4_1_0() { return cWhenExpressionParserRuleCall_4_1_0; }

		//";"
		public Keyword getSemicolonKeyword_5() { return cSemicolonKeyword_5; }
	}

	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Expression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cRelationParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cLogicalExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorLogicalOperatorEnumRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightRelationParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		/// *
		// * Addition returns Expression:
		// * Multiplication ({Addition.left=current} '+' right=Multiplication)*;
		// * / Expression returns expression::Expression:
		//	Relation ({expression::LogicalExpression.left=current} operator=LogicalOperator right=Relation)*;
		public ParserRule getRule() { return rule; }

		//Relation ({expression::LogicalExpression.left=current} operator=LogicalOperator right=Relation)*
		public Group getGroup() { return cGroup; }

		//Relation
		public RuleCall getRelationParserRuleCall_0() { return cRelationParserRuleCall_0; }

		//({expression::LogicalExpression.left=current} operator=LogicalOperator right=Relation)*
		public Group getGroup_1() { return cGroup_1; }

		//{expression::LogicalExpression.left=current}
		public Action getLogicalExpressionLeftAction_1_0() { return cLogicalExpressionLeftAction_1_0; }

		//operator=LogicalOperator
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//LogicalOperator
		public RuleCall getOperatorLogicalOperatorEnumRuleCall_1_1_0() { return cOperatorLogicalOperatorEnumRuleCall_1_1_0; }

		//right=Relation
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//Relation
		public RuleCall getRightRelationParserRuleCall_1_2_0() { return cRightRelationParserRuleCall_1_2_0; }
	}

	public class RelationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Relation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cShiftExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cRelationalExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorRelationalOperatorEnumRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightShiftExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Relation returns expression::Expression:
		//	ShiftExpression ({expression::RelationalExpression.left=current} operator=RelationalOperator right=ShiftExpression)?;
		public ParserRule getRule() { return rule; }

		//ShiftExpression ({expression::RelationalExpression.left=current} operator=RelationalOperator right=ShiftExpression)?
		public Group getGroup() { return cGroup; }

		//ShiftExpression
		public RuleCall getShiftExpressionParserRuleCall_0() { return cShiftExpressionParserRuleCall_0; }

		//({expression::RelationalExpression.left=current} operator=RelationalOperator right=ShiftExpression)?
		public Group getGroup_1() { return cGroup_1; }

		//{expression::RelationalExpression.left=current}
		public Action getRelationalExpressionLeftAction_1_0() { return cRelationalExpressionLeftAction_1_0; }

		//operator=RelationalOperator
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//RelationalOperator
		public RuleCall getOperatorRelationalOperatorEnumRuleCall_1_1_0() { return cOperatorRelationalOperatorEnumRuleCall_1_1_0; }

		//right=ShiftExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//ShiftExpression
		public RuleCall getRightShiftExpressionParserRuleCall_1_2_0() { return cRightShiftExpressionParserRuleCall_1_2_0; }
	}

	public class ShiftExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ShiftExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cSimpleExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cShiftExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorShiftOperatorEnumRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightSimpleExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//ShiftExpression returns expression::Expression:
		//	SimpleExpression ({expression::ShiftExpression.left=current} operator=ShiftOperator right=SimpleExpression)?;
		public ParserRule getRule() { return rule; }

		//SimpleExpression ({expression::ShiftExpression.left=current} operator=ShiftOperator right=SimpleExpression)?
		public Group getGroup() { return cGroup; }

		//SimpleExpression
		public RuleCall getSimpleExpressionParserRuleCall_0() { return cSimpleExpressionParserRuleCall_0; }

		//({expression::ShiftExpression.left=current} operator=ShiftOperator right=SimpleExpression)?
		public Group getGroup_1() { return cGroup_1; }

		//{expression::ShiftExpression.left=current}
		public Action getShiftExpressionLeftAction_1_0() { return cShiftExpressionLeftAction_1_0; }

		//operator=ShiftOperator
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//ShiftOperator
		public RuleCall getOperatorShiftOperatorEnumRuleCall_1_1_0() { return cOperatorShiftOperatorEnumRuleCall_1_1_0; }

		//right=SimpleExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//SimpleExpression
		public RuleCall getRightSimpleExpressionParserRuleCall_1_2_0() { return cRightSimpleExpressionParserRuleCall_1_2_0; }
	}

	public class SimpleExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SimpleExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final RuleCall cTermExpressionParserRuleCall_0_0 = (RuleCall)cGroup_0.eContents().get(0);
		private final Group cGroup_0_1 = (Group)cGroup_0.eContents().get(1);
		private final Action cAddingExpressionLeftAction_0_1_0 = (Action)cGroup_0_1.eContents().get(0);
		private final Assignment cOperatorAssignment_0_1_1 = (Assignment)cGroup_0_1.eContents().get(1);
		private final RuleCall cOperatorAddingOperatorEnumRuleCall_0_1_1_0 = (RuleCall)cOperatorAssignment_0_1_1.eContents().get(0);
		private final Assignment cRightAssignment_0_1_2 = (Assignment)cGroup_0_1.eContents().get(2);
		private final RuleCall cRightTermExpressionParserRuleCall_0_1_2_0 = (RuleCall)cRightAssignment_0_1_2.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final RuleCall cSignTermExpressionParserRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cGroup_1.eContents().get(1);
		private final Action cAddingExpressionLeftAction_1_1_0 = (Action)cGroup_1_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cOperatorAddingOperatorEnumRuleCall_1_1_1_0 = (RuleCall)cOperatorAssignment_1_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_1_2 = (Assignment)cGroup_1_1.eContents().get(2);
		private final RuleCall cRightTermExpressionParserRuleCall_1_1_2_0 = (RuleCall)cRightAssignment_1_1_2.eContents().get(0);
		
		//SimpleExpression returns expression::Expression:
		//	TermExpression ({expression::AddingExpression.left=current} operator=AddingOperator right=TermExpression)* |
		//	SignTermExpression ({expression::AddingExpression.left=current} operator=AddingOperator right=TermExpression)*;
		public ParserRule getRule() { return rule; }

		//TermExpression ({expression::AddingExpression.left=current} operator=AddingOperator right=TermExpression)* |
		//SignTermExpression ({expression::AddingExpression.left=current} operator=AddingOperator right=TermExpression)*
		public Alternatives getAlternatives() { return cAlternatives; }

		//TermExpression ({expression::AddingExpression.left=current} operator=AddingOperator right=TermExpression)*
		public Group getGroup_0() { return cGroup_0; }

		//TermExpression
		public RuleCall getTermExpressionParserRuleCall_0_0() { return cTermExpressionParserRuleCall_0_0; }

		//({expression::AddingExpression.left=current} operator=AddingOperator right=TermExpression)*
		public Group getGroup_0_1() { return cGroup_0_1; }

		//{expression::AddingExpression.left=current}
		public Action getAddingExpressionLeftAction_0_1_0() { return cAddingExpressionLeftAction_0_1_0; }

		//operator=AddingOperator
		public Assignment getOperatorAssignment_0_1_1() { return cOperatorAssignment_0_1_1; }

		//AddingOperator
		public RuleCall getOperatorAddingOperatorEnumRuleCall_0_1_1_0() { return cOperatorAddingOperatorEnumRuleCall_0_1_1_0; }

		//right=TermExpression
		public Assignment getRightAssignment_0_1_2() { return cRightAssignment_0_1_2; }

		//TermExpression
		public RuleCall getRightTermExpressionParserRuleCall_0_1_2_0() { return cRightTermExpressionParserRuleCall_0_1_2_0; }

		//SignTermExpression ({expression::AddingExpression.left=current} operator=AddingOperator right=TermExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//SignTermExpression
		public RuleCall getSignTermExpressionParserRuleCall_1_0() { return cSignTermExpressionParserRuleCall_1_0; }

		//({expression::AddingExpression.left=current} operator=AddingOperator right=TermExpression)*
		public Group getGroup_1_1() { return cGroup_1_1; }

		//{expression::AddingExpression.left=current}
		public Action getAddingExpressionLeftAction_1_1_0() { return cAddingExpressionLeftAction_1_1_0; }

		//operator=AddingOperator
		public Assignment getOperatorAssignment_1_1_1() { return cOperatorAssignment_1_1_1; }

		//AddingOperator
		public RuleCall getOperatorAddingOperatorEnumRuleCall_1_1_1_0() { return cOperatorAddingOperatorEnumRuleCall_1_1_1_0; }

		//right=TermExpression
		public Assignment getRightAssignment_1_1_2() { return cRightAssignment_1_1_2; }

		//TermExpression
		public RuleCall getRightTermExpressionParserRuleCall_1_1_2_0() { return cRightTermExpressionParserRuleCall_1_1_2_0; }
	}

	public class SignTermExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SignTermExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cSignFactorParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cMultiplyingExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorMultiplyingOperatorEnumRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightFactorParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//SignTermExpression returns expression::Expression:
		//	SignFactor ({expression::MultiplyingExpression.left=current} operator=MultiplyingOperator right=Factor)*;
		public ParserRule getRule() { return rule; }

		//SignFactor ({expression::MultiplyingExpression.left=current} operator=MultiplyingOperator right=Factor)*
		public Group getGroup() { return cGroup; }

		//SignFactor
		public RuleCall getSignFactorParserRuleCall_0() { return cSignFactorParserRuleCall_0; }

		//({expression::MultiplyingExpression.left=current} operator=MultiplyingOperator right=Factor)*
		public Group getGroup_1() { return cGroup_1; }

		//{expression::MultiplyingExpression.left=current}
		public Action getMultiplyingExpressionLeftAction_1_0() { return cMultiplyingExpressionLeftAction_1_0; }

		//operator=MultiplyingOperator
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//MultiplyingOperator
		public RuleCall getOperatorMultiplyingOperatorEnumRuleCall_1_1_0() { return cOperatorMultiplyingOperatorEnumRuleCall_1_1_0; }

		//right=Factor
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//Factor
		public RuleCall getRightFactorParserRuleCall_1_2_0() { return cRightFactorParserRuleCall_1_2_0; }
	}

	public class TermExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TermExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cFactorParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cMultiplyingExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorMultiplyingOperatorEnumRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightFactorParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//TermExpression returns expression::Expression:
		//	Factor ({expression::MultiplyingExpression.left=current} operator=MultiplyingOperator right=Factor)*;
		public ParserRule getRule() { return rule; }

		//Factor ({expression::MultiplyingExpression.left=current} operator=MultiplyingOperator right=Factor)*
		public Group getGroup() { return cGroup; }

		//Factor
		public RuleCall getFactorParserRuleCall_0() { return cFactorParserRuleCall_0; }

		//({expression::MultiplyingExpression.left=current} operator=MultiplyingOperator right=Factor)*
		public Group getGroup_1() { return cGroup_1; }

		//{expression::MultiplyingExpression.left=current}
		public Action getMultiplyingExpressionLeftAction_1_0() { return cMultiplyingExpressionLeftAction_1_0; }

		//operator=MultiplyingOperator
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//MultiplyingOperator
		public RuleCall getOperatorMultiplyingOperatorEnumRuleCall_1_1_0() { return cOperatorMultiplyingOperatorEnumRuleCall_1_1_0; }

		//right=Factor
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//Factor
		public RuleCall getRightFactorParserRuleCall_1_2_0() { return cRightFactorParserRuleCall_1_2_0; }
	}

	public class FactorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Factor");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final RuleCall cPrimaryParserRuleCall_0_0 = (RuleCall)cGroup_0.eContents().get(0);
		private final Group cGroup_0_1 = (Group)cGroup_0.eContents().get(1);
		private final Action cPowerExpressionLeftAction_0_1_0 = (Action)cGroup_0_1.eContents().get(0);
		private final Keyword cAsteriskAsteriskKeyword_0_1_1 = (Keyword)cGroup_0_1.eContents().get(1);
		private final Assignment cRightAssignment_0_1_2 = (Assignment)cGroup_0_1.eContents().get(2);
		private final RuleCall cRightPrimaryParserRuleCall_0_1_2_0 = (RuleCall)cRightAssignment_0_1_2.eContents().get(0);
		private final RuleCall cUnaryExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Factor returns expression::Expression:
		//	Primary ({expression::PowerExpression.left=current} "**" right=Primary)? | UnaryExpression;
		public ParserRule getRule() { return rule; }

		//Primary ({expression::PowerExpression.left=current} "**" right=Primary)? | UnaryExpression
		public Alternatives getAlternatives() { return cAlternatives; }

		//Primary ({expression::PowerExpression.left=current} "**" right=Primary)?
		public Group getGroup_0() { return cGroup_0; }

		//Primary
		public RuleCall getPrimaryParserRuleCall_0_0() { return cPrimaryParserRuleCall_0_0; }

		//({expression::PowerExpression.left=current} "**" right=Primary)?
		public Group getGroup_0_1() { return cGroup_0_1; }

		//{expression::PowerExpression.left=current}
		public Action getPowerExpressionLeftAction_0_1_0() { return cPowerExpressionLeftAction_0_1_0; }

		//"**"
		public Keyword getAsteriskAsteriskKeyword_0_1_1() { return cAsteriskAsteriskKeyword_0_1_1; }

		//right=Primary
		public Assignment getRightAssignment_0_1_2() { return cRightAssignment_0_1_2; }

		//Primary
		public RuleCall getRightPrimaryParserRuleCall_0_1_2_0() { return cRightPrimaryParserRuleCall_0_1_2_0; }

		//UnaryExpression
		public RuleCall getUnaryExpressionParserRuleCall_1() { return cUnaryExpressionParserRuleCall_1; }
	}

	public class UnaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnaryExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cUnaryExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cOperatorAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cOperatorUnaryOperatorEnumRuleCall_1_0 = (RuleCall)cOperatorAssignment_1.eContents().get(0);
		private final Assignment cExpressionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExpressionPrimaryParserRuleCall_2_0 = (RuleCall)cExpressionAssignment_2.eContents().get(0);
		
		//UnaryExpression returns expression::Expression:
		//	{expression::UnaryExpression} operator=UnaryOperator expression=Primary;
		public ParserRule getRule() { return rule; }

		//{expression::UnaryExpression} operator=UnaryOperator expression=Primary
		public Group getGroup() { return cGroup; }

		//{expression::UnaryExpression}
		public Action getUnaryExpressionAction_0() { return cUnaryExpressionAction_0; }

		//operator=UnaryOperator
		public Assignment getOperatorAssignment_1() { return cOperatorAssignment_1; }

		//UnaryOperator
		public RuleCall getOperatorUnaryOperatorEnumRuleCall_1_0() { return cOperatorUnaryOperatorEnumRuleCall_1_0; }

		//expression=Primary
		public Assignment getExpressionAssignment_2() { return cExpressionAssignment_2; }

		//Primary
		public RuleCall getExpressionPrimaryParserRuleCall_2_0() { return cExpressionPrimaryParserRuleCall_2_0; }
	}

	public class SignFactorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SignFactor");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final RuleCall cSignPrimaryParserRuleCall_0_0 = (RuleCall)cGroup_0.eContents().get(0);
		private final Group cGroup_0_1 = (Group)cGroup_0.eContents().get(1);
		private final Action cPowerExpressionLeftAction_0_1_0 = (Action)cGroup_0_1.eContents().get(0);
		private final Keyword cAsteriskAsteriskKeyword_0_1_1 = (Keyword)cGroup_0_1.eContents().get(1);
		private final Assignment cRightAssignment_0_1_2 = (Assignment)cGroup_0_1.eContents().get(2);
		private final RuleCall cRightPrimaryParserRuleCall_0_1_2_0 = (RuleCall)cRightAssignment_0_1_2.eContents().get(0);
		private final RuleCall cSignUnaryExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//SignFactor returns expression::Expression:
		//	SignPrimary ({expression::PowerExpression.left=current} "**" right=Primary)? | SignUnaryExpression;
		public ParserRule getRule() { return rule; }

		//SignPrimary ({expression::PowerExpression.left=current} "**" right=Primary)? | SignUnaryExpression
		public Alternatives getAlternatives() { return cAlternatives; }

		//SignPrimary ({expression::PowerExpression.left=current} "**" right=Primary)?
		public Group getGroup_0() { return cGroup_0; }

		//SignPrimary
		public RuleCall getSignPrimaryParserRuleCall_0_0() { return cSignPrimaryParserRuleCall_0_0; }

		//({expression::PowerExpression.left=current} "**" right=Primary)?
		public Group getGroup_0_1() { return cGroup_0_1; }

		//{expression::PowerExpression.left=current}
		public Action getPowerExpressionLeftAction_0_1_0() { return cPowerExpressionLeftAction_0_1_0; }

		//"**"
		public Keyword getAsteriskAsteriskKeyword_0_1_1() { return cAsteriskAsteriskKeyword_0_1_1; }

		//right=Primary
		public Assignment getRightAssignment_0_1_2() { return cRightAssignment_0_1_2; }

		//Primary
		public RuleCall getRightPrimaryParserRuleCall_0_1_2_0() { return cRightPrimaryParserRuleCall_0_1_2_0; }

		//SignUnaryExpression
		public RuleCall getSignUnaryExpressionParserRuleCall_1() { return cSignUnaryExpressionParserRuleCall_1; }
	}

	public class SignUnaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SignUnaryExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cSignExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cSignAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cSignSignEnumRuleCall_1_0 = (RuleCall)cSignAssignment_1.eContents().get(0);
		private final Assignment cExpressionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExpressionUnaryExpressionParserRuleCall_2_0 = (RuleCall)cExpressionAssignment_2.eContents().get(0);
		
		//SignUnaryExpression returns expression::Expression:
		//	{expression::SignExpression} sign=Sign expression=UnaryExpression;
		public ParserRule getRule() { return rule; }

		//{expression::SignExpression} sign=Sign expression=UnaryExpression
		public Group getGroup() { return cGroup; }

		//{expression::SignExpression}
		public Action getSignExpressionAction_0() { return cSignExpressionAction_0; }

		//sign=Sign
		public Assignment getSignAssignment_1() { return cSignAssignment_1; }

		//Sign
		public RuleCall getSignSignEnumRuleCall_1_0() { return cSignSignEnumRuleCall_1_0; }

		//expression=UnaryExpression
		public Assignment getExpressionAssignment_2() { return cExpressionAssignment_2; }

		//UnaryExpression
		public RuleCall getExpressionUnaryExpressionParserRuleCall_2_0() { return cExpressionUnaryExpressionParserRuleCall_2_0; }
	}

	public class SignPrimaryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SignPrimary");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cSignExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cSignAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cSignSignEnumRuleCall_1_0 = (RuleCall)cSignAssignment_1.eContents().get(0);
		private final Assignment cExpressionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExpressionPrimaryParserRuleCall_2_0 = (RuleCall)cExpressionAssignment_2.eContents().get(0);
		
		//SignPrimary returns expression::Expression:
		//	{expression::SignExpression} sign=Sign expression=Primary;
		public ParserRule getRule() { return rule; }

		//{expression::SignExpression} sign=Sign expression=Primary
		public Group getGroup() { return cGroup; }

		//{expression::SignExpression}
		public Action getSignExpressionAction_0() { return cSignExpressionAction_0; }

		//sign=Sign
		public Assignment getSignAssignment_1() { return cSignAssignment_1; }

		//Sign
		public RuleCall getSignSignEnumRuleCall_1_0() { return cSignSignEnumRuleCall_1_0; }

		//expression=Primary
		public Assignment getExpressionAssignment_2() { return cExpressionAssignment_2; }

		//Primary
		public RuleCall getExpressionPrimaryParserRuleCall_2_0() { return cExpressionPrimaryParserRuleCall_2_0; }
	}

	public class PrimaryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Primary");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cAllocatorExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cNameExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cNullExpressionParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cBitStringNameParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cCharacterNameParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cValueExpressionParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cAggregateParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		
		//Primary returns expression::Expression:
		//	AllocatorExpression | NameExpression | NullExpression | BitStringName | CharacterName | ValueExpression | Aggregate;
		public ParserRule getRule() { return rule; }

		//AllocatorExpression | NameExpression | NullExpression | BitStringName | CharacterName | ValueExpression | Aggregate
		public Alternatives getAlternatives() { return cAlternatives; }

		//AllocatorExpression
		public RuleCall getAllocatorExpressionParserRuleCall_0() { return cAllocatorExpressionParserRuleCall_0; }

		//NameExpression
		public RuleCall getNameExpressionParserRuleCall_1() { return cNameExpressionParserRuleCall_1; }

		//NullExpression
		public RuleCall getNullExpressionParserRuleCall_2() { return cNullExpressionParserRuleCall_2; }

		//BitStringName
		public RuleCall getBitStringNameParserRuleCall_3() { return cBitStringNameParserRuleCall_3; }

		//CharacterName
		public RuleCall getCharacterNameParserRuleCall_4() { return cCharacterNameParserRuleCall_4; }

		//ValueExpression
		public RuleCall getValueExpressionParserRuleCall_5() { return cValueExpressionParserRuleCall_5; }

		//Aggregate
		public RuleCall getAggregateParserRuleCall_6() { return cAggregateParserRuleCall_6; }
	}

	public class FileDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FileDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFileKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameMultiIdentifierNameParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cTypeAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cTypeSubtypeIndicationParserRuleCall_3_0 = (RuleCall)cTypeAssignment_3.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Group cGroup_4_0 = (Group)cGroup_4.eContents().get(0);
		private final Keyword cOpenKeyword_4_0_0 = (Keyword)cGroup_4_0.eContents().get(0);
		private final Assignment cOpenAssignment_4_0_1 = (Assignment)cGroup_4_0.eContents().get(1);
		private final RuleCall cOpenExpressionParserRuleCall_4_0_1_0 = (RuleCall)cOpenAssignment_4_0_1.eContents().get(0);
		private final Keyword cIsKeyword_4_1 = (Keyword)cGroup_4.eContents().get(1);
		private final Assignment cIsAssignment_4_2 = (Assignment)cGroup_4.eContents().get(2);
		private final RuleCall cIsExpressionParserRuleCall_4_2_0 = (RuleCall)cIsAssignment_4_2.eContents().get(0);
		private final Keyword cSemicolonKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//FileDeclaration returns declaration::FileDeclaration:
		//	"file" name=MultiIdentifierName ":" type=SubtypeIndication (("open" open=Expression)? "is" is=Expression)? ";";
		public ParserRule getRule() { return rule; }

		//"file" name=MultiIdentifierName ":" type=SubtypeIndication (("open" open=Expression)? "is" is=Expression)? ";"
		public Group getGroup() { return cGroup; }

		//"file"
		public Keyword getFileKeyword_0() { return cFileKeyword_0; }

		//name=MultiIdentifierName
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//MultiIdentifierName
		public RuleCall getNameMultiIdentifierNameParserRuleCall_1_0() { return cNameMultiIdentifierNameParserRuleCall_1_0; }

		//":"
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }

		//type=SubtypeIndication
		public Assignment getTypeAssignment_3() { return cTypeAssignment_3; }

		//SubtypeIndication
		public RuleCall getTypeSubtypeIndicationParserRuleCall_3_0() { return cTypeSubtypeIndicationParserRuleCall_3_0; }

		//(("open" open=Expression)? "is" is=Expression)?
		public Group getGroup_4() { return cGroup_4; }

		//("open" open=Expression)?
		public Group getGroup_4_0() { return cGroup_4_0; }

		//"open"
		public Keyword getOpenKeyword_4_0_0() { return cOpenKeyword_4_0_0; }

		//open=Expression
		public Assignment getOpenAssignment_4_0_1() { return cOpenAssignment_4_0_1; }

		//Expression
		public RuleCall getOpenExpressionParserRuleCall_4_0_1_0() { return cOpenExpressionParserRuleCall_4_0_1_0; }

		//"is"
		public Keyword getIsKeyword_4_1() { return cIsKeyword_4_1; }

		//is=Expression
		public Assignment getIsAssignment_4_2() { return cIsAssignment_4_2; }

		//Expression
		public RuleCall getIsExpressionParserRuleCall_4_2_0() { return cIsExpressionParserRuleCall_4_2_0; }

		//";"
		public Keyword getSemicolonKeyword_5() { return cSemicolonKeyword_5; }
	}

	public class InterfaceFileDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "InterfaceFileDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFileKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameMultiIdentifierNameParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cTypeAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cTypeSubtypeIndicationParserRuleCall_3_0 = (RuleCall)cTypeAssignment_3.eContents().get(0);
		
		//InterfaceFileDeclaration returns declaration::FileDeclaration:
		//	"file" name=MultiIdentifierName ":" type=SubtypeIndication;
		public ParserRule getRule() { return rule; }

		//"file" name=MultiIdentifierName ":" type=SubtypeIndication
		public Group getGroup() { return cGroup; }

		//"file"
		public Keyword getFileKeyword_0() { return cFileKeyword_0; }

		//name=MultiIdentifierName
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//MultiIdentifierName
		public RuleCall getNameMultiIdentifierNameParserRuleCall_1_0() { return cNameMultiIdentifierNameParserRuleCall_1_0; }

		//":"
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }

		//type=SubtypeIndication
		public Assignment getTypeAssignment_3() { return cTypeAssignment_3; }

		//SubtypeIndication
		public RuleCall getTypeSubtypeIndicationParserRuleCall_3_0() { return cTypeSubtypeIndicationParserRuleCall_3_0; }
	}

	public class FileTypeDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FileTypeDefinition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFileKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cOfKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTypeNameParserRuleCall_2_0 = (RuleCall)cTypeAssignment_2.eContents().get(0);
		
		//FileTypeDefinition returns type::FileTypeDefinition:
		//	"file" "of" type=Name;
		public ParserRule getRule() { return rule; }

		//"file" "of" type=Name
		public Group getGroup() { return cGroup; }

		//"file"
		public Keyword getFileKeyword_0() { return cFileKeyword_0; }

		//"of"
		public Keyword getOfKeyword_1() { return cOfKeyword_1; }

		//type=Name
		public Assignment getTypeAssignment_2() { return cTypeAssignment_2; }

		//Name
		public RuleCall getTypeNameParserRuleCall_2_0() { return cTypeNameParserRuleCall_2_0; }
	}

	public class GenerateStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "GenerateStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLabelAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLabelLabelParserRuleCall_0_0 = (RuleCall)cLabelAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cSchemeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cSchemeGenerationSchemeParserRuleCall_2_0 = (RuleCall)cSchemeAssignment_2.eContents().get(0);
		private final Keyword cGenerateKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Assignment cDeclarationAssignment_4_0 = (Assignment)cGroup_4.eContents().get(0);
		private final RuleCall cDeclarationBlockDeclarativeItemParserRuleCall_4_0_0 = (RuleCall)cDeclarationAssignment_4_0.eContents().get(0);
		private final Keyword cBeginKeyword_4_1 = (Keyword)cGroup_4.eContents().get(1);
		private final Assignment cStatementAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cStatementArchitectureStatementParserRuleCall_5_0 = (RuleCall)cStatementAssignment_5.eContents().get(0);
		private final Keyword cEndKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Keyword cGenerateKeyword_7 = (Keyword)cGroup.eContents().get(7);
		private final RuleCall cIdentifierParserRuleCall_8 = (RuleCall)cGroup.eContents().get(8);
		private final Keyword cSemicolonKeyword_9 = (Keyword)cGroup.eContents().get(9);
		
		/// *
		// * label: for variable in range generate    -- label required
		// *            block declarative items  \__ optional   
		// *         begin                       /
		// *            concurrent statements          -- using variable
		// *         end generate label ;
		// *
		// *  label: if condition generate            -- label required
		// *            block declarative items  \__ optional   
		// *         begin                       /
		// *            concurrent statements
		// *         end generate label ;
		// * / GenerateStatement returns statement::GenerateStatement:
		//	label=Label ":" scheme=GenerationScheme "generate" (declaration+=BlockDeclarativeItem* "begin")?
		//	statement+=ArchitectureStatement* "end" "generate" Identifier? ";";
		public ParserRule getRule() { return rule; }

		//label=Label ":" scheme=GenerationScheme "generate" (declaration+=BlockDeclarativeItem* "begin")?
		//statement+=ArchitectureStatement* "end" "generate" Identifier? ";"
		public Group getGroup() { return cGroup; }

		//label=Label
		public Assignment getLabelAssignment_0() { return cLabelAssignment_0; }

		//Label
		public RuleCall getLabelLabelParserRuleCall_0_0() { return cLabelLabelParserRuleCall_0_0; }

		//":"
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }

		//scheme=GenerationScheme
		public Assignment getSchemeAssignment_2() { return cSchemeAssignment_2; }

		//GenerationScheme
		public RuleCall getSchemeGenerationSchemeParserRuleCall_2_0() { return cSchemeGenerationSchemeParserRuleCall_2_0; }

		//"generate"
		public Keyword getGenerateKeyword_3() { return cGenerateKeyword_3; }

		//(declaration+=BlockDeclarativeItem* "begin")?
		public Group getGroup_4() { return cGroup_4; }

		//declaration+=BlockDeclarativeItem*
		public Assignment getDeclarationAssignment_4_0() { return cDeclarationAssignment_4_0; }

		//BlockDeclarativeItem
		public RuleCall getDeclarationBlockDeclarativeItemParserRuleCall_4_0_0() { return cDeclarationBlockDeclarativeItemParserRuleCall_4_0_0; }

		//"begin"
		public Keyword getBeginKeyword_4_1() { return cBeginKeyword_4_1; }

		//statement+=ArchitectureStatement*
		public Assignment getStatementAssignment_5() { return cStatementAssignment_5; }

		//ArchitectureStatement
		public RuleCall getStatementArchitectureStatementParserRuleCall_5_0() { return cStatementArchitectureStatementParserRuleCall_5_0; }

		//"end"
		public Keyword getEndKeyword_6() { return cEndKeyword_6; }

		//"generate"
		public Keyword getGenerateKeyword_7() { return cGenerateKeyword_7; }

		//Identifier?
		public RuleCall getIdentifierParserRuleCall_8() { return cIdentifierParserRuleCall_8; }

		//";"
		public Keyword getSemicolonKeyword_9() { return cSemicolonKeyword_9; }
	}

	public class GenerationSchemeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "GenerationScheme");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cForGenerationSchemeParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cIfGenerationSchemeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//GenerationScheme returns statement::GenerationScheme:
		//	ForGenerationScheme | IfGenerationScheme;
		public ParserRule getRule() { return rule; }

		//ForGenerationScheme | IfGenerationScheme
		public Alternatives getAlternatives() { return cAlternatives; }

		//ForGenerationScheme
		public RuleCall getForGenerationSchemeParserRuleCall_0() { return cForGenerationSchemeParserRuleCall_0; }

		//IfGenerationScheme
		public RuleCall getIfGenerationSchemeParserRuleCall_1() { return cIfGenerationSchemeParserRuleCall_1; }
	}

	public class ForGenerationSchemeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ForGenerationScheme");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cForKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cVariableAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cVariableIdentifierParserRuleCall_1_0 = (RuleCall)cVariableAssignment_1.eContents().get(0);
		private final Keyword cInKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cInAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cInDiscreteRangeParserRuleCall_3_0 = (RuleCall)cInAssignment_3.eContents().get(0);
		
		//ForGenerationScheme returns statement::ForGenerationScheme:
		//	"for" variable=Identifier "in" in=DiscreteRange;
		public ParserRule getRule() { return rule; }

		//"for" variable=Identifier "in" in=DiscreteRange
		public Group getGroup() { return cGroup; }

		//"for"
		public Keyword getForKeyword_0() { return cForKeyword_0; }

		//variable=Identifier
		public Assignment getVariableAssignment_1() { return cVariableAssignment_1; }

		//Identifier
		public RuleCall getVariableIdentifierParserRuleCall_1_0() { return cVariableIdentifierParserRuleCall_1_0; }

		//"in"
		public Keyword getInKeyword_2() { return cInKeyword_2; }

		//in=DiscreteRange
		public Assignment getInAssignment_3() { return cInAssignment_3; }

		//DiscreteRange
		public RuleCall getInDiscreteRangeParserRuleCall_3_0() { return cInDiscreteRangeParserRuleCall_3_0; }
	}

	public class IfGenerationSchemeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IfGenerationScheme");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIfKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cConditionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cConditionExpressionParserRuleCall_1_0 = (RuleCall)cConditionAssignment_1.eContents().get(0);
		
		//IfGenerationScheme returns statement::IfGenerationScheme:
		//	"if" condition=Expression;
		public ParserRule getRule() { return rule; }

		//"if" condition=Expression
		public Group getGroup() { return cGroup; }

		//"if"
		public Keyword getIfKeyword_0() { return cIfKeyword_0; }

		//condition=Expression
		public Assignment getConditionAssignment_1() { return cConditionAssignment_1; }

		//Expression
		public RuleCall getConditionExpressionParserRuleCall_1_0() { return cConditionExpressionParserRuleCall_1_0; }
	}

	public class GenericsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Generics");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cGenericKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cDeclarationAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cDeclarationGenericDeclarationParserRuleCall_2_0 = (RuleCall)cDeclarationAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cSemicolonKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cDeclarationAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cDeclarationGenericDeclarationParserRuleCall_3_1_0 = (RuleCall)cDeclarationAssignment_3_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cSemicolonKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//Generics:
		//	"generic" "(" declaration+=GenericDeclaration (";" declaration+=GenericDeclaration)* ")" ";";
		public ParserRule getRule() { return rule; }

		//"generic" "(" declaration+=GenericDeclaration (";" declaration+=GenericDeclaration)* ")" ";"
		public Group getGroup() { return cGroup; }

		//"generic"
		public Keyword getGenericKeyword_0() { return cGenericKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//declaration+=GenericDeclaration
		public Assignment getDeclarationAssignment_2() { return cDeclarationAssignment_2; }

		//GenericDeclaration
		public RuleCall getDeclarationGenericDeclarationParserRuleCall_2_0() { return cDeclarationGenericDeclarationParserRuleCall_2_0; }

		//(";" declaration+=GenericDeclaration)*
		public Group getGroup_3() { return cGroup_3; }

		//";"
		public Keyword getSemicolonKeyword_3_0() { return cSemicolonKeyword_3_0; }

		//declaration+=GenericDeclaration
		public Assignment getDeclarationAssignment_3_1() { return cDeclarationAssignment_3_1; }

		//GenericDeclaration
		public RuleCall getDeclarationGenericDeclarationParserRuleCall_3_1_0() { return cDeclarationGenericDeclarationParserRuleCall_3_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }

		//";"
		public Keyword getSemicolonKeyword_5() { return cSemicolonKeyword_5; }
	}

	public class GenericMapsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "GenericMaps");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cGenericKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cMapKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cGenericAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cGenericParameterParserRuleCall_3_0 = (RuleCall)cGenericAssignment_3.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cCommaKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cGenericAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cGenericParameterParserRuleCall_4_1_0 = (RuleCall)cGenericAssignment_4_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//GenericMaps:
		//	"generic" "map" "(" generic+=Parameter ("," generic+=Parameter)* ")";
		public ParserRule getRule() { return rule; }

		//"generic" "map" "(" generic+=Parameter ("," generic+=Parameter)* ")"
		public Group getGroup() { return cGroup; }

		//"generic"
		public Keyword getGenericKeyword_0() { return cGenericKeyword_0; }

		//"map"
		public Keyword getMapKeyword_1() { return cMapKeyword_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }

		//generic+=Parameter
		public Assignment getGenericAssignment_3() { return cGenericAssignment_3; }

		//Parameter
		public RuleCall getGenericParameterParserRuleCall_3_0() { return cGenericParameterParserRuleCall_3_0; }

		//("," generic+=Parameter)*
		public Group getGroup_4() { return cGroup_4; }

		//","
		public Keyword getCommaKeyword_4_0() { return cCommaKeyword_4_0; }

		//generic+=Parameter
		public Assignment getGenericAssignment_4_1() { return cGenericAssignment_4_1; }

		//Parameter
		public RuleCall getGenericParameterParserRuleCall_4_1_0() { return cGenericParameterParserRuleCall_4_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }
	}

	public class GroupDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "GroupDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cGroupKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIdentifierNameParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cIsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cIsNameParserRuleCall_3_0 = (RuleCall)cIsAssignment_3.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cMemberAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cMemberGroupConstituentsParserRuleCall_5_0 = (RuleCall)cMemberAssignment_5.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Keyword cSemicolonKeyword_7 = (Keyword)cGroup.eContents().get(7);
		
		/// *
		// * group identifier : group_template_name ( group_member [, group member] ) ;
		// * / GroupDeclaration returns declaration::GroupDeclaration:
		//	"group" name=IdentifierName ":" is=Name "(" member=GroupConstituents ")" ";";
		public ParserRule getRule() { return rule; }

		//"group" name=IdentifierName ":" is=Name "(" member=GroupConstituents ")" ";"
		public Group getGroup() { return cGroup; }

		//"group"
		public Keyword getGroupKeyword_0() { return cGroupKeyword_0; }

		//name=IdentifierName
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//IdentifierName
		public RuleCall getNameIdentifierNameParserRuleCall_1_0() { return cNameIdentifierNameParserRuleCall_1_0; }

		//":"
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }

		//is=Name
		public Assignment getIsAssignment_3() { return cIsAssignment_3; }

		//Name
		public RuleCall getIsNameParserRuleCall_3_0() { return cIsNameParserRuleCall_3_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_4() { return cLeftParenthesisKeyword_4; }

		//member=GroupConstituents
		public Assignment getMemberAssignment_5() { return cMemberAssignment_5; }

		//GroupConstituents
		public RuleCall getMemberGroupConstituentsParserRuleCall_5_0() { return cMemberGroupConstituentsParserRuleCall_5_0; }

		//")"
		public Keyword getRightParenthesisKeyword_6() { return cRightParenthesisKeyword_6; }

		//";"
		public Keyword getSemicolonKeyword_7() { return cSemicolonKeyword_7; }
	}

	public class GroupConstituentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "GroupConstituent");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cNameParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cCharacterNameParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//GroupConstituent returns Name:
		//	Name | CharacterName;
		public ParserRule getRule() { return rule; }

		//Name | CharacterName
		public Alternatives getAlternatives() { return cAlternatives; }

		//Name
		public RuleCall getNameParserRuleCall_0() { return cNameParserRuleCall_0; }

		//CharacterName
		public RuleCall getCharacterNameParserRuleCall_1() { return cCharacterNameParserRuleCall_1; }
	}

	public class GroupConstituentsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "GroupConstituents");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cGroupConstituentParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cNameListNameAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cGroup_1.eContents().get(1);
		private final Keyword cCommaKeyword_1_1_0 = (Keyword)cGroup_1_1.eContents().get(0);
		private final Assignment cNameAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cNameGroupConstituentParserRuleCall_1_1_1_0 = (RuleCall)cNameAssignment_1_1_1.eContents().get(0);
		
		//GroupConstituents returns MultiName:
		//	GroupConstituent ({NameList.name+=current} ("," name+=GroupConstituent)+)?;
		public ParserRule getRule() { return rule; }

		//GroupConstituent ({NameList.name+=current} ("," name+=GroupConstituent)+)?
		public Group getGroup() { return cGroup; }

		//GroupConstituent
		public RuleCall getGroupConstituentParserRuleCall_0() { return cGroupConstituentParserRuleCall_0; }

		//({NameList.name+=current} ("," name+=GroupConstituent)+)?
		public Group getGroup_1() { return cGroup_1; }

		//{NameList.name+=current}
		public Action getNameListNameAction_1_0() { return cNameListNameAction_1_0; }

		//("," name+=GroupConstituent)+
		public Group getGroup_1_1() { return cGroup_1_1; }

		//","
		public Keyword getCommaKeyword_1_1_0() { return cCommaKeyword_1_1_0; }

		//name+=GroupConstituent
		public Assignment getNameAssignment_1_1_1() { return cNameAssignment_1_1_1; }

		//GroupConstituent
		public RuleCall getNameGroupConstituentParserRuleCall_1_1_1_0() { return cNameGroupConstituentParserRuleCall_1_1_1_0; }
	}

	public class GroupTemplateDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "GroupTemplateDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cGroupKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIdentifierNameParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cIsKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cEntryAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cEntryEntityClassEnumRuleCall_4_0 = (RuleCall)cEntryAssignment_4.eContents().get(0);
		private final Keyword cLessThanSignGreaterThanSignKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Group cGroup_6 = (Group)cGroup.eContents().get(6);
		private final Keyword cCommaKeyword_6_0 = (Keyword)cGroup_6.eContents().get(0);
		private final Assignment cEntryAssignment_6_1 = (Assignment)cGroup_6.eContents().get(1);
		private final RuleCall cEntryEntityClassEnumRuleCall_6_1_0 = (RuleCall)cEntryAssignment_6_1.eContents().get(0);
		private final Keyword cLessThanSignGreaterThanSignKeyword_6_2 = (Keyword)cGroup_6.eContents().get(2);
		private final Keyword cRightParenthesisKeyword_7 = (Keyword)cGroup.eContents().get(7);
		private final Keyword cSemicolonKeyword_8 = (Keyword)cGroup.eContents().get(8);
		
		//GroupTemplateDeclaration returns declaration::GroupTemplateDeclaration:
		//	"group" name=IdentifierName "is" "(" entry+=EntityClass "<>"? ("," entry+=EntityClass "<>"?)* ")" ";";
		public ParserRule getRule() { return rule; }

		//"group" name=IdentifierName "is" "(" entry+=EntityClass "<>"? ("," entry+=EntityClass "<>"?)* ")" ";"
		public Group getGroup() { return cGroup; }

		//"group"
		public Keyword getGroupKeyword_0() { return cGroupKeyword_0; }

		//name=IdentifierName
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//IdentifierName
		public RuleCall getNameIdentifierNameParserRuleCall_1_0() { return cNameIdentifierNameParserRuleCall_1_0; }

		//"is"
		public Keyword getIsKeyword_2() { return cIsKeyword_2; }

		//"("
		public Keyword getLeftParenthesisKeyword_3() { return cLeftParenthesisKeyword_3; }

		//entry+=EntityClass
		public Assignment getEntryAssignment_4() { return cEntryAssignment_4; }

		//EntityClass
		public RuleCall getEntryEntityClassEnumRuleCall_4_0() { return cEntryEntityClassEnumRuleCall_4_0; }

		//"<>"?
		public Keyword getLessThanSignGreaterThanSignKeyword_5() { return cLessThanSignGreaterThanSignKeyword_5; }

		//("," entry+=EntityClass "<>"?)*
		public Group getGroup_6() { return cGroup_6; }

		//","
		public Keyword getCommaKeyword_6_0() { return cCommaKeyword_6_0; }

		//entry+=EntityClass
		public Assignment getEntryAssignment_6_1() { return cEntryAssignment_6_1; }

		//EntityClass
		public RuleCall getEntryEntityClassEnumRuleCall_6_1_0() { return cEntryEntityClassEnumRuleCall_6_1_0; }

		//"<>"?
		public Keyword getLessThanSignGreaterThanSignKeyword_6_2() { return cLessThanSignGreaterThanSignKeyword_6_2; }

		//")"
		public Keyword getRightParenthesisKeyword_7() { return cRightParenthesisKeyword_7; }

		//";"
		public Keyword getSemicolonKeyword_8() { return cSemicolonKeyword_8; }
	}

	public class IfStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IfStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cGroup.eContents().get(0);
		private final Assignment cLabelAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final RuleCall cLabelLabelParserRuleCall_0_0_0 = (RuleCall)cLabelAssignment_0_0.eContents().get(0);
		private final Keyword cColonKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Keyword cIfKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTestAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTestIfStatementTestParserRuleCall_2_0 = (RuleCall)cTestAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cElsifKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cTestAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cTestIfStatementTestParserRuleCall_3_1_0 = (RuleCall)cTestAssignment_3_1.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cElseKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cStatementAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cStatementSequentialStatementParserRuleCall_4_1_0 = (RuleCall)cStatementAssignment_4_1.eContents().get(0);
		private final Keyword cEndKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Keyword cIfKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final RuleCall cIdentifierParserRuleCall_7 = (RuleCall)cGroup.eContents().get(7);
		private final Keyword cSemicolonKeyword_8 = (Keyword)cGroup.eContents().get(8);
		
		/// *
		// * [ label: ] if  condition1  then
		// *                 sequence-of-statements
		// *             elsif  condition2  then      \_ optional
		// *                  sequence-of-statements  /
		// *             elsif  condition3  then      \_ optional
		// *                  sequence-of-statements  /
		// *             ...
		// * 
		// *             else                         \_ optional
		// *                  sequence-of-statements  /
		// *             end if [ label ] ;
		// * / IfStatement returns statement::IfStatement:
		//	(label=Label ":")? "if" test+=IfStatementTest ("elsif" test+=IfStatementTest)* ("else"
		//	statement+=SequentialStatement*)? "end" "if" Identifier? ";";
		public ParserRule getRule() { return rule; }

		//(label=Label ":")? "if" test+=IfStatementTest ("elsif" test+=IfStatementTest)* ("else" statement+=SequentialStatement*)?
		//"end" "if" Identifier? ";"
		public Group getGroup() { return cGroup; }

		//(label=Label ":")?
		public Group getGroup_0() { return cGroup_0; }

		//label=Label
		public Assignment getLabelAssignment_0_0() { return cLabelAssignment_0_0; }

		//Label
		public RuleCall getLabelLabelParserRuleCall_0_0_0() { return cLabelLabelParserRuleCall_0_0_0; }

		//":"
		public Keyword getColonKeyword_0_1() { return cColonKeyword_0_1; }

		//"if"
		public Keyword getIfKeyword_1() { return cIfKeyword_1; }

		//test+=IfStatementTest
		public Assignment getTestAssignment_2() { return cTestAssignment_2; }

		//IfStatementTest
		public RuleCall getTestIfStatementTestParserRuleCall_2_0() { return cTestIfStatementTestParserRuleCall_2_0; }

		//("elsif" test+=IfStatementTest)*
		public Group getGroup_3() { return cGroup_3; }

		//"elsif"
		public Keyword getElsifKeyword_3_0() { return cElsifKeyword_3_0; }

		//test+=IfStatementTest
		public Assignment getTestAssignment_3_1() { return cTestAssignment_3_1; }

		//IfStatementTest
		public RuleCall getTestIfStatementTestParserRuleCall_3_1_0() { return cTestIfStatementTestParserRuleCall_3_1_0; }

		//("else" statement+=SequentialStatement*)?
		public Group getGroup_4() { return cGroup_4; }

		//"else"
		public Keyword getElseKeyword_4_0() { return cElseKeyword_4_0; }

		//statement+=SequentialStatement*
		public Assignment getStatementAssignment_4_1() { return cStatementAssignment_4_1; }

		//SequentialStatement
		public RuleCall getStatementSequentialStatementParserRuleCall_4_1_0() { return cStatementSequentialStatementParserRuleCall_4_1_0; }

		//"end"
		public Keyword getEndKeyword_5() { return cEndKeyword_5; }

		//"if"
		public Keyword getIfKeyword_6() { return cIfKeyword_6; }

		//Identifier?
		public RuleCall getIdentifierParserRuleCall_7() { return cIdentifierParserRuleCall_7; }

		//";"
		public Keyword getSemicolonKeyword_8() { return cSemicolonKeyword_8; }
	}

	public class IfStatementTestElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IfStatementTest");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cConditionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cConditionExpressionParserRuleCall_0_0 = (RuleCall)cConditionAssignment_0.eContents().get(0);
		private final Keyword cThenKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cStatementAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cStatementSequentialStatementParserRuleCall_2_0 = (RuleCall)cStatementAssignment_2.eContents().get(0);
		
		//IfStatementTest returns statement::IfStatementTest:
		//	condition=Expression "then" statement+=SequentialStatement*;
		public ParserRule getRule() { return rule; }

		//condition=Expression "then" statement+=SequentialStatement*
		public Group getGroup() { return cGroup; }

		//condition=Expression
		public Assignment getConditionAssignment_0() { return cConditionAssignment_0; }

		//Expression
		public RuleCall getConditionExpressionParserRuleCall_0_0() { return cConditionExpressionParserRuleCall_0_0; }

		//"then"
		public Keyword getThenKeyword_1() { return cThenKeyword_1; }

		//statement+=SequentialStatement*
		public Assignment getStatementAssignment_2() { return cStatementAssignment_2; }

		//SequentialStatement
		public RuleCall getStatementSequentialStatementParserRuleCall_2_0() { return cStatementSequentialStatementParserRuleCall_2_0; }
	}

	public class ConstraintElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Constraint");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cRangeConstraintParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cIndexConstraintParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Constraint returns expression::Expression:
		//	RangeConstraint | IndexConstraint;
		public ParserRule getRule() { return rule; }

		//RangeConstraint | IndexConstraint
		public Alternatives getAlternatives() { return cAlternatives; }

		//RangeConstraint
		public RuleCall getRangeConstraintParserRuleCall_0() { return cRangeConstraintParserRuleCall_0; }

		//IndexConstraint
		public RuleCall getIndexConstraintParserRuleCall_1() { return cIndexConstraintParserRuleCall_1; }
	}

	public class RangeConstraintElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RangeConstraint");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cRangeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cRangeParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//RangeConstraint returns expression::Expression:
		//	"range" Range;
		public ParserRule getRule() { return rule; }

		//"range" Range
		public Group getGroup() { return cGroup; }

		//"range"
		public Keyword getRangeKeyword_0() { return cRangeKeyword_0; }

		//Range
		public RuleCall getRangeParserRuleCall_1() { return cRangeParserRuleCall_1; }
	}

	public class IndexConstraintElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IndexConstraint");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cDiscreteRangeParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Action cMultiExpressionExpressionAction_2_0 = (Action)cGroup_2.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cExpressionAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cExpressionDiscreteRangeParserRuleCall_2_1_1_0 = (RuleCall)cExpressionAssignment_2_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//IndexConstraint returns expression::Expression:
		//	"(" DiscreteRange ({expression::MultiExpression.expression+=current} ("," expression+=DiscreteRange)+)? ")";
		public ParserRule getRule() { return rule; }

		//"(" DiscreteRange ({expression::MultiExpression.expression+=current} ("," expression+=DiscreteRange)+)? ")"
		public Group getGroup() { return cGroup; }

		//"("
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }

		//DiscreteRange
		public RuleCall getDiscreteRangeParserRuleCall_1() { return cDiscreteRangeParserRuleCall_1; }

		//({expression::MultiExpression.expression+=current} ("," expression+=DiscreteRange)+)?
		public Group getGroup_2() { return cGroup_2; }

		//{expression::MultiExpression.expression+=current}
		public Action getMultiExpressionExpressionAction_2_0() { return cMultiExpressionExpressionAction_2_0; }

		//("," expression+=DiscreteRange)+
		public Group getGroup_2_1() { return cGroup_2_1; }

		//","
		public Keyword getCommaKeyword_2_1_0() { return cCommaKeyword_2_1_0; }

		//expression+=DiscreteRange
		public Assignment getExpressionAssignment_2_1_1() { return cExpressionAssignment_2_1_1; }

		//DiscreteRange
		public RuleCall getExpressionDiscreteRangeParserRuleCall_2_1_1_0() { return cExpressionDiscreteRangeParserRuleCall_2_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}

	public class GenericDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "GenericDeclaration");
		private final RuleCall cInterfaceConstantDeclarationParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//GenericDeclaration returns declaration::Declaration:
		//	InterfaceConstantDeclaration;
		public ParserRule getRule() { return rule; }

		//InterfaceConstantDeclaration
		public RuleCall getInterfaceConstantDeclarationParserRuleCall() { return cInterfaceConstantDeclarationParserRuleCall; }
	}

	public class PortDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PortDeclaration");
		private final RuleCall cInterfaceSignalDeclarationParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//PortDeclaration returns declaration::Declaration:
		//	InterfaceSignalDeclaration;
		public ParserRule getRule() { return rule; }

		//InterfaceSignalDeclaration
		public RuleCall getInterfaceSignalDeclarationParserRuleCall() { return cInterfaceSignalDeclarationParserRuleCall; }
	}

	public class FunctionParameterDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FunctionParameterDeclaration");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cInterfaceConstantDeclarationParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cInterfaceSignalDeclarationParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cInterfaceVariableDeclarationParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cInterfaceFileDeclarationParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//FunctionParameterDeclaration returns declaration::Declaration:
		//	InterfaceConstantDeclaration | InterfaceSignalDeclaration | InterfaceVariableDeclaration | InterfaceFileDeclaration;
		public ParserRule getRule() { return rule; }

		//InterfaceConstantDeclaration | InterfaceSignalDeclaration | InterfaceVariableDeclaration | InterfaceFileDeclaration
		public Alternatives getAlternatives() { return cAlternatives; }

		//InterfaceConstantDeclaration
		public RuleCall getInterfaceConstantDeclarationParserRuleCall_0() { return cInterfaceConstantDeclarationParserRuleCall_0; }

		//InterfaceSignalDeclaration
		public RuleCall getInterfaceSignalDeclarationParserRuleCall_1() { return cInterfaceSignalDeclarationParserRuleCall_1; }

		//InterfaceVariableDeclaration
		public RuleCall getInterfaceVariableDeclarationParserRuleCall_2() { return cInterfaceVariableDeclarationParserRuleCall_2; }

		//InterfaceFileDeclaration
		public RuleCall getInterfaceFileDeclarationParserRuleCall_3() { return cInterfaceFileDeclarationParserRuleCall_3; }
	}

	public class ProcedureParameterDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ProcedureParameterDeclaration");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cInterfaceVariableDeclarationParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cInterfaceSignalDeclarationParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cInterfaceConstantDeclarationParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cInterfaceFileDeclarationParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//ProcedureParameterDeclaration returns declaration::Declaration:
		//	InterfaceVariableDeclaration | InterfaceSignalDeclaration | InterfaceConstantDeclaration | InterfaceFileDeclaration;
		public ParserRule getRule() { return rule; }

		//InterfaceVariableDeclaration | InterfaceSignalDeclaration | InterfaceConstantDeclaration | InterfaceFileDeclaration
		public Alternatives getAlternatives() { return cAlternatives; }

		//InterfaceVariableDeclaration
		public RuleCall getInterfaceVariableDeclarationParserRuleCall_0() { return cInterfaceVariableDeclarationParserRuleCall_0; }

		//InterfaceSignalDeclaration
		public RuleCall getInterfaceSignalDeclarationParserRuleCall_1() { return cInterfaceSignalDeclarationParserRuleCall_1; }

		//InterfaceConstantDeclaration
		public RuleCall getInterfaceConstantDeclarationParserRuleCall_2() { return cInterfaceConstantDeclarationParserRuleCall_2; }

		//InterfaceFileDeclaration
		public RuleCall getInterfaceFileDeclarationParserRuleCall_3() { return cInterfaceFileDeclarationParserRuleCall_3; }
	}

	public class LoopStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LoopStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cLoopStatementAction_0 = (Action)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cLabelAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cLabelLabelParserRuleCall_1_0_0 = (RuleCall)cLabelAssignment_1_0.eContents().get(0);
		private final Keyword cColonKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cIterationAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cIterationIterationSchemeParserRuleCall_2_0 = (RuleCall)cIterationAssignment_2.eContents().get(0);
		private final Keyword cLoopKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cStatementAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cStatementSequentialStatementParserRuleCall_4_0 = (RuleCall)cStatementAssignment_4.eContents().get(0);
		private final Keyword cEndKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Keyword cLoopKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final RuleCall cIdentifierParserRuleCall_7 = (RuleCall)cGroup.eContents().get(7);
		private final Keyword cSemicolonKeyword_8 = (Keyword)cGroup.eContents().get(8);
		
		/// *
		// * [ label: ] loop
		// *                  sequence-of-statements -- use exit statement to get out
		// *             end loop [ label ] ;
		// * 
		// *  [ label: ] for variable in range loop
		// *                  sequence-of-statements
		// *             end loop [ label ] ;
		// * 
		// *  [ label: ] while  condition  loop
		// *                  sequence-of-statements
		// *             end loop [ label ] ;
		// * / LoopStatement returns statement::LoopStatement:
		//	{statement::LoopStatement} (label=Label ":")? iteration=IterationScheme? "loop" statement+=SequentialStatement* "end"
		//	"loop" Identifier? ";";
		public ParserRule getRule() { return rule; }

		//{statement::LoopStatement} (label=Label ":")? iteration=IterationScheme? "loop" statement+=SequentialStatement* "end"
		//"loop" Identifier? ";"
		public Group getGroup() { return cGroup; }

		//{statement::LoopStatement}
		public Action getLoopStatementAction_0() { return cLoopStatementAction_0; }

		//(label=Label ":")?
		public Group getGroup_1() { return cGroup_1; }

		//label=Label
		public Assignment getLabelAssignment_1_0() { return cLabelAssignment_1_0; }

		//Label
		public RuleCall getLabelLabelParserRuleCall_1_0_0() { return cLabelLabelParserRuleCall_1_0_0; }

		//":"
		public Keyword getColonKeyword_1_1() { return cColonKeyword_1_1; }

		//iteration=IterationScheme?
		public Assignment getIterationAssignment_2() { return cIterationAssignment_2; }

		//IterationScheme
		public RuleCall getIterationIterationSchemeParserRuleCall_2_0() { return cIterationIterationSchemeParserRuleCall_2_0; }

		//"loop"
		public Keyword getLoopKeyword_3() { return cLoopKeyword_3; }

		//statement+=SequentialStatement*
		public Assignment getStatementAssignment_4() { return cStatementAssignment_4; }

		//SequentialStatement
		public RuleCall getStatementSequentialStatementParserRuleCall_4_0() { return cStatementSequentialStatementParserRuleCall_4_0; }

		//"end"
		public Keyword getEndKeyword_5() { return cEndKeyword_5; }

		//"loop"
		public Keyword getLoopKeyword_6() { return cLoopKeyword_6; }

		//Identifier?
		public RuleCall getIdentifierParserRuleCall_7() { return cIdentifierParserRuleCall_7; }

		//";"
		public Keyword getSemicolonKeyword_8() { return cSemicolonKeyword_8; }
	}

	public class IterationSchemeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IterationScheme");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cWhileIterationSchemeParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cForIterationSchemeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//IterationScheme returns statement::IterationScheme:
		//	WhileIterationScheme | ForIterationScheme;
		public ParserRule getRule() { return rule; }

		//WhileIterationScheme | ForIterationScheme
		public Alternatives getAlternatives() { return cAlternatives; }

		//WhileIterationScheme
		public RuleCall getWhileIterationSchemeParserRuleCall_0() { return cWhileIterationSchemeParserRuleCall_0; }

		//ForIterationScheme
		public RuleCall getForIterationSchemeParserRuleCall_1() { return cForIterationSchemeParserRuleCall_1; }
	}

	public class WhileIterationSchemeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "WhileIterationScheme");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cWhileKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cConditionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cConditionExpressionParserRuleCall_1_0 = (RuleCall)cConditionAssignment_1.eContents().get(0);
		
		//WhileIterationScheme returns statement::WhileIterationScheme:
		//	"while" condition=Expression;
		public ParserRule getRule() { return rule; }

		//"while" condition=Expression
		public Group getGroup() { return cGroup; }

		//"while"
		public Keyword getWhileKeyword_0() { return cWhileKeyword_0; }

		//condition=Expression
		public Assignment getConditionAssignment_1() { return cConditionAssignment_1; }

		//Expression
		public RuleCall getConditionExpressionParserRuleCall_1_0() { return cConditionExpressionParserRuleCall_1_0; }
	}

	public class ForIterationSchemeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ForIterationScheme");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cForKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cVariableAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cVariableIdentifierParserRuleCall_1_0 = (RuleCall)cVariableAssignment_1.eContents().get(0);
		private final Keyword cInKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cInAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cInDiscreteRangeParserRuleCall_3_0 = (RuleCall)cInAssignment_3.eContents().get(0);
		
		//ForIterationScheme returns statement::ForIterationScheme:
		//	"for" variable=Identifier "in" in=DiscreteRange;
		public ParserRule getRule() { return rule; }

		//"for" variable=Identifier "in" in=DiscreteRange
		public Group getGroup() { return cGroup; }

		//"for"
		public Keyword getForKeyword_0() { return cForKeyword_0; }

		//variable=Identifier
		public Assignment getVariableAssignment_1() { return cVariableAssignment_1; }

		//Identifier
		public RuleCall getVariableIdentifierParserRuleCall_1_0() { return cVariableIdentifierParserRuleCall_1_0; }

		//"in"
		public Keyword getInKeyword_2() { return cInKeyword_2; }

		//in=DiscreteRange
		public Assignment getInAssignment_3() { return cInAssignment_3; }

		//DiscreteRange
		public RuleCall getInDiscreteRangeParserRuleCall_3_0() { return cInDiscreteRangeParserRuleCall_3_0; }
	}

	public class NameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Name");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cNamePrefixParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cNameExpressionElementAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cElementAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cElementNameSuffixParserRuleCall_1_1_0 = (RuleCall)cElementAssignment_1_1.eContents().get(0);
		
		//Name:
		//	NamePrefix ({expression::NameExpression.element+=current} element+=NameSuffix+)?;
		public ParserRule getRule() { return rule; }

		//NamePrefix ({expression::NameExpression.element+=current} element+=NameSuffix+)?
		public Group getGroup() { return cGroup; }

		//NamePrefix
		public RuleCall getNamePrefixParserRuleCall_0() { return cNamePrefixParserRuleCall_0; }

		//({expression::NameExpression.element+=current} element+=NameSuffix+)?
		public Group getGroup_1() { return cGroup_1; }

		//{expression::NameExpression.element+=current}
		public Action getNameExpressionElementAction_1_0() { return cNameExpressionElementAction_1_0; }

		//element+=NameSuffix+
		public Assignment getElementAssignment_1_1() { return cElementAssignment_1_1; }

		//NameSuffix
		public RuleCall getElementNameSuffixParserRuleCall_1_1_0() { return cElementNameSuffixParserRuleCall_1_1_0; }
	}

	public class NameExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NameExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cNameExpressionAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Assignment cElementAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cElementNamePrefixParserRuleCall_0_1_0 = (RuleCall)cElementAssignment_0_1.eContents().get(0);
		private final Assignment cElementAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cElementNameSuffixParserRuleCall_0_2_0 = (RuleCall)cElementAssignment_0_2.eContents().get(0);
		private final RuleCall cNamePrefixExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//NameExpression returns expression::Expression:
		//	{expression::NameExpression} element+=NamePrefix element+=NameSuffix+ | NamePrefixExpression;
		public ParserRule getRule() { return rule; }

		//{expression::NameExpression} element+=NamePrefix element+=NameSuffix+ | NamePrefixExpression
		public Alternatives getAlternatives() { return cAlternatives; }

		//{expression::NameExpression} element+=NamePrefix element+=NameSuffix+
		public Group getGroup_0() { return cGroup_0; }

		//{expression::NameExpression}
		public Action getNameExpressionAction_0_0() { return cNameExpressionAction_0_0; }

		//element+=NamePrefix
		public Assignment getElementAssignment_0_1() { return cElementAssignment_0_1; }

		//NamePrefix
		public RuleCall getElementNamePrefixParserRuleCall_0_1_0() { return cElementNamePrefixParserRuleCall_0_1_0; }

		//element+=NameSuffix+
		public Assignment getElementAssignment_0_2() { return cElementAssignment_0_2; }

		//NameSuffix
		public RuleCall getElementNameSuffixParserRuleCall_0_2_0() { return cElementNameSuffixParserRuleCall_0_2_0; }

		//NamePrefixExpression
		public RuleCall getNamePrefixExpressionParserRuleCall_1() { return cNamePrefixExpressionParserRuleCall_1; }
	}

	public class NamePrefixElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NamePrefix");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIdentifierNameParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cStringNameParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cAllParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cOthersParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//NamePrefix returns Name:
		//	IdentifierName | StringName | All | Others;
		public ParserRule getRule() { return rule; }

		//IdentifierName | StringName | All | Others
		public Alternatives getAlternatives() { return cAlternatives; }

		//IdentifierName
		public RuleCall getIdentifierNameParserRuleCall_0() { return cIdentifierNameParserRuleCall_0; }

		//StringName
		public RuleCall getStringNameParserRuleCall_1() { return cStringNameParserRuleCall_1; }

		//All
		public RuleCall getAllParserRuleCall_2() { return cAllParserRuleCall_2; }

		//Others
		public RuleCall getOthersParserRuleCall_3() { return cOthersParserRuleCall_3; }
	}

	public class NamePrefixExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NamePrefixExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIdentifierNameParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cStringNameParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cAllParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cOthersParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//NamePrefixExpression returns expression::Expression:
		//	IdentifierName | StringName | All | Others;
		public ParserRule getRule() { return rule; }

		//IdentifierName | StringName | All | Others
		public Alternatives getAlternatives() { return cAlternatives; }

		//IdentifierName
		public RuleCall getIdentifierNameParserRuleCall_0() { return cIdentifierNameParserRuleCall_0; }

		//StringName
		public RuleCall getStringNameParserRuleCall_1() { return cStringNameParserRuleCall_1; }

		//All
		public RuleCall getAllParserRuleCall_2() { return cAllParserRuleCall_2; }

		//Others
		public RuleCall getOthersParserRuleCall_3() { return cOthersParserRuleCall_3; }
	}

	public class NameSuffixElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NameSuffix");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSelectedNameParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cAttributeNameParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cAggregateParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cSliceNameParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		/// * 
		// * prefixed operator:
		// *   SelectedName: prefix = Prefix '.' suffix = Suffix
		// *   AttributeName: prefix = Prefix (signature = Signature )? '\'' AttributeDesignator ( '(' expression = Expression ')' )?	
		// *   IndexedName: prefix = Prefix '(' index += Expression ( ',' index += Expression )* ')'
		// *   SliceName: prefix = Prefix '(' range = DiscreteRange ')'
		// * / NameSuffix returns Name:
		//	SelectedName | AttributeName | Aggregate | SliceName;
		public ParserRule getRule() { return rule; }

		//SelectedName | AttributeName | Aggregate | SliceName
		public Alternatives getAlternatives() { return cAlternatives; }

		//SelectedName
		public RuleCall getSelectedNameParserRuleCall_0() { return cSelectedNameParserRuleCall_0; }

		//AttributeName
		public RuleCall getAttributeNameParserRuleCall_1() { return cAttributeNameParserRuleCall_1; }

		//Aggregate
		public RuleCall getAggregateParserRuleCall_2() { return cAggregateParserRuleCall_2; }

		//SliceName
		public RuleCall getSliceNameParserRuleCall_3() { return cSliceNameParserRuleCall_3; }
	}

	public class StringNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "StringName");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cStringExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueSTRINGTerminalRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		
		//StringName returns expression::StringExpression:
		//	{expression::StringExpression} value=STRING;
		public ParserRule getRule() { return rule; }

		//{expression::StringExpression} value=STRING
		public Group getGroup() { return cGroup; }

		//{expression::StringExpression}
		public Action getStringExpressionAction_0() { return cStringExpressionAction_0; }

		//value=STRING
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }

		//STRING
		public RuleCall getValueSTRINGTerminalRuleCall_1_0() { return cValueSTRINGTerminalRuleCall_1_0; }
	}

	public class CharacterNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CharacterName");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cCharacterExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueCHARTerminalRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		
		//CharacterName returns expression::CharacterExpression:
		//	{expression::CharacterExpression} value=CHAR;
		public ParserRule getRule() { return rule; }

		//{expression::CharacterExpression} value=CHAR
		public Group getGroup() { return cGroup; }

		//{expression::CharacterExpression}
		public Action getCharacterExpressionAction_0() { return cCharacterExpressionAction_0; }

		//value=CHAR
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }

		//CHAR
		public RuleCall getValueCHARTerminalRuleCall_1_0() { return cValueCHARTerminalRuleCall_1_0; }
	}

	public class IdentifierNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IdentifierName");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cIdentifierExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueIdentifierParserRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		
		//IdentifierName returns expression::IdentifierExpression:
		//	{expression::IdentifierExpression} value=Identifier;
		public ParserRule getRule() { return rule; }

		//{expression::IdentifierExpression} value=Identifier
		public Group getGroup() { return cGroup; }

		//{expression::IdentifierExpression}
		public Action getIdentifierExpressionAction_0() { return cIdentifierExpressionAction_0; }

		//value=Identifier
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }

		//Identifier
		public RuleCall getValueIdentifierParserRuleCall_1_0() { return cValueIdentifierParserRuleCall_1_0; }
	}

	public class SelectedNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SelectedName");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFullStopKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final RuleCall cIdentifierNameParserRuleCall_1_0 = (RuleCall)cAlternatives_1.eContents().get(0);
		private final RuleCall cCharacterNameParserRuleCall_1_1 = (RuleCall)cAlternatives_1.eContents().get(1);
		private final RuleCall cStringNameParserRuleCall_1_2 = (RuleCall)cAlternatives_1.eContents().get(2);
		private final RuleCall cAllParserRuleCall_1_3 = (RuleCall)cAlternatives_1.eContents().get(3);
		
		//SelectedName returns Name:
		//	"." (IdentifierName | CharacterName | StringName | All);
		public ParserRule getRule() { return rule; }

		//"." (IdentifierName | CharacterName | StringName | All)
		public Group getGroup() { return cGroup; }

		//"."
		public Keyword getFullStopKeyword_0() { return cFullStopKeyword_0; }

		//IdentifierName | CharacterName | StringName | All
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//IdentifierName
		public RuleCall getIdentifierNameParserRuleCall_1_0() { return cIdentifierNameParserRuleCall_1_0; }

		//CharacterName
		public RuleCall getCharacterNameParserRuleCall_1_1() { return cCharacterNameParserRuleCall_1_1; }

		//StringName
		public RuleCall getStringNameParserRuleCall_1_2() { return cStringNameParserRuleCall_1_2; }

		//All
		public RuleCall getAllParserRuleCall_1_3() { return cAllParserRuleCall_1_3; }
	}

	public class AttributeNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AttributeName");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cAttributeExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cSignatureAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cSignatureSignatureParserRuleCall_1_0 = (RuleCall)cSignatureAssignment_1.eContents().get(0);
		private final Assignment cValueAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValueATTRIBUTETerminalRuleCall_2_0 = (RuleCall)cValueAssignment_2.eContents().get(0);
		
		//AttributeName returns expression::AttributeExpression:
		//	{expression::AttributeExpression} signature=Signature? value=ATTRIBUTE;
		public ParserRule getRule() { return rule; }

		//{expression::AttributeExpression} signature=Signature? value=ATTRIBUTE
		public Group getGroup() { return cGroup; }

		//{expression::AttributeExpression}
		public Action getAttributeExpressionAction_0() { return cAttributeExpressionAction_0; }

		//signature=Signature?
		public Assignment getSignatureAssignment_1() { return cSignatureAssignment_1; }

		//Signature
		public RuleCall getSignatureSignatureParserRuleCall_1_0() { return cSignatureSignatureParserRuleCall_1_0; }

		//value=ATTRIBUTE
		public Assignment getValueAssignment_2() { return cValueAssignment_2; }

		//ATTRIBUTE
		public RuleCall getValueATTRIBUTETerminalRuleCall_2_0() { return cValueATTRIBUTETerminalRuleCall_2_0; }
	}

	public class NatureDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NatureDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cNatureKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIdentifierNameParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cIsKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cIsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cIsNatureDefinitionParserRuleCall_3_0 = (RuleCall)cIsAssignment_3.eContents().get(0);
		private final Keyword cSemicolonKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//NatureDeclaration returns declaration::NatureDeclaration:
		//	"nature" name=IdentifierName "is" is=NatureDefinition ";";
		public ParserRule getRule() { return rule; }

		//"nature" name=IdentifierName "is" is=NatureDefinition ";"
		public Group getGroup() { return cGroup; }

		//"nature"
		public Keyword getNatureKeyword_0() { return cNatureKeyword_0; }

		//name=IdentifierName
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//IdentifierName
		public RuleCall getNameIdentifierNameParserRuleCall_1_0() { return cNameIdentifierNameParserRuleCall_1_0; }

		//"is"
		public Keyword getIsKeyword_2() { return cIsKeyword_2; }

		//is=NatureDefinition
		public Assignment getIsAssignment_3() { return cIsAssignment_3; }

		//NatureDefinition
		public RuleCall getIsNatureDefinitionParserRuleCall_3_0() { return cIsNatureDefinitionParserRuleCall_3_0; }

		//";"
		public Keyword getSemicolonKeyword_4() { return cSemicolonKeyword_4; }
	}

	public class NatureDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NatureDefinition");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cScalarNatureDefinitionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cCompositeNatureDefinitionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//NatureDefinition returns nature::NatureDefinition:
		//	ScalarNatureDefinition | CompositeNatureDefinition;
		public ParserRule getRule() { return rule; }

		//ScalarNatureDefinition | CompositeNatureDefinition
		public Alternatives getAlternatives() { return cAlternatives; }

		//ScalarNatureDefinition
		public RuleCall getScalarNatureDefinitionParserRuleCall_0() { return cScalarNatureDefinitionParserRuleCall_0; }

		//CompositeNatureDefinition
		public RuleCall getCompositeNatureDefinitionParserRuleCall_1() { return cCompositeNatureDefinitionParserRuleCall_1; }
	}

	public class ScalarNatureDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ScalarNatureDefinition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameNameParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cAcrossKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cAcrossAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cAcrossNameParserRuleCall_2_0 = (RuleCall)cAcrossAssignment_2.eContents().get(0);
		private final Keyword cThroughKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cThroughAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cThroughNameParserRuleCall_4_0 = (RuleCall)cThroughAssignment_4.eContents().get(0);
		private final Keyword cReferenceKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//ScalarNatureDefinition returns nature::ScalarNatureDefinition:
		//	name=Name "across" across=Name "through" through=Name "reference";
		public ParserRule getRule() { return rule; }

		//name=Name "across" across=Name "through" through=Name "reference"
		public Group getGroup() { return cGroup; }

		//name=Name
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//Name
		public RuleCall getNameNameParserRuleCall_0_0() { return cNameNameParserRuleCall_0_0; }

		//"across"
		public Keyword getAcrossKeyword_1() { return cAcrossKeyword_1; }

		//across=Name
		public Assignment getAcrossAssignment_2() { return cAcrossAssignment_2; }

		//Name
		public RuleCall getAcrossNameParserRuleCall_2_0() { return cAcrossNameParserRuleCall_2_0; }

		//"through"
		public Keyword getThroughKeyword_3() { return cThroughKeyword_3; }

		//through=Name
		public Assignment getThroughAssignment_4() { return cThroughAssignment_4; }

		//Name
		public RuleCall getThroughNameParserRuleCall_4_0() { return cThroughNameParserRuleCall_4_0; }

		//"reference"
		public Keyword getReferenceKeyword_5() { return cReferenceKeyword_5; }
	}

	public class NextStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NextStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cNextStatementAction_0 = (Action)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cLabelAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cLabelLabelParserRuleCall_1_0_0 = (RuleCall)cLabelAssignment_1_0.eContents().get(0);
		private final Keyword cColonKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Keyword cNextKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cNextAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNextIdentifierParserRuleCall_3_0 = (RuleCall)cNextAssignment_3.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cWhenKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cWhenAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cWhenExpressionParserRuleCall_4_1_0 = (RuleCall)cWhenAssignment_4_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		/// *
		// * [ label: ] next [ label2 ] [ when condition ] ;
		// * / NextStatement returns statement::NextStatement:
		//	{statement::NextStatement} (label=Label ":")? "next" next=Identifier? ("when" when=Expression)? ";";
		public ParserRule getRule() { return rule; }

		//{statement::NextStatement} (label=Label ":")? "next" next=Identifier? ("when" when=Expression)? ";"
		public Group getGroup() { return cGroup; }

		//{statement::NextStatement}
		public Action getNextStatementAction_0() { return cNextStatementAction_0; }

		//(label=Label ":")?
		public Group getGroup_1() { return cGroup_1; }

		//label=Label
		public Assignment getLabelAssignment_1_0() { return cLabelAssignment_1_0; }

		//Label
		public RuleCall getLabelLabelParserRuleCall_1_0_0() { return cLabelLabelParserRuleCall_1_0_0; }

		//":"
		public Keyword getColonKeyword_1_1() { return cColonKeyword_1_1; }

		//"next"
		public Keyword getNextKeyword_2() { return cNextKeyword_2; }

		//next=Identifier?
		public Assignment getNextAssignment_3() { return cNextAssignment_3; }

		//Identifier
		public RuleCall getNextIdentifierParserRuleCall_3_0() { return cNextIdentifierParserRuleCall_3_0; }

		//("when" when=Expression)?
		public Group getGroup_4() { return cGroup_4; }

		//"when"
		public Keyword getWhenKeyword_4_0() { return cWhenKeyword_4_0; }

		//when=Expression
		public Assignment getWhenAssignment_4_1() { return cWhenAssignment_4_1; }

		//Expression
		public RuleCall getWhenExpressionParserRuleCall_4_1_0() { return cWhenExpressionParserRuleCall_4_1_0; }

		//";"
		public Keyword getSemicolonKeyword_5() { return cSemicolonKeyword_5; }
	}

	public class PortsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Ports");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cPortKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cDeclarationAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cDeclarationPortDeclarationParserRuleCall_2_0 = (RuleCall)cDeclarationAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cSemicolonKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cDeclarationAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cDeclarationPortDeclarationParserRuleCall_3_1_0 = (RuleCall)cDeclarationAssignment_3_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cSemicolonKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//Ports:
		//	"port" "(" declaration+=PortDeclaration (";" declaration+=PortDeclaration)* ")" ";";
		public ParserRule getRule() { return rule; }

		//"port" "(" declaration+=PortDeclaration (";" declaration+=PortDeclaration)* ")" ";"
		public Group getGroup() { return cGroup; }

		//"port"
		public Keyword getPortKeyword_0() { return cPortKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//declaration+=PortDeclaration
		public Assignment getDeclarationAssignment_2() { return cDeclarationAssignment_2; }

		//PortDeclaration
		public RuleCall getDeclarationPortDeclarationParserRuleCall_2_0() { return cDeclarationPortDeclarationParserRuleCall_2_0; }

		//(";" declaration+=PortDeclaration)*
		public Group getGroup_3() { return cGroup_3; }

		//";"
		public Keyword getSemicolonKeyword_3_0() { return cSemicolonKeyword_3_0; }

		//declaration+=PortDeclaration
		public Assignment getDeclarationAssignment_3_1() { return cDeclarationAssignment_3_1; }

		//PortDeclaration
		public RuleCall getDeclarationPortDeclarationParserRuleCall_3_1_0() { return cDeclarationPortDeclarationParserRuleCall_3_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }

		//";"
		public Keyword getSemicolonKeyword_5() { return cSemicolonKeyword_5; }
	}

	public class PortMapsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PortMaps");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cPortKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cMapKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cPortAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cPortParameterParserRuleCall_3_0 = (RuleCall)cPortAssignment_3.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cCommaKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cPortAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cPortParameterParserRuleCall_4_1_0 = (RuleCall)cPortAssignment_4_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//PortMaps:
		//	"port" "map" "(" port+=Parameter ("," port+=Parameter)* ")";
		public ParserRule getRule() { return rule; }

		//"port" "map" "(" port+=Parameter ("," port+=Parameter)* ")"
		public Group getGroup() { return cGroup; }

		//"port"
		public Keyword getPortKeyword_0() { return cPortKeyword_0; }

		//"map"
		public Keyword getMapKeyword_1() { return cMapKeyword_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }

		//port+=Parameter
		public Assignment getPortAssignment_3() { return cPortAssignment_3; }

		//Parameter
		public RuleCall getPortParameterParserRuleCall_3_0() { return cPortParameterParserRuleCall_3_0; }

		//("," port+=Parameter)*
		public Group getGroup_4() { return cGroup_4; }

		//","
		public Keyword getCommaKeyword_4_0() { return cCommaKeyword_4_0; }

		//port+=Parameter
		public Assignment getPortAssignment_4_1() { return cPortAssignment_4_1; }

		//Parameter
		public RuleCall getPortParameterParserRuleCall_4_1_0() { return cPortParameterParserRuleCall_4_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }
	}

	public class ProcedureCallStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ProcedureCallStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cGroup.eContents().get(0);
		private final Assignment cLabelAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final RuleCall cLabelLabelParserRuleCall_0_0_0 = (RuleCall)cLabelAssignment_0_0.eContents().get(0);
		private final Keyword cColonKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Assignment cProcedureAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cProcedureNameParserRuleCall_1_0 = (RuleCall)cProcedureAssignment_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//ProcedureCallStatement returns statement::ProcedureCallStatement:
		//	(label=Label ":")? procedure=Name ";";
		public ParserRule getRule() { return rule; }

		//(label=Label ":")? procedure=Name ";"
		public Group getGroup() { return cGroup; }

		//(label=Label ":")?
		public Group getGroup_0() { return cGroup_0; }

		//label=Label
		public Assignment getLabelAssignment_0_0() { return cLabelAssignment_0_0; }

		//Label
		public RuleCall getLabelLabelParserRuleCall_0_0_0() { return cLabelLabelParserRuleCall_0_0_0; }

		//":"
		public Keyword getColonKeyword_0_1() { return cColonKeyword_0_1; }

		//procedure=Name
		public Assignment getProcedureAssignment_1() { return cProcedureAssignment_1; }

		//Name
		public RuleCall getProcedureNameParserRuleCall_1_0() { return cProcedureNameParserRuleCall_1_0; }

		//";"
		public Keyword getSemicolonKeyword_2() { return cSemicolonKeyword_2; }
	}

	public class ConcurrentProcedureCallStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ConcurrentProcedureCallStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cGroup.eContents().get(0);
		private final Assignment cLabelAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final RuleCall cLabelLabelParserRuleCall_0_0_0 = (RuleCall)cLabelAssignment_0_0.eContents().get(0);
		private final Keyword cColonKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Assignment cPostponedAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Keyword cPostponedPostponedKeyword_1_0 = (Keyword)cPostponedAssignment_1.eContents().get(0);
		private final Assignment cProcedureAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cProcedureNameParserRuleCall_2_0 = (RuleCall)cProcedureAssignment_2.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//ConcurrentProcedureCallStatement returns statement::ProcedureCallStatement:
		//	(label=Label ":")? postponed?="postponed" procedure=Name ";";
		public ParserRule getRule() { return rule; }

		//(label=Label ":")? postponed?="postponed" procedure=Name ";"
		public Group getGroup() { return cGroup; }

		//(label=Label ":")?
		public Group getGroup_0() { return cGroup_0; }

		//label=Label
		public Assignment getLabelAssignment_0_0() { return cLabelAssignment_0_0; }

		//Label
		public RuleCall getLabelLabelParserRuleCall_0_0_0() { return cLabelLabelParserRuleCall_0_0_0; }

		//":"
		public Keyword getColonKeyword_0_1() { return cColonKeyword_0_1; }

		//postponed?="postponed"
		public Assignment getPostponedAssignment_1() { return cPostponedAssignment_1; }

		//"postponed"
		public Keyword getPostponedPostponedKeyword_1_0() { return cPostponedPostponedKeyword_1_0; }

		//procedure=Name
		public Assignment getProcedureAssignment_2() { return cProcedureAssignment_2; }

		//Name
		public RuleCall getProcedureNameParserRuleCall_2_0() { return cProcedureNameParserRuleCall_2_0; }

		//";"
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}

	public class ProcessStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ProcessStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cProcessStatementAction_0 = (Action)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cLabelAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cLabelLabelParserRuleCall_1_0_0 = (RuleCall)cLabelAssignment_1_0.eContents().get(0);
		private final Keyword cColonKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cPostponedAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Keyword cPostponedPostponedKeyword_2_0 = (Keyword)cPostponedAssignment_2.eContents().get(0);
		private final Keyword cProcessKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cLeftParenthesisKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cSensitivityAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cSensitivityMultiIdentifierNameParserRuleCall_4_1_0 = (RuleCall)cSensitivityAssignment_4_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4_2 = (Keyword)cGroup_4.eContents().get(2);
		private final Keyword cIsKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cDeclarationAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cDeclarationProcessDeclarativeItemParserRuleCall_6_0 = (RuleCall)cDeclarationAssignment_6.eContents().get(0);
		private final Keyword cBeginKeyword_7 = (Keyword)cGroup.eContents().get(7);
		private final Assignment cStatementAssignment_8 = (Assignment)cGroup.eContents().get(8);
		private final RuleCall cStatementSequentialStatementParserRuleCall_8_0 = (RuleCall)cStatementAssignment_8.eContents().get(0);
		private final Keyword cEndKeyword_9 = (Keyword)cGroup.eContents().get(9);
		private final Keyword cPostponedKeyword_10 = (Keyword)cGroup.eContents().get(10);
		private final Keyword cProcessKeyword_11 = (Keyword)cGroup.eContents().get(11);
		private final RuleCall cIdentifierParserRuleCall_12 = (RuleCall)cGroup.eContents().get(12);
		private final Keyword cSemicolonKeyword_13 = (Keyword)cGroup.eContents().get(13);
		
		/// *
		// * label : process [ ( sensitivity_list ) ] [ is ]
		// *            [ process_declarative_items ]
		// *         begin
		// *            sequential statements
		// *         end process [ label ] ;
		// * / ProcessStatement returns statement::ProcessStatement:
		//	{statement::ProcessStatement} (label=Label ":")? postponed?="postponed"? "process" ("("
		//	sensitivity=MultiIdentifierName ")")? "is"? declaration+=ProcessDeclarativeItem* "begin"
		//	statement+=SequentialStatement* "end" "postponed"? "process" Identifier? ";";
		public ParserRule getRule() { return rule; }

		//{statement::ProcessStatement} (label=Label ":")? postponed?="postponed"? "process" ("(" sensitivity=MultiIdentifierName
		//")")? "is"? declaration+=ProcessDeclarativeItem* "begin" statement+=SequentialStatement* "end" "postponed"? "process"
		//Identifier? ";"
		public Group getGroup() { return cGroup; }

		//{statement::ProcessStatement}
		public Action getProcessStatementAction_0() { return cProcessStatementAction_0; }

		//(label=Label ":")?
		public Group getGroup_1() { return cGroup_1; }

		//label=Label
		public Assignment getLabelAssignment_1_0() { return cLabelAssignment_1_0; }

		//Label
		public RuleCall getLabelLabelParserRuleCall_1_0_0() { return cLabelLabelParserRuleCall_1_0_0; }

		//":"
		public Keyword getColonKeyword_1_1() { return cColonKeyword_1_1; }

		//postponed?="postponed"?
		public Assignment getPostponedAssignment_2() { return cPostponedAssignment_2; }

		//"postponed"
		public Keyword getPostponedPostponedKeyword_2_0() { return cPostponedPostponedKeyword_2_0; }

		//"process"
		public Keyword getProcessKeyword_3() { return cProcessKeyword_3; }

		//("(" sensitivity=MultiIdentifierName ")")?
		public Group getGroup_4() { return cGroup_4; }

		//"("
		public Keyword getLeftParenthesisKeyword_4_0() { return cLeftParenthesisKeyword_4_0; }

		//sensitivity=MultiIdentifierName
		public Assignment getSensitivityAssignment_4_1() { return cSensitivityAssignment_4_1; }

		//MultiIdentifierName
		public RuleCall getSensitivityMultiIdentifierNameParserRuleCall_4_1_0() { return cSensitivityMultiIdentifierNameParserRuleCall_4_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_4_2() { return cRightParenthesisKeyword_4_2; }

		//"is"?
		public Keyword getIsKeyword_5() { return cIsKeyword_5; }

		//declaration+=ProcessDeclarativeItem*
		public Assignment getDeclarationAssignment_6() { return cDeclarationAssignment_6; }

		//ProcessDeclarativeItem
		public RuleCall getDeclarationProcessDeclarativeItemParserRuleCall_6_0() { return cDeclarationProcessDeclarativeItemParserRuleCall_6_0; }

		//"begin"
		public Keyword getBeginKeyword_7() { return cBeginKeyword_7; }

		//statement+=SequentialStatement*
		public Assignment getStatementAssignment_8() { return cStatementAssignment_8; }

		//SequentialStatement
		public RuleCall getStatementSequentialStatementParserRuleCall_8_0() { return cStatementSequentialStatementParserRuleCall_8_0; }

		//"end"
		public Keyword getEndKeyword_9() { return cEndKeyword_9; }

		//"postponed"?
		public Keyword getPostponedKeyword_10() { return cPostponedKeyword_10; }

		//"process"
		public Keyword getProcessKeyword_11() { return cProcessKeyword_11; }

		//Identifier?
		public RuleCall getIdentifierParserRuleCall_12() { return cIdentifierParserRuleCall_12; }

		//";"
		public Keyword getSemicolonKeyword_13() { return cSemicolonKeyword_13; }
	}

	public class AllocatorExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AllocatorExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cNewKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTypeSubtypeIndicationParserRuleCall_1_0 = (RuleCall)cTypeAssignment_1.eContents().get(0);
		
		/// *
		// * allocator = "new" subtype_indication
		// *	         | "new" qualified_expression
		// * / AllocatorExpression returns expression::AllocatorExpression:
		//	"new" type=SubtypeIndication;
		public ParserRule getRule() { return rule; }

		//"new" type=SubtypeIndication
		public Group getGroup() { return cGroup; }

		//"new"
		public Keyword getNewKeyword_0() { return cNewKeyword_0; }

		//type=SubtypeIndication
		public Assignment getTypeAssignment_1() { return cTypeAssignment_1; }

		//SubtypeIndication
		public RuleCall getTypeSubtypeIndicationParserRuleCall_1_0() { return cTypeSubtypeIndicationParserRuleCall_1_0; }
	}

	public class RecordNatureDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RecordNatureDefinition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cRecordKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cRecordAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cRecordRecordNatureElementParserRuleCall_1_0 = (RuleCall)cRecordAssignment_1.eContents().get(0);
		private final Keyword cEndKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cRecordKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final RuleCall cIdentifierParserRuleCall_4 = (RuleCall)cGroup.eContents().get(4);
		
		//RecordNatureDefinition returns nature::RecordNatureDefinition:
		//	"record" record+=RecordNatureElement+ "end" "record" Identifier?;
		public ParserRule getRule() { return rule; }

		//"record" record+=RecordNatureElement+ "end" "record" Identifier?
		public Group getGroup() { return cGroup; }

		//"record"
		public Keyword getRecordKeyword_0() { return cRecordKeyword_0; }

		//record+=RecordNatureElement+
		public Assignment getRecordAssignment_1() { return cRecordAssignment_1; }

		//RecordNatureElement
		public RuleCall getRecordRecordNatureElementParserRuleCall_1_0() { return cRecordRecordNatureElementParserRuleCall_1_0; }

		//"end"
		public Keyword getEndKeyword_2() { return cEndKeyword_2; }

		//"record"
		public Keyword getRecordKeyword_3() { return cRecordKeyword_3; }

		//Identifier?
		public RuleCall getIdentifierParserRuleCall_4() { return cIdentifierParserRuleCall_4; }
	}

	public class RecordNatureElementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RecordNatureElement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameMultiIdentifierNameParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNatureAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNatureSubnatureIndicationParserRuleCall_2_0 = (RuleCall)cNatureAssignment_2.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//RecordNatureElement returns nature::RecordNatureElement:
		//	name=MultiIdentifierName ":" nature=SubnatureIndication ";";
		public ParserRule getRule() { return rule; }

		//name=MultiIdentifierName ":" nature=SubnatureIndication ";"
		public Group getGroup() { return cGroup; }

		//name=MultiIdentifierName
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//MultiIdentifierName
		public RuleCall getNameMultiIdentifierNameParserRuleCall_0_0() { return cNameMultiIdentifierNameParserRuleCall_0_0; }

		//":"
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }

		//nature=SubnatureIndication
		public Assignment getNatureAssignment_2() { return cNatureAssignment_2; }

		//SubnatureIndication
		public RuleCall getNatureSubnatureIndicationParserRuleCall_2_0() { return cNatureSubnatureIndicationParserRuleCall_2_0; }

		//";"
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}

	public class RecordTypeDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RecordTypeDefinition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cRecordKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cDeclarationAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cDeclarationRecordTypeElementParserRuleCall_1_0 = (RuleCall)cDeclarationAssignment_1.eContents().get(0);
		private final Keyword cEndKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cRecordKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final RuleCall cIdentifierParserRuleCall_4 = (RuleCall)cGroup.eContents().get(4);
		
		//RecordTypeDefinition returns type::RecordTypeDefinition:
		//	"record" declaration+=RecordTypeElement+ "end" "record" Identifier?;
		public ParserRule getRule() { return rule; }

		//"record" declaration+=RecordTypeElement+ "end" "record" Identifier?
		public Group getGroup() { return cGroup; }

		//"record"
		public Keyword getRecordKeyword_0() { return cRecordKeyword_0; }

		//declaration+=RecordTypeElement+
		public Assignment getDeclarationAssignment_1() { return cDeclarationAssignment_1; }

		//RecordTypeElement
		public RuleCall getDeclarationRecordTypeElementParserRuleCall_1_0() { return cDeclarationRecordTypeElementParserRuleCall_1_0; }

		//"end"
		public Keyword getEndKeyword_2() { return cEndKeyword_2; }

		//"record"
		public Keyword getRecordKeyword_3() { return cRecordKeyword_3; }

		//Identifier?
		public RuleCall getIdentifierParserRuleCall_4() { return cIdentifierParserRuleCall_4; }
	}

	public class RecordTypeElementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RecordTypeElement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameMultiIdentifierNameParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTypeSubtypeIndicationParserRuleCall_2_0 = (RuleCall)cTypeAssignment_2.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//RecordTypeElement returns type::RecordTypeElement:
		//	name=MultiIdentifierName ":" type=SubtypeIndication ";";
		public ParserRule getRule() { return rule; }

		//name=MultiIdentifierName ":" type=SubtypeIndication ";"
		public Group getGroup() { return cGroup; }

		//name=MultiIdentifierName
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//MultiIdentifierName
		public RuleCall getNameMultiIdentifierNameParserRuleCall_0_0() { return cNameMultiIdentifierNameParserRuleCall_0_0; }

		//":"
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }

		//type=SubtypeIndication
		public Assignment getTypeAssignment_2() { return cTypeAssignment_2; }

		//SubtypeIndication
		public RuleCall getTypeSubtypeIndicationParserRuleCall_2_0() { return cTypeSubtypeIndicationParserRuleCall_2_0; }

		//";"
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}

	public class ReportStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ReportStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cGroup.eContents().get(0);
		private final Assignment cLabelAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final RuleCall cLabelLabelParserRuleCall_0_0_0 = (RuleCall)cLabelAssignment_0_0.eContents().get(0);
		private final Keyword cColonKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Keyword cReportKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cReportAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cReportExpressionParserRuleCall_2_0 = (RuleCall)cReportAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cSeverityKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cSeverityAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cSeverityExpressionParserRuleCall_3_1_0 = (RuleCall)cSeverityAssignment_3_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		/// *
		// * [ label: ] report string [ severity name ] ;
		// * / ReportStatement returns statement::ReportStatement:
		//	(label=Label ":")? "report" report=Expression ("severity" severity=Expression)? ";";
		public ParserRule getRule() { return rule; }

		//(label=Label ":")? "report" report=Expression ("severity" severity=Expression)? ";"
		public Group getGroup() { return cGroup; }

		//(label=Label ":")?
		public Group getGroup_0() { return cGroup_0; }

		//label=Label
		public Assignment getLabelAssignment_0_0() { return cLabelAssignment_0_0; }

		//Label
		public RuleCall getLabelLabelParserRuleCall_0_0_0() { return cLabelLabelParserRuleCall_0_0_0; }

		//":"
		public Keyword getColonKeyword_0_1() { return cColonKeyword_0_1; }

		//"report"
		public Keyword getReportKeyword_1() { return cReportKeyword_1; }

		//report=Expression
		public Assignment getReportAssignment_2() { return cReportAssignment_2; }

		//Expression
		public RuleCall getReportExpressionParserRuleCall_2_0() { return cReportExpressionParserRuleCall_2_0; }

		//("severity" severity=Expression)?
		public Group getGroup_3() { return cGroup_3; }

		//"severity"
		public Keyword getSeverityKeyword_3_0() { return cSeverityKeyword_3_0; }

		//severity=Expression
		public Assignment getSeverityAssignment_3_1() { return cSeverityAssignment_3_1; }

		//Expression
		public RuleCall getSeverityExpressionParserRuleCall_3_1_0() { return cSeverityExpressionParserRuleCall_3_1_0; }

		//";"
		public Keyword getSemicolonKeyword_4() { return cSemicolonKeyword_4; }
	}

	public class ReturnStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ReturnStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cReturnStatementAction_0 = (Action)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cLabelAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cLabelLabelParserRuleCall_1_0_0 = (RuleCall)cLabelAssignment_1_0.eContents().get(0);
		private final Keyword cColonKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Keyword cReturnKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cExpressionAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cExpressionExpressionParserRuleCall_3_0 = (RuleCall)cExpressionAssignment_3.eContents().get(0);
		private final Keyword cSemicolonKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		/// *
		// * [ label: ] return [ expression ] ;
		// * / ReturnStatement returns statement::ReturnStatement:
		//	{statement::ReturnStatement} (label=Label ":")? "return" expression=Expression? ";";
		public ParserRule getRule() { return rule; }

		//{statement::ReturnStatement} (label=Label ":")? "return" expression=Expression? ";"
		public Group getGroup() { return cGroup; }

		//{statement::ReturnStatement}
		public Action getReturnStatementAction_0() { return cReturnStatementAction_0; }

		//(label=Label ":")?
		public Group getGroup_1() { return cGroup_1; }

		//label=Label
		public Assignment getLabelAssignment_1_0() { return cLabelAssignment_1_0; }

		//Label
		public RuleCall getLabelLabelParserRuleCall_1_0_0() { return cLabelLabelParserRuleCall_1_0_0; }

		//":"
		public Keyword getColonKeyword_1_1() { return cColonKeyword_1_1; }

		//"return"
		public Keyword getReturnKeyword_2() { return cReturnKeyword_2; }

		//expression=Expression?
		public Assignment getExpressionAssignment_3() { return cExpressionAssignment_3; }

		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_3_0() { return cExpressionExpressionParserRuleCall_3_0; }

		//";"
		public Keyword getSemicolonKeyword_4() { return cSemicolonKeyword_4; }
	}

	public class SequentialStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SequentialStatement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cWaitStatementParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cAssertionStatementParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cReportStatementParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cIfStatementParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cCaseStatementParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cLoopStatementParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cNextStatementParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cExitStatementParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		private final RuleCall cReturnStatementParserRuleCall_8 = (RuleCall)cAlternatives.eContents().get(8);
		private final RuleCall cNullStatementParserRuleCall_9 = (RuleCall)cAlternatives.eContents().get(9);
		private final RuleCall cBreakStatementParserRuleCall_10 = (RuleCall)cAlternatives.eContents().get(10);
		private final RuleCall cProcedureCallStatementParserRuleCall_11 = (RuleCall)cAlternatives.eContents().get(11);
		private final RuleCall cVariableAssignmentStatementParserRuleCall_12 = (RuleCall)cAlternatives.eContents().get(12);
		private final RuleCall cSequentialSignalAssignmentStatementParserRuleCall_13 = (RuleCall)cAlternatives.eContents().get(13);
		
		//SequentialStatement returns statement::Statement:
		//	WaitStatement | AssertionStatement | ReportStatement | IfStatement | CaseStatement | LoopStatement | NextStatement |
		//	ExitStatement | ReturnStatement | NullStatement | BreakStatement | ProcedureCallStatement |
		//	VariableAssignmentStatement | SequentialSignalAssignmentStatement;
		public ParserRule getRule() { return rule; }

		//WaitStatement | AssertionStatement | ReportStatement | IfStatement | CaseStatement | LoopStatement | NextStatement |
		//ExitStatement | ReturnStatement | NullStatement | BreakStatement | ProcedureCallStatement | VariableAssignmentStatement
		//| SequentialSignalAssignmentStatement
		public Alternatives getAlternatives() { return cAlternatives; }

		//WaitStatement
		public RuleCall getWaitStatementParserRuleCall_0() { return cWaitStatementParserRuleCall_0; }

		//AssertionStatement
		public RuleCall getAssertionStatementParserRuleCall_1() { return cAssertionStatementParserRuleCall_1; }

		//ReportStatement
		public RuleCall getReportStatementParserRuleCall_2() { return cReportStatementParserRuleCall_2; }

		//IfStatement
		public RuleCall getIfStatementParserRuleCall_3() { return cIfStatementParserRuleCall_3; }

		//CaseStatement
		public RuleCall getCaseStatementParserRuleCall_4() { return cCaseStatementParserRuleCall_4; }

		//LoopStatement
		public RuleCall getLoopStatementParserRuleCall_5() { return cLoopStatementParserRuleCall_5; }

		//NextStatement
		public RuleCall getNextStatementParserRuleCall_6() { return cNextStatementParserRuleCall_6; }

		//ExitStatement
		public RuleCall getExitStatementParserRuleCall_7() { return cExitStatementParserRuleCall_7; }

		//ReturnStatement
		public RuleCall getReturnStatementParserRuleCall_8() { return cReturnStatementParserRuleCall_8; }

		//NullStatement
		public RuleCall getNullStatementParserRuleCall_9() { return cNullStatementParserRuleCall_9; }

		//BreakStatement
		public RuleCall getBreakStatementParserRuleCall_10() { return cBreakStatementParserRuleCall_10; }

		//ProcedureCallStatement
		public RuleCall getProcedureCallStatementParserRuleCall_11() { return cProcedureCallStatementParserRuleCall_11; }

		//VariableAssignmentStatement
		public RuleCall getVariableAssignmentStatementParserRuleCall_12() { return cVariableAssignmentStatementParserRuleCall_12; }

		//SequentialSignalAssignmentStatement
		public RuleCall getSequentialSignalAssignmentStatementParserRuleCall_13() { return cSequentialSignalAssignmentStatementParserRuleCall_13; }
	}

	public class NullStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NullStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cExpressionStatementAction_0 = (Action)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cLabelAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cLabelLabelParserRuleCall_1_0_0 = (RuleCall)cLabelAssignment_1_0.eContents().get(0);
		private final Keyword cColonKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cExpressionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExpressionNullExpressionParserRuleCall_2_0 = (RuleCall)cExpressionAssignment_2.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//NullStatement returns statement::ExpressionStatement:
		//	{statement::ExpressionStatement} (label=Label ":")? expression=NullExpression ";";
		public ParserRule getRule() { return rule; }

		//{statement::ExpressionStatement} (label=Label ":")? expression=NullExpression ";"
		public Group getGroup() { return cGroup; }

		//{statement::ExpressionStatement}
		public Action getExpressionStatementAction_0() { return cExpressionStatementAction_0; }

		//(label=Label ":")?
		public Group getGroup_1() { return cGroup_1; }

		//label=Label
		public Assignment getLabelAssignment_1_0() { return cLabelAssignment_1_0; }

		//Label
		public RuleCall getLabelLabelParserRuleCall_1_0_0() { return cLabelLabelParserRuleCall_1_0_0; }

		//":"
		public Keyword getColonKeyword_1_1() { return cColonKeyword_1_1; }

		//expression=NullExpression
		public Assignment getExpressionAssignment_2() { return cExpressionAssignment_2; }

		//NullExpression
		public RuleCall getExpressionNullExpressionParserRuleCall_2_0() { return cExpressionNullExpressionParserRuleCall_2_0; }

		//";"
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}

	public class SignalDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SignalDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSignalKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameMultiIdentifierNameParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cTypeAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cTypeSubtypeIndicationParserRuleCall_3_0 = (RuleCall)cTypeAssignment_3.eContents().get(0);
		private final Assignment cKindAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cKindSignalKindEnumRuleCall_4_0 = (RuleCall)cKindAssignment_4.eContents().get(0);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cColonEqualsSignKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Assignment cInitialAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cInitialExpressionParserRuleCall_5_1_0 = (RuleCall)cInitialAssignment_5_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//SignalDeclaration returns declaration::SignalDeclaration:
		//	"signal" name=MultiIdentifierName ":" type=SubtypeIndication kind=SignalKind? (":=" initial=Expression)? ";";
		public ParserRule getRule() { return rule; }

		//"signal" name=MultiIdentifierName ":" type=SubtypeIndication kind=SignalKind? (":=" initial=Expression)? ";"
		public Group getGroup() { return cGroup; }

		//"signal"
		public Keyword getSignalKeyword_0() { return cSignalKeyword_0; }

		//name=MultiIdentifierName
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//MultiIdentifierName
		public RuleCall getNameMultiIdentifierNameParserRuleCall_1_0() { return cNameMultiIdentifierNameParserRuleCall_1_0; }

		//":"
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }

		//type=SubtypeIndication
		public Assignment getTypeAssignment_3() { return cTypeAssignment_3; }

		//SubtypeIndication
		public RuleCall getTypeSubtypeIndicationParserRuleCall_3_0() { return cTypeSubtypeIndicationParserRuleCall_3_0; }

		//kind=SignalKind?
		public Assignment getKindAssignment_4() { return cKindAssignment_4; }

		//SignalKind
		public RuleCall getKindSignalKindEnumRuleCall_4_0() { return cKindSignalKindEnumRuleCall_4_0; }

		//(":=" initial=Expression)?
		public Group getGroup_5() { return cGroup_5; }

		//":="
		public Keyword getColonEqualsSignKeyword_5_0() { return cColonEqualsSignKeyword_5_0; }

		//initial=Expression
		public Assignment getInitialAssignment_5_1() { return cInitialAssignment_5_1; }

		//Expression
		public RuleCall getInitialExpressionParserRuleCall_5_1_0() { return cInitialExpressionParserRuleCall_5_1_0; }

		//";"
		public Keyword getSemicolonKeyword_6() { return cSemicolonKeyword_6; }
	}

	public class VariableDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "VariableDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cSharedAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cSharedSharedKeyword_0_0 = (Keyword)cSharedAssignment_0.eContents().get(0);
		private final Keyword cVariableKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameMultiIdentifierNameParserRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Keyword cColonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cTypeAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cTypeSubtypeIndicationParserRuleCall_4_0 = (RuleCall)cTypeAssignment_4.eContents().get(0);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cColonEqualsSignKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Assignment cInitialAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cInitialExpressionParserRuleCall_5_1_0 = (RuleCall)cInitialAssignment_5_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//VariableDeclaration returns declaration::VariableDeclaration:
		//	shared?="shared"? "variable" name=MultiIdentifierName ":" type=SubtypeIndication (":=" initial=Expression)? ";";
		public ParserRule getRule() { return rule; }

		//shared?="shared"? "variable" name=MultiIdentifierName ":" type=SubtypeIndication (":=" initial=Expression)? ";"
		public Group getGroup() { return cGroup; }

		//shared?="shared"?
		public Assignment getSharedAssignment_0() { return cSharedAssignment_0; }

		//"shared"
		public Keyword getSharedSharedKeyword_0_0() { return cSharedSharedKeyword_0_0; }

		//"variable"
		public Keyword getVariableKeyword_1() { return cVariableKeyword_1; }

		//name=MultiIdentifierName
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }

		//MultiIdentifierName
		public RuleCall getNameMultiIdentifierNameParserRuleCall_2_0() { return cNameMultiIdentifierNameParserRuleCall_2_0; }

		//":"
		public Keyword getColonKeyword_3() { return cColonKeyword_3; }

		//type=SubtypeIndication
		public Assignment getTypeAssignment_4() { return cTypeAssignment_4; }

		//SubtypeIndication
		public RuleCall getTypeSubtypeIndicationParserRuleCall_4_0() { return cTypeSubtypeIndicationParserRuleCall_4_0; }

		//(":=" initial=Expression)?
		public Group getGroup_5() { return cGroup_5; }

		//":="
		public Keyword getColonEqualsSignKeyword_5_0() { return cColonEqualsSignKeyword_5_0; }

		//initial=Expression
		public Assignment getInitialAssignment_5_1() { return cInitialAssignment_5_1; }

		//Expression
		public RuleCall getInitialExpressionParserRuleCall_5_1_0() { return cInitialExpressionParserRuleCall_5_1_0; }

		//";"
		public Keyword getSemicolonKeyword_6() { return cSemicolonKeyword_6; }
	}

	public class ConstantDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ConstantDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cConstantKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameMultiIdentifierNameParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cTypeAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cTypeSubtypeIndicationParserRuleCall_3_0 = (RuleCall)cTypeAssignment_3.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cColonEqualsSignKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cInitialAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cInitialExpressionParserRuleCall_4_1_0 = (RuleCall)cInitialAssignment_4_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//ConstantDeclaration returns declaration::ConstantDeclaration:
		//	"constant" name=MultiIdentifierName ":" type=SubtypeIndication (":=" initial=Expression)? ";";
		public ParserRule getRule() { return rule; }

		//"constant" name=MultiIdentifierName ":" type=SubtypeIndication (":=" initial=Expression)? ";"
		public Group getGroup() { return cGroup; }

		//"constant"
		public Keyword getConstantKeyword_0() { return cConstantKeyword_0; }

		//name=MultiIdentifierName
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//MultiIdentifierName
		public RuleCall getNameMultiIdentifierNameParserRuleCall_1_0() { return cNameMultiIdentifierNameParserRuleCall_1_0; }

		//":"
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }

		//type=SubtypeIndication
		public Assignment getTypeAssignment_3() { return cTypeAssignment_3; }

		//SubtypeIndication
		public RuleCall getTypeSubtypeIndicationParserRuleCall_3_0() { return cTypeSubtypeIndicationParserRuleCall_3_0; }

		//(":=" initial=Expression)?
		public Group getGroup_4() { return cGroup_4; }

		//":="
		public Keyword getColonEqualsSignKeyword_4_0() { return cColonEqualsSignKeyword_4_0; }

		//initial=Expression
		public Assignment getInitialAssignment_4_1() { return cInitialAssignment_4_1; }

		//Expression
		public RuleCall getInitialExpressionParserRuleCall_4_1_0() { return cInitialExpressionParserRuleCall_4_1_0; }

		//";"
		public Keyword getSemicolonKeyword_5() { return cSemicolonKeyword_5; }
	}

	public class InterfaceSignalDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "InterfaceSignalDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSignalKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameMultiIdentifierNameParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cModeAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cModeModeEnumRuleCall_3_0 = (RuleCall)cModeAssignment_3.eContents().get(0);
		private final Assignment cTypeAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cTypeSubtypeIndicationParserRuleCall_4_0 = (RuleCall)cTypeAssignment_4.eContents().get(0);
		private final Assignment cKindAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cKindSignalKindEnumRuleCall_5_0 = (RuleCall)cKindAssignment_5.eContents().get(0);
		private final Group cGroup_6 = (Group)cGroup.eContents().get(6);
		private final Keyword cColonEqualsSignKeyword_6_0 = (Keyword)cGroup_6.eContents().get(0);
		private final Assignment cInitialAssignment_6_1 = (Assignment)cGroup_6.eContents().get(1);
		private final RuleCall cInitialExpressionParserRuleCall_6_1_0 = (RuleCall)cInitialAssignment_6_1.eContents().get(0);
		
		//InterfaceSignalDeclaration returns declaration::SignalDeclaration:
		//	"signal"? name=MultiIdentifierName ":" mode=Mode? type=SubtypeIndication kind=SignalKind? (":=" initial=Expression)?;
		public ParserRule getRule() { return rule; }

		//"signal"? name=MultiIdentifierName ":" mode=Mode? type=SubtypeIndication kind=SignalKind? (":=" initial=Expression)?
		public Group getGroup() { return cGroup; }

		//"signal"?
		public Keyword getSignalKeyword_0() { return cSignalKeyword_0; }

		//name=MultiIdentifierName
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//MultiIdentifierName
		public RuleCall getNameMultiIdentifierNameParserRuleCall_1_0() { return cNameMultiIdentifierNameParserRuleCall_1_0; }

		//":"
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }

		//mode=Mode?
		public Assignment getModeAssignment_3() { return cModeAssignment_3; }

		//Mode
		public RuleCall getModeModeEnumRuleCall_3_0() { return cModeModeEnumRuleCall_3_0; }

		//type=SubtypeIndication
		public Assignment getTypeAssignment_4() { return cTypeAssignment_4; }

		//SubtypeIndication
		public RuleCall getTypeSubtypeIndicationParserRuleCall_4_0() { return cTypeSubtypeIndicationParserRuleCall_4_0; }

		//kind=SignalKind?
		public Assignment getKindAssignment_5() { return cKindAssignment_5; }

		//SignalKind
		public RuleCall getKindSignalKindEnumRuleCall_5_0() { return cKindSignalKindEnumRuleCall_5_0; }

		//(":=" initial=Expression)?
		public Group getGroup_6() { return cGroup_6; }

		//":="
		public Keyword getColonEqualsSignKeyword_6_0() { return cColonEqualsSignKeyword_6_0; }

		//initial=Expression
		public Assignment getInitialAssignment_6_1() { return cInitialAssignment_6_1; }

		//Expression
		public RuleCall getInitialExpressionParserRuleCall_6_1_0() { return cInitialExpressionParserRuleCall_6_1_0; }
	}

	public class InterfaceVariableDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "InterfaceVariableDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cVariableKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameMultiIdentifierNameParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cModeAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cModeModeEnumRuleCall_3_0 = (RuleCall)cModeAssignment_3.eContents().get(0);
		private final Assignment cTypeAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cTypeSubtypeIndicationParserRuleCall_4_0 = (RuleCall)cTypeAssignment_4.eContents().get(0);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cColonEqualsSignKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Assignment cInitialAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cInitialExpressionParserRuleCall_5_1_0 = (RuleCall)cInitialAssignment_5_1.eContents().get(0);
		
		//InterfaceVariableDeclaration returns declaration::VariableDeclaration:
		//	"variable"? name=MultiIdentifierName ":" mode=Mode? type=SubtypeIndication (":=" initial=Expression)?;
		public ParserRule getRule() { return rule; }

		//"variable"? name=MultiIdentifierName ":" mode=Mode? type=SubtypeIndication (":=" initial=Expression)?
		public Group getGroup() { return cGroup; }

		//"variable"?
		public Keyword getVariableKeyword_0() { return cVariableKeyword_0; }

		//name=MultiIdentifierName
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//MultiIdentifierName
		public RuleCall getNameMultiIdentifierNameParserRuleCall_1_0() { return cNameMultiIdentifierNameParserRuleCall_1_0; }

		//":"
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }

		//mode=Mode?
		public Assignment getModeAssignment_3() { return cModeAssignment_3; }

		//Mode
		public RuleCall getModeModeEnumRuleCall_3_0() { return cModeModeEnumRuleCall_3_0; }

		//type=SubtypeIndication
		public Assignment getTypeAssignment_4() { return cTypeAssignment_4; }

		//SubtypeIndication
		public RuleCall getTypeSubtypeIndicationParserRuleCall_4_0() { return cTypeSubtypeIndicationParserRuleCall_4_0; }

		//(":=" initial=Expression)?
		public Group getGroup_5() { return cGroup_5; }

		//":="
		public Keyword getColonEqualsSignKeyword_5_0() { return cColonEqualsSignKeyword_5_0; }

		//initial=Expression
		public Assignment getInitialAssignment_5_1() { return cInitialAssignment_5_1; }

		//Expression
		public RuleCall getInitialExpressionParserRuleCall_5_1_0() { return cInitialExpressionParserRuleCall_5_1_0; }
	}

	public class InterfaceConstantDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "InterfaceConstantDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cConstantKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameMultiIdentifierNameParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cInKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cTypeAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cTypeSubtypeIndicationParserRuleCall_4_0 = (RuleCall)cTypeAssignment_4.eContents().get(0);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cColonEqualsSignKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Assignment cInitialAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cInitialExpressionParserRuleCall_5_1_0 = (RuleCall)cInitialAssignment_5_1.eContents().get(0);
		
		//InterfaceConstantDeclaration returns declaration::ConstantDeclaration:
		//	"constant"? name=MultiIdentifierName ":" "in"? type=SubtypeIndication (":=" initial=Expression)?;
		public ParserRule getRule() { return rule; }

		//"constant"? name=MultiIdentifierName ":" "in"? type=SubtypeIndication (":=" initial=Expression)?
		public Group getGroup() { return cGroup; }

		//"constant"?
		public Keyword getConstantKeyword_0() { return cConstantKeyword_0; }

		//name=MultiIdentifierName
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//MultiIdentifierName
		public RuleCall getNameMultiIdentifierNameParserRuleCall_1_0() { return cNameMultiIdentifierNameParserRuleCall_1_0; }

		//":"
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }

		//"in"?
		public Keyword getInKeyword_3() { return cInKeyword_3; }

		//type=SubtypeIndication
		public Assignment getTypeAssignment_4() { return cTypeAssignment_4; }

		//SubtypeIndication
		public RuleCall getTypeSubtypeIndicationParserRuleCall_4_0() { return cTypeSubtypeIndicationParserRuleCall_4_0; }

		//(":=" initial=Expression)?
		public Group getGroup_5() { return cGroup_5; }

		//":="
		public Keyword getColonEqualsSignKeyword_5_0() { return cColonEqualsSignKeyword_5_0; }

		//initial=Expression
		public Assignment getInitialAssignment_5_1() { return cInitialAssignment_5_1; }

		//Expression
		public RuleCall getInitialExpressionParserRuleCall_5_1_0() { return cInitialExpressionParserRuleCall_5_1_0; }
	}

	public class SignatureElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Signature");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cSignatureAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cParameterAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cParameterNameParserRuleCall_2_0_0 = (RuleCall)cParameterAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cParameterAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cParameterNameParserRuleCall_2_1_1_0 = (RuleCall)cParameterAssignment_2_1_1.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cReturnKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cReturnAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cReturnNameParserRuleCall_3_1_0 = (RuleCall)cReturnAssignment_3_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		/// *
		// * signature = [ [ type_mark { "," type_mark } ] [ "return" type_mark ] ].
		// * / Signature:
		//	{Signature} "[" (parameter+=Name ("," parameter+=Name)*)? ("return" return=Name)? "]";
		public ParserRule getRule() { return rule; }

		//{Signature} "[" (parameter+=Name ("," parameter+=Name)*)? ("return" return=Name)? "]"
		public Group getGroup() { return cGroup; }

		//{Signature}
		public Action getSignatureAction_0() { return cSignatureAction_0; }

		//"["
		public Keyword getLeftSquareBracketKeyword_1() { return cLeftSquareBracketKeyword_1; }

		//(parameter+=Name ("," parameter+=Name)*)?
		public Group getGroup_2() { return cGroup_2; }

		//parameter+=Name
		public Assignment getParameterAssignment_2_0() { return cParameterAssignment_2_0; }

		//Name
		public RuleCall getParameterNameParserRuleCall_2_0_0() { return cParameterNameParserRuleCall_2_0_0; }

		//("," parameter+=Name)*
		public Group getGroup_2_1() { return cGroup_2_1; }

		//","
		public Keyword getCommaKeyword_2_1_0() { return cCommaKeyword_2_1_0; }

		//parameter+=Name
		public Assignment getParameterAssignment_2_1_1() { return cParameterAssignment_2_1_1; }

		//Name
		public RuleCall getParameterNameParserRuleCall_2_1_1_0() { return cParameterNameParserRuleCall_2_1_1_0; }

		//("return" return=Name)?
		public Group getGroup_3() { return cGroup_3; }

		//"return"
		public Keyword getReturnKeyword_3_0() { return cReturnKeyword_3_0; }

		//return=Name
		public Assignment getReturnAssignment_3_1() { return cReturnAssignment_3_1; }

		//Name
		public RuleCall getReturnNameParserRuleCall_3_1_0() { return cReturnNameParserRuleCall_3_1_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_4() { return cRightSquareBracketKeyword_4; }
	}

	public class SimultaneousAlternativeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SimultaneousAlternative");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cWhenKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cChoiceAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cChoiceChoicesParserRuleCall_1_0 = (RuleCall)cChoiceAssignment_1.eContents().get(0);
		private final Keyword cEqualsSignGreaterThanSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cStatementAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cStatementSimultaneousStatementParserRuleCall_3_0 = (RuleCall)cStatementAssignment_3.eContents().get(0);
		
		//SimultaneousAlternative returns statement::CaseAlternative:
		//	"when" choice=Choices "=>" statement+=SimultaneousStatement*;
		public ParserRule getRule() { return rule; }

		//"when" choice=Choices "=>" statement+=SimultaneousStatement*
		public Group getGroup() { return cGroup; }

		//"when"
		public Keyword getWhenKeyword_0() { return cWhenKeyword_0; }

		//choice=Choices
		public Assignment getChoiceAssignment_1() { return cChoiceAssignment_1; }

		//Choices
		public RuleCall getChoiceChoicesParserRuleCall_1_0() { return cChoiceChoicesParserRuleCall_1_0; }

		//"=>"
		public Keyword getEqualsSignGreaterThanSignKeyword_2() { return cEqualsSignGreaterThanSignKeyword_2; }

		//statement+=SimultaneousStatement*
		public Assignment getStatementAssignment_3() { return cStatementAssignment_3; }

		//SimultaneousStatement
		public RuleCall getStatementSimultaneousStatementParserRuleCall_3_0() { return cStatementSimultaneousStatementParserRuleCall_3_0; }
	}

	public class SimultaneousCaseStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SimultaneousCaseStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cGroup.eContents().get(0);
		private final Assignment cLabelAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final RuleCall cLabelLabelParserRuleCall_0_0_0 = (RuleCall)cLabelAssignment_0_0.eContents().get(0);
		private final Keyword cColonKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Keyword cCaseKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cCaseAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cCaseExpressionParserRuleCall_2_0 = (RuleCall)cCaseAssignment_2.eContents().get(0);
		private final Keyword cUseKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cWhenAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cWhenSimultaneousAlternativeParserRuleCall_4_0 = (RuleCall)cWhenAssignment_4.eContents().get(0);
		private final Keyword cEndKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Keyword cCaseKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final RuleCall cIdentifierParserRuleCall_7 = (RuleCall)cGroup.eContents().get(7);
		private final Keyword cSemicolonKeyword_8 = (Keyword)cGroup.eContents().get(8);
		
		//SimultaneousCaseStatement returns statement::SimultaneousCaseStatement:
		//	(label=Label ":")? "case" case=Expression "use" when+=SimultaneousAlternative+ "end" "case" Identifier? ";";
		public ParserRule getRule() { return rule; }

		//(label=Label ":")? "case" case=Expression "use" when+=SimultaneousAlternative+ "end" "case" Identifier? ";"
		public Group getGroup() { return cGroup; }

		//(label=Label ":")?
		public Group getGroup_0() { return cGroup_0; }

		//label=Label
		public Assignment getLabelAssignment_0_0() { return cLabelAssignment_0_0; }

		//Label
		public RuleCall getLabelLabelParserRuleCall_0_0_0() { return cLabelLabelParserRuleCall_0_0_0; }

		//":"
		public Keyword getColonKeyword_0_1() { return cColonKeyword_0_1; }

		//"case"
		public Keyword getCaseKeyword_1() { return cCaseKeyword_1; }

		//case=Expression
		public Assignment getCaseAssignment_2() { return cCaseAssignment_2; }

		//Expression
		public RuleCall getCaseExpressionParserRuleCall_2_0() { return cCaseExpressionParserRuleCall_2_0; }

		//"use"
		public Keyword getUseKeyword_3() { return cUseKeyword_3; }

		//when+=SimultaneousAlternative+
		public Assignment getWhenAssignment_4() { return cWhenAssignment_4; }

		//SimultaneousAlternative
		public RuleCall getWhenSimultaneousAlternativeParserRuleCall_4_0() { return cWhenSimultaneousAlternativeParserRuleCall_4_0; }

		//"end"
		public Keyword getEndKeyword_5() { return cEndKeyword_5; }

		//"case"
		public Keyword getCaseKeyword_6() { return cCaseKeyword_6; }

		//Identifier?
		public RuleCall getIdentifierParserRuleCall_7() { return cIdentifierParserRuleCall_7; }

		//";"
		public Keyword getSemicolonKeyword_8() { return cSemicolonKeyword_8; }
	}

	public class SimultaneousIfStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SimultaneousIfStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cGroup.eContents().get(0);
		private final Assignment cLabelAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final RuleCall cLabelLabelParserRuleCall_0_0_0 = (RuleCall)cLabelAssignment_0_0.eContents().get(0);
		private final Keyword cColonKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Keyword cIfKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTestAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTestSimultaneousIfStatementTestParserRuleCall_2_0 = (RuleCall)cTestAssignment_2.eContents().get(0);
		private final Keyword cUseKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cElsifKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cTestAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cTestSimultaneousIfStatementTestParserRuleCall_4_1_0 = (RuleCall)cTestAssignment_4_1.eContents().get(0);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cElseKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Assignment cStatementAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cStatementSimultaneousStatementParserRuleCall_5_1_0 = (RuleCall)cStatementAssignment_5_1.eContents().get(0);
		private final Keyword cEndKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Keyword cUseKeyword_7 = (Keyword)cGroup.eContents().get(7);
		private final RuleCall cIdentifierParserRuleCall_8 = (RuleCall)cGroup.eContents().get(8);
		private final Keyword cSemicolonKeyword_9 = (Keyword)cGroup.eContents().get(9);
		
		//SimultaneousIfStatement returns statement::SimultaneousIfStatement:
		//	(label=Label ":")? "if" test+=SimultaneousIfStatementTest "use" ("elsif" test+=SimultaneousIfStatementTest)* ("else"
		//	statement+=SimultaneousStatement*)? "end" "use" Identifier? ";";
		public ParserRule getRule() { return rule; }

		//(label=Label ":")? "if" test+=SimultaneousIfStatementTest "use" ("elsif" test+=SimultaneousIfStatementTest)* ("else"
		//statement+=SimultaneousStatement*)? "end" "use" Identifier? ";"
		public Group getGroup() { return cGroup; }

		//(label=Label ":")?
		public Group getGroup_0() { return cGroup_0; }

		//label=Label
		public Assignment getLabelAssignment_0_0() { return cLabelAssignment_0_0; }

		//Label
		public RuleCall getLabelLabelParserRuleCall_0_0_0() { return cLabelLabelParserRuleCall_0_0_0; }

		//":"
		public Keyword getColonKeyword_0_1() { return cColonKeyword_0_1; }

		//"if"
		public Keyword getIfKeyword_1() { return cIfKeyword_1; }

		//test+=SimultaneousIfStatementTest
		public Assignment getTestAssignment_2() { return cTestAssignment_2; }

		//SimultaneousIfStatementTest
		public RuleCall getTestSimultaneousIfStatementTestParserRuleCall_2_0() { return cTestSimultaneousIfStatementTestParserRuleCall_2_0; }

		//"use"
		public Keyword getUseKeyword_3() { return cUseKeyword_3; }

		//("elsif" test+=SimultaneousIfStatementTest)*
		public Group getGroup_4() { return cGroup_4; }

		//"elsif"
		public Keyword getElsifKeyword_4_0() { return cElsifKeyword_4_0; }

		//test+=SimultaneousIfStatementTest
		public Assignment getTestAssignment_4_1() { return cTestAssignment_4_1; }

		//SimultaneousIfStatementTest
		public RuleCall getTestSimultaneousIfStatementTestParserRuleCall_4_1_0() { return cTestSimultaneousIfStatementTestParserRuleCall_4_1_0; }

		//("else" statement+=SimultaneousStatement*)?
		public Group getGroup_5() { return cGroup_5; }

		//"else"
		public Keyword getElseKeyword_5_0() { return cElseKeyword_5_0; }

		//statement+=SimultaneousStatement*
		public Assignment getStatementAssignment_5_1() { return cStatementAssignment_5_1; }

		//SimultaneousStatement
		public RuleCall getStatementSimultaneousStatementParserRuleCall_5_1_0() { return cStatementSimultaneousStatementParserRuleCall_5_1_0; }

		//"end"
		public Keyword getEndKeyword_6() { return cEndKeyword_6; }

		//"use"
		public Keyword getUseKeyword_7() { return cUseKeyword_7; }

		//Identifier?
		public RuleCall getIdentifierParserRuleCall_8() { return cIdentifierParserRuleCall_8; }

		//";"
		public Keyword getSemicolonKeyword_9() { return cSemicolonKeyword_9; }
	}

	public class SimultaneousIfStatementTestElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SimultaneousIfStatementTest");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cConditionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cConditionExpressionParserRuleCall_0_0 = (RuleCall)cConditionAssignment_0.eContents().get(0);
		private final Keyword cUseKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cStatementAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cStatementSimultaneousStatementParserRuleCall_2_0 = (RuleCall)cStatementAssignment_2.eContents().get(0);
		
		//SimultaneousIfStatementTest returns statement::IfStatementTest:
		//	condition=Expression "use" statement+=SimultaneousStatement*;
		public ParserRule getRule() { return rule; }

		//condition=Expression "use" statement+=SimultaneousStatement*
		public Group getGroup() { return cGroup; }

		//condition=Expression
		public Assignment getConditionAssignment_0() { return cConditionAssignment_0; }

		//Expression
		public RuleCall getConditionExpressionParserRuleCall_0_0() { return cConditionExpressionParserRuleCall_0_0; }

		//"use"
		public Keyword getUseKeyword_1() { return cUseKeyword_1; }

		//statement+=SimultaneousStatement*
		public Assignment getStatementAssignment_2() { return cStatementAssignment_2; }

		//SimultaneousStatement
		public RuleCall getStatementSimultaneousStatementParserRuleCall_2_0() { return cStatementSimultaneousStatementParserRuleCall_2_0; }
	}

	public class SimultaneousProceduralStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SimultaneousProceduralStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cSimultaneousProceduralStatementAction_0 = (Action)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cLabelAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cLabelLabelParserRuleCall_1_0_0 = (RuleCall)cLabelAssignment_1_0.eContents().get(0);
		private final Keyword cColonKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Keyword cProceduralKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cIsKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cDeclarationAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cDeclarationProceduralDeclarativeItemParserRuleCall_4_0 = (RuleCall)cDeclarationAssignment_4.eContents().get(0);
		private final Keyword cBeginKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cStatementAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cStatementSequentialStatementParserRuleCall_6_0 = (RuleCall)cStatementAssignment_6.eContents().get(0);
		private final Keyword cEndKeyword_7 = (Keyword)cGroup.eContents().get(7);
		private final Keyword cProceduralKeyword_8 = (Keyword)cGroup.eContents().get(8);
		private final RuleCall cIdentifierParserRuleCall_9 = (RuleCall)cGroup.eContents().get(9);
		private final Keyword cSemicolonKeyword_10 = (Keyword)cGroup.eContents().get(10);
		
		//SimultaneousProceduralStatement returns statement::SimultaneousProceduralStatement:
		//	{statement::SimultaneousProceduralStatement} (label=Label ":")? "procedural" "is"?
		//	declaration+=ProceduralDeclarativeItem* "begin" statement+=SequentialStatement* "end" "procedural" Identifier? ";";
		public ParserRule getRule() { return rule; }

		//{statement::SimultaneousProceduralStatement} (label=Label ":")? "procedural" "is"?
		//declaration+=ProceduralDeclarativeItem* "begin" statement+=SequentialStatement* "end" "procedural" Identifier? ";"
		public Group getGroup() { return cGroup; }

		//{statement::SimultaneousProceduralStatement}
		public Action getSimultaneousProceduralStatementAction_0() { return cSimultaneousProceduralStatementAction_0; }

		//(label=Label ":")?
		public Group getGroup_1() { return cGroup_1; }

		//label=Label
		public Assignment getLabelAssignment_1_0() { return cLabelAssignment_1_0; }

		//Label
		public RuleCall getLabelLabelParserRuleCall_1_0_0() { return cLabelLabelParserRuleCall_1_0_0; }

		//":"
		public Keyword getColonKeyword_1_1() { return cColonKeyword_1_1; }

		//"procedural"
		public Keyword getProceduralKeyword_2() { return cProceduralKeyword_2; }

		//"is"?
		public Keyword getIsKeyword_3() { return cIsKeyword_3; }

		//declaration+=ProceduralDeclarativeItem*
		public Assignment getDeclarationAssignment_4() { return cDeclarationAssignment_4; }

		//ProceduralDeclarativeItem
		public RuleCall getDeclarationProceduralDeclarativeItemParserRuleCall_4_0() { return cDeclarationProceduralDeclarativeItemParserRuleCall_4_0; }

		//"begin"
		public Keyword getBeginKeyword_5() { return cBeginKeyword_5; }

		//statement+=SequentialStatement*
		public Assignment getStatementAssignment_6() { return cStatementAssignment_6; }

		//SequentialStatement
		public RuleCall getStatementSequentialStatementParserRuleCall_6_0() { return cStatementSequentialStatementParserRuleCall_6_0; }

		//"end"
		public Keyword getEndKeyword_7() { return cEndKeyword_7; }

		//"procedural"
		public Keyword getProceduralKeyword_8() { return cProceduralKeyword_8; }

		//Identifier?
		public RuleCall getIdentifierParserRuleCall_9() { return cIdentifierParserRuleCall_9; }

		//";"
		public Keyword getSemicolonKeyword_10() { return cSemicolonKeyword_10; }
	}

	public class SimultaneousStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SimultaneousStatement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSimpleSimultaneousStatementParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cSimultaneousIfStatementParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cSimultaneousCaseStatementParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cSimultaneousProceduralStatementParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cNullStatementParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		
		//SimultaneousStatement returns statement::Statement:
		//	SimpleSimultaneousStatement | SimultaneousIfStatement | SimultaneousCaseStatement | SimultaneousProceduralStatement |
		//	NullStatement;
		public ParserRule getRule() { return rule; }

		//SimpleSimultaneousStatement | SimultaneousIfStatement | SimultaneousCaseStatement | SimultaneousProceduralStatement |
		//NullStatement
		public Alternatives getAlternatives() { return cAlternatives; }

		//SimpleSimultaneousStatement
		public RuleCall getSimpleSimultaneousStatementParserRuleCall_0() { return cSimpleSimultaneousStatementParserRuleCall_0; }

		//SimultaneousIfStatement
		public RuleCall getSimultaneousIfStatementParserRuleCall_1() { return cSimultaneousIfStatementParserRuleCall_1; }

		//SimultaneousCaseStatement
		public RuleCall getSimultaneousCaseStatementParserRuleCall_2() { return cSimultaneousCaseStatementParserRuleCall_2; }

		//SimultaneousProceduralStatement
		public RuleCall getSimultaneousProceduralStatementParserRuleCall_3() { return cSimultaneousProceduralStatementParserRuleCall_3; }

		//NullStatement
		public RuleCall getNullStatementParserRuleCall_4() { return cNullStatementParserRuleCall_4; }
	}

	public class SpectrumElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Spectrum");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSpectrumKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cLeftAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLeftSimpleExpressionParserRuleCall_1_0 = (RuleCall)cLeftAssignment_1.eContents().get(0);
		private final Keyword cCommaKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cRightAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cRightSimpleExpressionParserRuleCall_3_0 = (RuleCall)cRightAssignment_3.eContents().get(0);
		
		//Spectrum returns ams::Spectrum:
		//	"spectrum" left=SimpleExpression "," right=SimpleExpression;
		public ParserRule getRule() { return rule; }

		//"spectrum" left=SimpleExpression "," right=SimpleExpression
		public Group getGroup() { return cGroup; }

		//"spectrum"
		public Keyword getSpectrumKeyword_0() { return cSpectrumKeyword_0; }

		//left=SimpleExpression
		public Assignment getLeftAssignment_1() { return cLeftAssignment_1; }

		//SimpleExpression
		public RuleCall getLeftSimpleExpressionParserRuleCall_1_0() { return cLeftSimpleExpressionParserRuleCall_1_0; }

		//","
		public Keyword getCommaKeyword_2() { return cCommaKeyword_2; }

		//right=SimpleExpression
		public Assignment getRightAssignment_3() { return cRightAssignment_3; }

		//SimpleExpression
		public RuleCall getRightSimpleExpressionParserRuleCall_3_0() { return cRightSimpleExpressionParserRuleCall_3_0; }
	}

	public class NoiseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Noise");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cNoiseKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNoiseAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNoiseSimpleExpressionParserRuleCall_1_0 = (RuleCall)cNoiseAssignment_1.eContents().get(0);
		
		//Noise returns ams::Noise:
		//	"noise" noise=SimpleExpression;
		public ParserRule getRule() { return rule; }

		//"noise" noise=SimpleExpression
		public Group getGroup() { return cGroup; }

		//"noise"
		public Keyword getNoiseKeyword_0() { return cNoiseKeyword_0; }

		//noise=SimpleExpression
		public Assignment getNoiseAssignment_1() { return cNoiseAssignment_1; }

		//SimpleExpression
		public RuleCall getNoiseSimpleExpressionParserRuleCall_1_0() { return cNoiseSimpleExpressionParserRuleCall_1_0; }
	}

	public class QuantityDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "QuantityDeclaration");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cBranchQuantityDeclarationParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cFreeQuantityDeclarationParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cSourceQuantityDeclarationParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//QuantityDeclaration returns declaration::QuantityDeclaration:
		//	BranchQuantityDeclaration | FreeQuantityDeclaration | SourceQuantityDeclaration;
		public ParserRule getRule() { return rule; }

		//BranchQuantityDeclaration | FreeQuantityDeclaration | SourceQuantityDeclaration
		public Alternatives getAlternatives() { return cAlternatives; }

		//BranchQuantityDeclaration
		public RuleCall getBranchQuantityDeclarationParserRuleCall_0() { return cBranchQuantityDeclarationParserRuleCall_0; }

		//FreeQuantityDeclaration
		public RuleCall getFreeQuantityDeclarationParserRuleCall_1() { return cFreeQuantityDeclarationParserRuleCall_1; }

		//SourceQuantityDeclaration
		public RuleCall getSourceQuantityDeclarationParserRuleCall_2() { return cSourceQuantityDeclarationParserRuleCall_2; }
	}

	public class QuantityAspectElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "QuantityAspect");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameMultiIdentifierNameParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cToleranceKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cToleranceAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cToleranceExpressionParserRuleCall_1_1_0 = (RuleCall)cToleranceAssignment_1_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cColonEqualsSignKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cExpressionAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cExpressionExpressionParserRuleCall_2_1_0 = (RuleCall)cExpressionAssignment_2_1.eContents().get(0);
		
		/// * 
		// * across_aspect: identifier_list ( tolerance_aspect )? ( VARASGN expression )? ACROSS;
		// * / QuantityAspect returns ams::QuantityAspect:
		//	name=MultiIdentifierName ("tolerance" tolerance=Expression)? (":=" expression=Expression)?;
		public ParserRule getRule() { return rule; }

		//name=MultiIdentifierName ("tolerance" tolerance=Expression)? (":=" expression=Expression)?
		public Group getGroup() { return cGroup; }

		//name=MultiIdentifierName
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//MultiIdentifierName
		public RuleCall getNameMultiIdentifierNameParserRuleCall_0_0() { return cNameMultiIdentifierNameParserRuleCall_0_0; }

		//("tolerance" tolerance=Expression)?
		public Group getGroup_1() { return cGroup_1; }

		//"tolerance"
		public Keyword getToleranceKeyword_1_0() { return cToleranceKeyword_1_0; }

		//tolerance=Expression
		public Assignment getToleranceAssignment_1_1() { return cToleranceAssignment_1_1; }

		//Expression
		public RuleCall getToleranceExpressionParserRuleCall_1_1_0() { return cToleranceExpressionParserRuleCall_1_1_0; }

		//(":=" expression=Expression)?
		public Group getGroup_2() { return cGroup_2; }

		//":="
		public Keyword getColonEqualsSignKeyword_2_0() { return cColonEqualsSignKeyword_2_0; }

		//expression=Expression
		public Assignment getExpressionAssignment_2_1() { return cExpressionAssignment_2_1; }

		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_2_1_0() { return cExpressionExpressionParserRuleCall_2_1_0; }
	}

	public class BranchQuantityDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BranchQuantityDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cQuantityKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cAcrossAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cAcrossQuantityAspectParserRuleCall_1_0_0 = (RuleCall)cAcrossAssignment_1_0.eContents().get(0);
		private final Keyword cAcrossKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cThroughAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cThroughQuantityAspectParserRuleCall_2_0_0 = (RuleCall)cThroughAssignment_2_0.eContents().get(0);
		private final Keyword cThroughKeyword_2_1 = (Keyword)cGroup_2.eContents().get(1);
		private final Assignment cLeftAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cLeftNameParserRuleCall_3_0 = (RuleCall)cLeftAssignment_3.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cToKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cRightAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cRightNameParserRuleCall_4_1_0 = (RuleCall)cRightAssignment_4_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//BranchQuantityDeclaration returns declaration::BranchQuantityDeclaration:
		//	"quantity" (across=QuantityAspect "across")? (through=QuantityAspect "through")? left=Name ("to" right=Name)? ";";
		public ParserRule getRule() { return rule; }

		//"quantity" (across=QuantityAspect "across")? (through=QuantityAspect "through")? left=Name ("to" right=Name)? ";"
		public Group getGroup() { return cGroup; }

		//"quantity"
		public Keyword getQuantityKeyword_0() { return cQuantityKeyword_0; }

		//(across=QuantityAspect "across")?
		public Group getGroup_1() { return cGroup_1; }

		//across=QuantityAspect
		public Assignment getAcrossAssignment_1_0() { return cAcrossAssignment_1_0; }

		//QuantityAspect
		public RuleCall getAcrossQuantityAspectParserRuleCall_1_0_0() { return cAcrossQuantityAspectParserRuleCall_1_0_0; }

		//"across"
		public Keyword getAcrossKeyword_1_1() { return cAcrossKeyword_1_1; }

		//(through=QuantityAspect "through")?
		public Group getGroup_2() { return cGroup_2; }

		//through=QuantityAspect
		public Assignment getThroughAssignment_2_0() { return cThroughAssignment_2_0; }

		//QuantityAspect
		public RuleCall getThroughQuantityAspectParserRuleCall_2_0_0() { return cThroughQuantityAspectParserRuleCall_2_0_0; }

		//"through"
		public Keyword getThroughKeyword_2_1() { return cThroughKeyword_2_1; }

		//left=Name
		public Assignment getLeftAssignment_3() { return cLeftAssignment_3; }

		//Name
		public RuleCall getLeftNameParserRuleCall_3_0() { return cLeftNameParserRuleCall_3_0; }

		//("to" right=Name)?
		public Group getGroup_4() { return cGroup_4; }

		//"to"
		public Keyword getToKeyword_4_0() { return cToKeyword_4_0; }

		//right=Name
		public Assignment getRightAssignment_4_1() { return cRightAssignment_4_1; }

		//Name
		public RuleCall getRightNameParserRuleCall_4_1_0() { return cRightNameParserRuleCall_4_1_0; }

		//";"
		public Keyword getSemicolonKeyword_5() { return cSemicolonKeyword_5; }
	}

	public class FreeQuantityDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FreeQuantityDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cQuantityKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameMultiIdentifierNameParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cTypeAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cTypeSubtypeIndicationParserRuleCall_3_0 = (RuleCall)cTypeAssignment_3.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cColonEqualsSignKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cQuantityAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cQuantityExpressionParserRuleCall_4_1_0 = (RuleCall)cQuantityAssignment_4_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//FreeQuantityDeclaration returns declaration::FreeQuantityDeclaration:
		//	"quantity" name=MultiIdentifierName ":" type=SubtypeIndication (":=" quantity=Expression)? ";";
		public ParserRule getRule() { return rule; }

		//"quantity" name=MultiIdentifierName ":" type=SubtypeIndication (":=" quantity=Expression)? ";"
		public Group getGroup() { return cGroup; }

		//"quantity"
		public Keyword getQuantityKeyword_0() { return cQuantityKeyword_0; }

		//name=MultiIdentifierName
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//MultiIdentifierName
		public RuleCall getNameMultiIdentifierNameParserRuleCall_1_0() { return cNameMultiIdentifierNameParserRuleCall_1_0; }

		//":"
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }

		//type=SubtypeIndication
		public Assignment getTypeAssignment_3() { return cTypeAssignment_3; }

		//SubtypeIndication
		public RuleCall getTypeSubtypeIndicationParserRuleCall_3_0() { return cTypeSubtypeIndicationParserRuleCall_3_0; }

		//(":=" quantity=Expression)?
		public Group getGroup_4() { return cGroup_4; }

		//":="
		public Keyword getColonEqualsSignKeyword_4_0() { return cColonEqualsSignKeyword_4_0; }

		//quantity=Expression
		public Assignment getQuantityAssignment_4_1() { return cQuantityAssignment_4_1; }

		//Expression
		public RuleCall getQuantityExpressionParserRuleCall_4_1_0() { return cQuantityExpressionParserRuleCall_4_1_0; }

		//";"
		public Keyword getSemicolonKeyword_5() { return cSemicolonKeyword_5; }
	}

	public class SourceQuantityDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SourceQuantityDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cQuantityKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameMultiIdentifierNameParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cTypeAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cTypeSubtypeIndicationParserRuleCall_3_0 = (RuleCall)cTypeAssignment_3.eContents().get(0);
		private final Assignment cSourceAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cSourceSourceAspectParserRuleCall_4_0 = (RuleCall)cSourceAssignment_4.eContents().get(0);
		private final Keyword cSemicolonKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//SourceQuantityDeclaration returns declaration::SourceQuantityDeclaration:
		//	"quantity" name=MultiIdentifierName ":" type=SubtypeIndication source=SourceAspect ";";
		public ParserRule getRule() { return rule; }

		//"quantity" name=MultiIdentifierName ":" type=SubtypeIndication source=SourceAspect ";"
		public Group getGroup() { return cGroup; }

		//"quantity"
		public Keyword getQuantityKeyword_0() { return cQuantityKeyword_0; }

		//name=MultiIdentifierName
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//MultiIdentifierName
		public RuleCall getNameMultiIdentifierNameParserRuleCall_1_0() { return cNameMultiIdentifierNameParserRuleCall_1_0; }

		//":"
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }

		//type=SubtypeIndication
		public Assignment getTypeAssignment_3() { return cTypeAssignment_3; }

		//SubtypeIndication
		public RuleCall getTypeSubtypeIndicationParserRuleCall_3_0() { return cTypeSubtypeIndicationParserRuleCall_3_0; }

		//source=SourceAspect
		public Assignment getSourceAssignment_4() { return cSourceAssignment_4; }

		//SourceAspect
		public RuleCall getSourceSourceAspectParserRuleCall_4_0() { return cSourceSourceAspectParserRuleCall_4_0; }

		//";"
		public Keyword getSemicolonKeyword_5() { return cSemicolonKeyword_5; }
	}

	public class SourceAspectElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SourceAspect");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSpectrumParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cNoiseParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//SourceAspect returns ams::SourceAspect:
		//	Spectrum | Noise;
		public ParserRule getRule() { return rule; }

		//Spectrum | Noise
		public Alternatives getAlternatives() { return cAlternatives; }

		//Spectrum
		public RuleCall getSpectrumParserRuleCall_0() { return cSpectrumParserRuleCall_0; }

		//Noise
		public RuleCall getNoiseParserRuleCall_1() { return cNoiseParserRuleCall_1; }
	}

	public class LimitDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LimitDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLimitKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameMultiNameParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cTypeAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cTypeNameParserRuleCall_3_0 = (RuleCall)cTypeAssignment_3.eContents().get(0);
		private final Keyword cWithKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cValueAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cValueExpressionParserRuleCall_5_0 = (RuleCall)cValueAssignment_5.eContents().get(0);
		private final Keyword cSemicolonKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//LimitDeclaration returns declaration::LimitDeclaration:
		//	"limit" name=MultiName ":" type=Name "with" value=Expression ";";
		public ParserRule getRule() { return rule; }

		//"limit" name=MultiName ":" type=Name "with" value=Expression ";"
		public Group getGroup() { return cGroup; }

		//"limit"
		public Keyword getLimitKeyword_0() { return cLimitKeyword_0; }

		//name=MultiName
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//MultiName
		public RuleCall getNameMultiNameParserRuleCall_1_0() { return cNameMultiNameParserRuleCall_1_0; }

		//":"
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }

		//type=Name
		public Assignment getTypeAssignment_3() { return cTypeAssignment_3; }

		//Name
		public RuleCall getTypeNameParserRuleCall_3_0() { return cTypeNameParserRuleCall_3_0; }

		//"with"
		public Keyword getWithKeyword_4() { return cWithKeyword_4; }

		//value=Expression
		public Assignment getValueAssignment_5() { return cValueAssignment_5; }

		//Expression
		public RuleCall getValueExpressionParserRuleCall_5_0() { return cValueExpressionParserRuleCall_5_0; }

		//";"
		public Keyword getSemicolonKeyword_6() { return cSemicolonKeyword_6; }
	}

	public class SubnatureDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SubnatureDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSubnatureKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIdentifierNameParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cIsKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cNatureAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNatureSubnatureIndicationParserRuleCall_3_0 = (RuleCall)cNatureAssignment_3.eContents().get(0);
		private final Keyword cSemicolonKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//SubnatureDeclaration returns declaration::SubnatureDeclaration:
		//	"subnature" name=IdentifierName "is" nature=SubnatureIndication ";";
		public ParserRule getRule() { return rule; }

		//"subnature" name=IdentifierName "is" nature=SubnatureIndication ";"
		public Group getGroup() { return cGroup; }

		//"subnature"
		public Keyword getSubnatureKeyword_0() { return cSubnatureKeyword_0; }

		//name=IdentifierName
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//IdentifierName
		public RuleCall getNameIdentifierNameParserRuleCall_1_0() { return cNameIdentifierNameParserRuleCall_1_0; }

		//"is"
		public Keyword getIsKeyword_2() { return cIsKeyword_2; }

		//nature=SubnatureIndication
		public Assignment getNatureAssignment_3() { return cNatureAssignment_3; }

		//SubnatureIndication
		public RuleCall getNatureSubnatureIndicationParserRuleCall_3_0() { return cNatureSubnatureIndicationParserRuleCall_3_0; }

		//";"
		public Keyword getSemicolonKeyword_4() { return cSemicolonKeyword_4; }
	}

	public class SubprogramDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SubprogramDeclaration");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cProcedureDeclarationParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cFunctionDeclarationParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//SubprogramDeclaration returns declaration::SubprogramDeclaration:
		//	ProcedureDeclaration | FunctionDeclaration;
		public ParserRule getRule() { return rule; }

		//ProcedureDeclaration | FunctionDeclaration
		public Alternatives getAlternatives() { return cAlternatives; }

		//ProcedureDeclaration
		public RuleCall getProcedureDeclarationParserRuleCall_0() { return cProcedureDeclarationParserRuleCall_0; }

		//FunctionDeclaration
		public RuleCall getFunctionDeclarationParserRuleCall_1() { return cFunctionDeclarationParserRuleCall_1; }
	}

	public class ProcedureDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ProcedureDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cProcedureDeclarationAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cProcedureKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameDesignatorNameParserRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cLeftParenthesisKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cParameterAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cParameterProcedureParameterDeclarationParserRuleCall_3_1_0 = (RuleCall)cParameterAssignment_3_1.eContents().get(0);
		private final Group cGroup_3_2 = (Group)cGroup_3.eContents().get(2);
		private final Keyword cSemicolonKeyword_3_2_0 = (Keyword)cGroup_3_2.eContents().get(0);
		private final Assignment cParameterAssignment_3_2_1 = (Assignment)cGroup_3_2.eContents().get(1);
		private final RuleCall cParameterProcedureParameterDeclarationParserRuleCall_3_2_1_0 = (RuleCall)cParameterAssignment_3_2_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3_3 = (Keyword)cGroup_3.eContents().get(3);
		private final Assignment cBodyAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cBodySubprogramBodyParserRuleCall_4_0 = (RuleCall)cBodyAssignment_4.eContents().get(0);
		private final Keyword cSemicolonKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//ProcedureDeclaration returns declaration::ProcedureDeclaration:
		//	{declaration::ProcedureDeclaration} "procedure" name=DesignatorName ("(" parameter+=ProcedureParameterDeclaration (";"
		//	parameter+=ProcedureParameterDeclaration)* ")")? body=SubprogramBody? ";";
		public ParserRule getRule() { return rule; }

		//{declaration::ProcedureDeclaration} "procedure" name=DesignatorName ("(" parameter+=ProcedureParameterDeclaration (";"
		//parameter+=ProcedureParameterDeclaration)* ")")? body=SubprogramBody? ";"
		public Group getGroup() { return cGroup; }

		//{declaration::ProcedureDeclaration}
		public Action getProcedureDeclarationAction_0() { return cProcedureDeclarationAction_0; }

		//"procedure"
		public Keyword getProcedureKeyword_1() { return cProcedureKeyword_1; }

		//name=DesignatorName
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }

		//DesignatorName
		public RuleCall getNameDesignatorNameParserRuleCall_2_0() { return cNameDesignatorNameParserRuleCall_2_0; }

		//("(" parameter+=ProcedureParameterDeclaration (";" parameter+=ProcedureParameterDeclaration)* ")")?
		public Group getGroup_3() { return cGroup_3; }

		//"("
		public Keyword getLeftParenthesisKeyword_3_0() { return cLeftParenthesisKeyword_3_0; }

		//parameter+=ProcedureParameterDeclaration
		public Assignment getParameterAssignment_3_1() { return cParameterAssignment_3_1; }

		//ProcedureParameterDeclaration
		public RuleCall getParameterProcedureParameterDeclarationParserRuleCall_3_1_0() { return cParameterProcedureParameterDeclarationParserRuleCall_3_1_0; }

		//(";" parameter+=ProcedureParameterDeclaration)*
		public Group getGroup_3_2() { return cGroup_3_2; }

		//";"
		public Keyword getSemicolonKeyword_3_2_0() { return cSemicolonKeyword_3_2_0; }

		//parameter+=ProcedureParameterDeclaration
		public Assignment getParameterAssignment_3_2_1() { return cParameterAssignment_3_2_1; }

		//ProcedureParameterDeclaration
		public RuleCall getParameterProcedureParameterDeclarationParserRuleCall_3_2_1_0() { return cParameterProcedureParameterDeclarationParserRuleCall_3_2_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3_3() { return cRightParenthesisKeyword_3_3; }

		//body=SubprogramBody?
		public Assignment getBodyAssignment_4() { return cBodyAssignment_4; }

		//SubprogramBody
		public RuleCall getBodySubprogramBodyParserRuleCall_4_0() { return cBodySubprogramBodyParserRuleCall_4_0; }

		//";"
		public Keyword getSemicolonKeyword_5() { return cSemicolonKeyword_5; }
	}

	public class FunctionDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FunctionDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cFunctionDeclarationAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cPurityAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cPurityPurityEnumRuleCall_1_0 = (RuleCall)cPurityAssignment_1.eContents().get(0);
		private final Keyword cFunctionKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cNameAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNameDesignatorNameParserRuleCall_3_0 = (RuleCall)cNameAssignment_3.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cLeftParenthesisKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cParameterAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cParameterFunctionParameterDeclarationParserRuleCall_4_1_0 = (RuleCall)cParameterAssignment_4_1.eContents().get(0);
		private final Group cGroup_4_2 = (Group)cGroup_4.eContents().get(2);
		private final Keyword cSemicolonKeyword_4_2_0 = (Keyword)cGroup_4_2.eContents().get(0);
		private final Assignment cParameterAssignment_4_2_1 = (Assignment)cGroup_4_2.eContents().get(1);
		private final RuleCall cParameterFunctionParameterDeclarationParserRuleCall_4_2_1_0 = (RuleCall)cParameterAssignment_4_2_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4_3 = (Keyword)cGroup_4.eContents().get(3);
		private final Keyword cReturnKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cTypeAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cTypeNameParserRuleCall_6_0 = (RuleCall)cTypeAssignment_6.eContents().get(0);
		private final Assignment cBodyAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cBodySubprogramBodyParserRuleCall_7_0 = (RuleCall)cBodyAssignment_7.eContents().get(0);
		private final Keyword cSemicolonKeyword_8 = (Keyword)cGroup.eContents().get(8);
		
		//FunctionDeclaration returns declaration::FunctionDeclaration:
		//	{declaration::FunctionDeclaration} purity=Purity? "function" name=DesignatorName ("("
		//	parameter+=FunctionParameterDeclaration (";" parameter+=FunctionParameterDeclaration)* ")")? "return" type=Name
		//	body=SubprogramBody? ";";
		public ParserRule getRule() { return rule; }

		//{declaration::FunctionDeclaration} purity=Purity? "function" name=DesignatorName ("("
		//parameter+=FunctionParameterDeclaration (";" parameter+=FunctionParameterDeclaration)* ")")? "return" type=Name
		//body=SubprogramBody? ";"
		public Group getGroup() { return cGroup; }

		//{declaration::FunctionDeclaration}
		public Action getFunctionDeclarationAction_0() { return cFunctionDeclarationAction_0; }

		//purity=Purity?
		public Assignment getPurityAssignment_1() { return cPurityAssignment_1; }

		//Purity
		public RuleCall getPurityPurityEnumRuleCall_1_0() { return cPurityPurityEnumRuleCall_1_0; }

		//"function"
		public Keyword getFunctionKeyword_2() { return cFunctionKeyword_2; }

		//name=DesignatorName
		public Assignment getNameAssignment_3() { return cNameAssignment_3; }

		//DesignatorName
		public RuleCall getNameDesignatorNameParserRuleCall_3_0() { return cNameDesignatorNameParserRuleCall_3_0; }

		//("(" parameter+=FunctionParameterDeclaration (";" parameter+=FunctionParameterDeclaration)* ")")?
		public Group getGroup_4() { return cGroup_4; }

		//"("
		public Keyword getLeftParenthesisKeyword_4_0() { return cLeftParenthesisKeyword_4_0; }

		//parameter+=FunctionParameterDeclaration
		public Assignment getParameterAssignment_4_1() { return cParameterAssignment_4_1; }

		//FunctionParameterDeclaration
		public RuleCall getParameterFunctionParameterDeclarationParserRuleCall_4_1_0() { return cParameterFunctionParameterDeclarationParserRuleCall_4_1_0; }

		//(";" parameter+=FunctionParameterDeclaration)*
		public Group getGroup_4_2() { return cGroup_4_2; }

		//";"
		public Keyword getSemicolonKeyword_4_2_0() { return cSemicolonKeyword_4_2_0; }

		//parameter+=FunctionParameterDeclaration
		public Assignment getParameterAssignment_4_2_1() { return cParameterAssignment_4_2_1; }

		//FunctionParameterDeclaration
		public RuleCall getParameterFunctionParameterDeclarationParserRuleCall_4_2_1_0() { return cParameterFunctionParameterDeclarationParserRuleCall_4_2_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_4_3() { return cRightParenthesisKeyword_4_3; }

		//"return"
		public Keyword getReturnKeyword_5() { return cReturnKeyword_5; }

		//type=Name
		public Assignment getTypeAssignment_6() { return cTypeAssignment_6; }

		//Name
		public RuleCall getTypeNameParserRuleCall_6_0() { return cTypeNameParserRuleCall_6_0; }

		//body=SubprogramBody?
		public Assignment getBodyAssignment_7() { return cBodyAssignment_7; }

		//SubprogramBody
		public RuleCall getBodySubprogramBodyParserRuleCall_7_0() { return cBodySubprogramBodyParserRuleCall_7_0; }

		//";"
		public Keyword getSemicolonKeyword_8() { return cSemicolonKeyword_8; }
	}

	public class SubprogramBodyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SubprogramBody");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cSubprogramBodyAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cIsKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cDeclarationAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cDeclarationSubprogramDeclarativeItemParserRuleCall_2_0 = (RuleCall)cDeclarationAssignment_2.eContents().get(0);
		private final Keyword cBeginKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cStatementAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cStatementSequentialStatementParserRuleCall_4_0 = (RuleCall)cStatementAssignment_4.eContents().get(0);
		private final Keyword cEndKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Alternatives cAlternatives_6 = (Alternatives)cGroup.eContents().get(6);
		private final Keyword cProcedureKeyword_6_0 = (Keyword)cAlternatives_6.eContents().get(0);
		private final Keyword cFunctionKeyword_6_1 = (Keyword)cAlternatives_6.eContents().get(1);
		private final RuleCall cDesignatorParserRuleCall_7 = (RuleCall)cGroup.eContents().get(7);
		
		//SubprogramBody returns declaration::SubprogramBody:
		//	{declaration::SubprogramBody} "is" declaration+=SubprogramDeclarativeItem* "begin" statement+=SequentialStatement*
		//	"end" ("procedure" | "function")? Designator?;
		public ParserRule getRule() { return rule; }

		//{declaration::SubprogramBody} "is" declaration+=SubprogramDeclarativeItem* "begin" statement+=SequentialStatement* "end"
		//("procedure" | "function")? Designator?
		public Group getGroup() { return cGroup; }

		//{declaration::SubprogramBody}
		public Action getSubprogramBodyAction_0() { return cSubprogramBodyAction_0; }

		//"is"
		public Keyword getIsKeyword_1() { return cIsKeyword_1; }

		//declaration+=SubprogramDeclarativeItem*
		public Assignment getDeclarationAssignment_2() { return cDeclarationAssignment_2; }

		//SubprogramDeclarativeItem
		public RuleCall getDeclarationSubprogramDeclarativeItemParserRuleCall_2_0() { return cDeclarationSubprogramDeclarativeItemParserRuleCall_2_0; }

		//"begin"
		public Keyword getBeginKeyword_3() { return cBeginKeyword_3; }

		//statement+=SequentialStatement*
		public Assignment getStatementAssignment_4() { return cStatementAssignment_4; }

		//SequentialStatement
		public RuleCall getStatementSequentialStatementParserRuleCall_4_0() { return cStatementSequentialStatementParserRuleCall_4_0; }

		//"end"
		public Keyword getEndKeyword_5() { return cEndKeyword_5; }

		//("procedure" | "function")?
		public Alternatives getAlternatives_6() { return cAlternatives_6; }

		//"procedure"
		public Keyword getProcedureKeyword_6_0() { return cProcedureKeyword_6_0; }

		//"function"
		public Keyword getFunctionKeyword_6_1() { return cFunctionKeyword_6_1; }

		//Designator?
		public RuleCall getDesignatorParserRuleCall_7() { return cDesignatorParserRuleCall_7; }
	}

	public class SubtypeDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SubtypeDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSubtypeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIdentifierNameParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cIsKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cTypeAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cTypeSubtypeIndicationParserRuleCall_3_0 = (RuleCall)cTypeAssignment_3.eContents().get(0);
		private final Keyword cSemicolonKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//SubtypeDeclaration returns declaration::SubtypeDeclaration:
		//	"subtype" name=IdentifierName "is" type=SubtypeIndication ";";
		public ParserRule getRule() { return rule; }

		//"subtype" name=IdentifierName "is" type=SubtypeIndication ";"
		public Group getGroup() { return cGroup; }

		//"subtype"
		public Keyword getSubtypeKeyword_0() { return cSubtypeKeyword_0; }

		//name=IdentifierName
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//IdentifierName
		public RuleCall getNameIdentifierNameParserRuleCall_1_0() { return cNameIdentifierNameParserRuleCall_1_0; }

		//"is"
		public Keyword getIsKeyword_2() { return cIsKeyword_2; }

		//type=SubtypeIndication
		public Assignment getTypeAssignment_3() { return cTypeAssignment_3; }

		//SubtypeIndication
		public RuleCall getTypeSubtypeIndicationParserRuleCall_3_0() { return cTypeSubtypeIndicationParserRuleCall_3_0; }

		//";"
		public Keyword getSemicolonKeyword_4() { return cSemicolonKeyword_4; }
	}

	public class AliasDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AliasDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cAliasKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameDesignatorNameParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cColonKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cAliasAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cAliasSubtypeIndicationParserRuleCall_2_1_0 = (RuleCall)cAliasAssignment_2_1.eContents().get(0);
		private final Keyword cIsKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cIsAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cIsNameSignatureParserRuleCall_4_0 = (RuleCall)cIsAssignment_4.eContents().get(0);
		private final Keyword cSemicolonKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//AliasDeclaration returns declaration::AliasDeclaration:
		//	"alias" name=DesignatorName (":" alias=SubtypeIndication)? "is" is=NameSignature ";";
		public ParserRule getRule() { return rule; }

		//"alias" name=DesignatorName (":" alias=SubtypeIndication)? "is" is=NameSignature ";"
		public Group getGroup() { return cGroup; }

		//"alias"
		public Keyword getAliasKeyword_0() { return cAliasKeyword_0; }

		//name=DesignatorName
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//DesignatorName
		public RuleCall getNameDesignatorNameParserRuleCall_1_0() { return cNameDesignatorNameParserRuleCall_1_0; }

		//(":" alias=SubtypeIndication)?
		public Group getGroup_2() { return cGroup_2; }

		//":"
		public Keyword getColonKeyword_2_0() { return cColonKeyword_2_0; }

		//alias=SubtypeIndication
		public Assignment getAliasAssignment_2_1() { return cAliasAssignment_2_1; }

		//SubtypeIndication
		public RuleCall getAliasSubtypeIndicationParserRuleCall_2_1_0() { return cAliasSubtypeIndicationParserRuleCall_2_1_0; }

		//"is"
		public Keyword getIsKeyword_3() { return cIsKeyword_3; }

		//is=NameSignature
		public Assignment getIsAssignment_4() { return cIsAssignment_4; }

		//NameSignature
		public RuleCall getIsNameSignatureParserRuleCall_4_0() { return cIsNameSignatureParserRuleCall_4_0; }

		//";"
		public Keyword getSemicolonKeyword_5() { return cSemicolonKeyword_5; }
	}

	public class RangeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Range");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cSimpleExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cRangeExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cDirectionAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cDirectionRangeDirectionEnumRuleCall_1_1_0 = (RuleCall)cDirectionAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightSimpleExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Range returns expression::Expression:
		//	SimpleExpression ({expression::RangeExpression.left=current} direction=RangeDirection right=SimpleExpression)?;
		public ParserRule getRule() { return rule; }

		//SimpleExpression ({expression::RangeExpression.left=current} direction=RangeDirection right=SimpleExpression)?
		public Group getGroup() { return cGroup; }

		//SimpleExpression
		public RuleCall getSimpleExpressionParserRuleCall_0() { return cSimpleExpressionParserRuleCall_0; }

		//({expression::RangeExpression.left=current} direction=RangeDirection right=SimpleExpression)?
		public Group getGroup_1() { return cGroup_1; }

		//{expression::RangeExpression.left=current}
		public Action getRangeExpressionLeftAction_1_0() { return cRangeExpressionLeftAction_1_0; }

		//direction=RangeDirection
		public Assignment getDirectionAssignment_1_1() { return cDirectionAssignment_1_1; }

		//RangeDirection
		public RuleCall getDirectionRangeDirectionEnumRuleCall_1_1_0() { return cDirectionRangeDirectionEnumRuleCall_1_1_0; }

		//right=SimpleExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//SimpleExpression
		public RuleCall getRightSimpleExpressionParserRuleCall_1_2_0() { return cRightSimpleExpressionParserRuleCall_1_2_0; }
	}

	public class DiscreteRangeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DiscreteRange");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cRangeSpecificationParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cSubtypeIndicationExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		/// *
		// * discrete_range = discrete_subtype_indication
		// *	              | range
		// * / DiscreteRange returns expression::Expression:
		//	RangeSpecification | SubtypeIndicationExpression;
		public ParserRule getRule() { return rule; }

		//RangeSpecification | SubtypeIndicationExpression
		public Alternatives getAlternatives() { return cAlternatives; }

		//RangeSpecification
		public RuleCall getRangeSpecificationParserRuleCall_0() { return cRangeSpecificationParserRuleCall_0; }

		//SubtypeIndicationExpression
		public RuleCall getSubtypeIndicationExpressionParserRuleCall_1() { return cSubtypeIndicationExpressionParserRuleCall_1; }
	}

	public class AggregateElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Aggregate");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cAggregateExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cExpressionAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cExpressionParameterParserRuleCall_2_0_0 = (RuleCall)cExpressionAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cExpressionAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cExpressionParameterParserRuleCall_2_1_1_0 = (RuleCall)cExpressionAssignment_2_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		/// *
		// * aggregate = "(" element_association { "," element_association } ")".
		// *
		// * Associations with elements' simple names are allowed in record aggregates only.
		// * Associations with simple expressions or discrete ranges as choices are allowed only in array aggregates.
		// * Each element of the value defined by an aggregate must be represented once and only once in the aggregate.
		// * Aggregates containing the single element association must always be specified 
		// * using named association in order to distinguish them from parenthesized expressions.
		// * The others choice can be only the last in an aggregate.
		// * / Aggregate returns expression::AggregateExpression:
		//	{expression::AggregateExpression} "(" (expression+=Parameter ("," expression+=Parameter)*)? ")";
		public ParserRule getRule() { return rule; }

		//{expression::AggregateExpression} "(" (expression+=Parameter ("," expression+=Parameter)*)? ")"
		public Group getGroup() { return cGroup; }

		//{expression::AggregateExpression}
		public Action getAggregateExpressionAction_0() { return cAggregateExpressionAction_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//(expression+=Parameter ("," expression+=Parameter)*)?
		public Group getGroup_2() { return cGroup_2; }

		//expression+=Parameter
		public Assignment getExpressionAssignment_2_0() { return cExpressionAssignment_2_0; }

		//Parameter
		public RuleCall getExpressionParameterParserRuleCall_2_0_0() { return cExpressionParameterParserRuleCall_2_0_0; }

		//("," expression+=Parameter)*
		public Group getGroup_2_1() { return cGroup_2_1; }

		//","
		public Keyword getCommaKeyword_2_1_0() { return cCommaKeyword_2_1_0; }

		//expression+=Parameter
		public Assignment getExpressionAssignment_2_1_1() { return cExpressionAssignment_2_1_1; }

		//Parameter
		public RuleCall getExpressionParameterParserRuleCall_2_1_1_0() { return cExpressionParameterParserRuleCall_2_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}

	public class SliceNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SliceName");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cRangeSpecificationParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//SliceName returns Name:
		//	"(" RangeSpecification ")";
		public ParserRule getRule() { return rule; }

		//"(" RangeSpecification ")"
		public Group getGroup() { return cGroup; }

		//"("
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }

		//RangeSpecification
		public RuleCall getRangeSpecificationParserRuleCall_1() { return cRangeSpecificationParserRuleCall_1; }

		//")"
		public Keyword getRightParenthesisKeyword_2() { return cRightParenthesisKeyword_2; }
	}

	public class RangeSpecificationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RangeSpecification");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cRangeExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Assignment cLeftAssignment_1_0_0 = (Assignment)cGroup_1_0.eContents().get(0);
		private final RuleCall cLeftSimpleExpressionParserRuleCall_1_0_0_0 = (RuleCall)cLeftAssignment_1_0_0.eContents().get(0);
		private final Assignment cDirectionAssignment_1_0_1 = (Assignment)cGroup_1_0.eContents().get(1);
		private final RuleCall cDirectionRangeDirectionEnumRuleCall_1_0_1_0 = (RuleCall)cDirectionAssignment_1_0_1.eContents().get(0);
		private final Assignment cRightAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRightSimpleExpressionParserRuleCall_2_0 = (RuleCall)cRightAssignment_2.eContents().get(0);
		
		//RangeSpecification returns expression::RangeExpression:
		//	{expression::RangeExpression} => (left=SimpleExpression direction=RangeDirection) right=SimpleExpression;
		public ParserRule getRule() { return rule; }

		//{expression::RangeExpression} => (left=SimpleExpression direction=RangeDirection) right=SimpleExpression
		public Group getGroup() { return cGroup; }

		//{expression::RangeExpression}
		public Action getRangeExpressionAction_0() { return cRangeExpressionAction_0; }

		//=> (left=SimpleExpression direction=RangeDirection)
		public Group getGroup_1() { return cGroup_1; }

		//left=SimpleExpression direction=RangeDirection
		public Group getGroup_1_0() { return cGroup_1_0; }

		//left=SimpleExpression
		public Assignment getLeftAssignment_1_0_0() { return cLeftAssignment_1_0_0; }

		//SimpleExpression
		public RuleCall getLeftSimpleExpressionParserRuleCall_1_0_0_0() { return cLeftSimpleExpressionParserRuleCall_1_0_0_0; }

		//direction=RangeDirection
		public Assignment getDirectionAssignment_1_0_1() { return cDirectionAssignment_1_0_1; }

		//RangeDirection
		public RuleCall getDirectionRangeDirectionEnumRuleCall_1_0_1_0() { return cDirectionRangeDirectionEnumRuleCall_1_0_1_0; }

		//right=SimpleExpression
		public Assignment getRightAssignment_2() { return cRightAssignment_2; }

		//SimpleExpression
		public RuleCall getRightSimpleExpressionParserRuleCall_2_0() { return cRightSimpleExpressionParserRuleCall_2_0; }
	}

	public class SubtypeIndicationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SubtypeIndication");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cSubtypeIndicationExpressionAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Assignment cNameAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cNameNameParserRuleCall_0_1_0 = (RuleCall)cNameAssignment_0_1.eContents().get(0);
		private final Assignment cMarkAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cMarkNameParserRuleCall_0_2_0 = (RuleCall)cMarkAssignment_0_2.eContents().get(0);
		private final Assignment cConstraintAssignment_0_3 = (Assignment)cGroup_0.eContents().get(3);
		private final RuleCall cConstraintConstraintParserRuleCall_0_3_0 = (RuleCall)cConstraintAssignment_0_3.eContents().get(0);
		private final Group cGroup_0_4 = (Group)cGroup_0.eContents().get(4);
		private final Keyword cToleranceKeyword_0_4_0 = (Keyword)cGroup_0_4.eContents().get(0);
		private final Assignment cToleranceAssignment_0_4_1 = (Assignment)cGroup_0_4.eContents().get(1);
		private final RuleCall cToleranceExpressionParserRuleCall_0_4_1_0 = (RuleCall)cToleranceAssignment_0_4_1.eContents().get(0);
		private final Group cGroup_0_4_2 = (Group)cGroup_0_4.eContents().get(2);
		private final Keyword cAcrossKeyword_0_4_2_0 = (Keyword)cGroup_0_4_2.eContents().get(0);
		private final Assignment cAcrossAssignment_0_4_2_1 = (Assignment)cGroup_0_4_2.eContents().get(1);
		private final RuleCall cAcrossExpressionParserRuleCall_0_4_2_1_0 = (RuleCall)cAcrossAssignment_0_4_2_1.eContents().get(0);
		private final Keyword cThroughKeyword_0_4_2_2 = (Keyword)cGroup_0_4_2.eContents().get(2);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cSubtypeIndicationExpressionAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cGroup_1.eContents().get(1);
		private final Group cGroup_1_1_0 = (Group)cGroup_1_1.eContents().get(0);
		private final Assignment cMarkAssignment_1_1_0_0 = (Assignment)cGroup_1_1_0.eContents().get(0);
		private final RuleCall cMarkNameParserRuleCall_1_1_0_0_0 = (RuleCall)cMarkAssignment_1_1_0_0.eContents().get(0);
		private final Assignment cConstraintAssignment_1_1_0_1 = (Assignment)cGroup_1_1_0.eContents().get(1);
		private final RuleCall cConstraintConstraintParserRuleCall_1_1_0_1_0 = (RuleCall)cConstraintAssignment_1_1_0_1.eContents().get(0);
		private final Group cGroup_1_2 = (Group)cGroup_1.eContents().get(2);
		private final Keyword cToleranceKeyword_1_2_0 = (Keyword)cGroup_1_2.eContents().get(0);
		private final Assignment cToleranceAssignment_1_2_1 = (Assignment)cGroup_1_2.eContents().get(1);
		private final RuleCall cToleranceExpressionParserRuleCall_1_2_1_0 = (RuleCall)cToleranceAssignment_1_2_1.eContents().get(0);
		private final Group cGroup_1_2_2 = (Group)cGroup_1_2.eContents().get(2);
		private final Keyword cAcrossKeyword_1_2_2_0 = (Keyword)cGroup_1_2_2.eContents().get(0);
		private final Assignment cAcrossAssignment_1_2_2_1 = (Assignment)cGroup_1_2_2.eContents().get(1);
		private final RuleCall cAcrossExpressionParserRuleCall_1_2_2_1_0 = (RuleCall)cAcrossAssignment_1_2_2_1.eContents().get(0);
		private final Keyword cThroughKeyword_1_2_2_2 = (Keyword)cGroup_1_2_2.eContents().get(2);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Action cSubtypeIndicationExpressionAction_2_0 = (Action)cGroup_2.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Group cGroup_2_1_0 = (Group)cGroup_2_1.eContents().get(0);
		private final Assignment cMarkAssignment_2_1_0_0 = (Assignment)cGroup_2_1_0.eContents().get(0);
		private final RuleCall cMarkNameParserRuleCall_2_1_0_0_0 = (RuleCall)cMarkAssignment_2_1_0_0.eContents().get(0);
		private final Keyword cToleranceKeyword_2_1_0_1 = (Keyword)cGroup_2_1_0.eContents().get(1);
		private final Assignment cToleranceAssignment_2_2 = (Assignment)cGroup_2.eContents().get(2);
		private final RuleCall cToleranceExpressionParserRuleCall_2_2_0 = (RuleCall)cToleranceAssignment_2_2.eContents().get(0);
		private final Group cGroup_2_3 = (Group)cGroup_2.eContents().get(3);
		private final Keyword cAcrossKeyword_2_3_0 = (Keyword)cGroup_2_3.eContents().get(0);
		private final Assignment cAcrossAssignment_2_3_1 = (Assignment)cGroup_2_3.eContents().get(1);
		private final RuleCall cAcrossExpressionParserRuleCall_2_3_1_0 = (RuleCall)cAcrossAssignment_2_3_1.eContents().get(0);
		private final Keyword cThroughKeyword_2_3_2 = (Keyword)cGroup_2_3.eContents().get(2);
		private final RuleCall cNameParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		/// *
		// * NAME_PATTERN (NAME_PATTERN)? = [ resolution_indication ] type_mark [ constraint ].
		// * / SubtypeIndication returns type::TypeReference:
		//	{expression::SubtypeIndicationExpression} name=Name mark=Name constraint=Constraint? ("tolerance" tolerance=Expression
		//	("across" across=Expression "through")?)? | {expression::SubtypeIndicationExpression} => (mark=Name
		//	constraint=Constraint) ("tolerance" tolerance=Expression ("across" across=Expression "through")?)? |
		//	{expression::SubtypeIndicationExpression} => (mark=Name "tolerance") tolerance=Expression ("across" across=Expression
		//	"through")? | Name;
		public ParserRule getRule() { return rule; }

		//{expression::SubtypeIndicationExpression} name=Name mark=Name constraint=Constraint? ("tolerance" tolerance=Expression
		//("across" across=Expression "through")?)? | {expression::SubtypeIndicationExpression} => (mark=Name
		//constraint=Constraint) ("tolerance" tolerance=Expression ("across" across=Expression "through")?)? |
		//{expression::SubtypeIndicationExpression} => (mark=Name "tolerance") tolerance=Expression ("across" across=Expression
		//"through")? | Name
		public Alternatives getAlternatives() { return cAlternatives; }

		//{expression::SubtypeIndicationExpression} name=Name mark=Name constraint=Constraint? ("tolerance" tolerance=Expression
		//("across" across=Expression "through")?)?
		public Group getGroup_0() { return cGroup_0; }

		//{expression::SubtypeIndicationExpression}
		public Action getSubtypeIndicationExpressionAction_0_0() { return cSubtypeIndicationExpressionAction_0_0; }

		//name=Name
		public Assignment getNameAssignment_0_1() { return cNameAssignment_0_1; }

		//Name
		public RuleCall getNameNameParserRuleCall_0_1_0() { return cNameNameParserRuleCall_0_1_0; }

		//mark=Name
		public Assignment getMarkAssignment_0_2() { return cMarkAssignment_0_2; }

		//Name
		public RuleCall getMarkNameParserRuleCall_0_2_0() { return cMarkNameParserRuleCall_0_2_0; }

		//constraint=Constraint?
		public Assignment getConstraintAssignment_0_3() { return cConstraintAssignment_0_3; }

		//Constraint
		public RuleCall getConstraintConstraintParserRuleCall_0_3_0() { return cConstraintConstraintParserRuleCall_0_3_0; }

		//("tolerance" tolerance=Expression ("across" across=Expression "through")?)?
		public Group getGroup_0_4() { return cGroup_0_4; }

		//"tolerance"
		public Keyword getToleranceKeyword_0_4_0() { return cToleranceKeyword_0_4_0; }

		//tolerance=Expression
		public Assignment getToleranceAssignment_0_4_1() { return cToleranceAssignment_0_4_1; }

		//Expression
		public RuleCall getToleranceExpressionParserRuleCall_0_4_1_0() { return cToleranceExpressionParserRuleCall_0_4_1_0; }

		//("across" across=Expression "through")?
		public Group getGroup_0_4_2() { return cGroup_0_4_2; }

		//"across"
		public Keyword getAcrossKeyword_0_4_2_0() { return cAcrossKeyword_0_4_2_0; }

		//across=Expression
		public Assignment getAcrossAssignment_0_4_2_1() { return cAcrossAssignment_0_4_2_1; }

		//Expression
		public RuleCall getAcrossExpressionParserRuleCall_0_4_2_1_0() { return cAcrossExpressionParserRuleCall_0_4_2_1_0; }

		//"through"
		public Keyword getThroughKeyword_0_4_2_2() { return cThroughKeyword_0_4_2_2; }

		//{expression::SubtypeIndicationExpression} => (mark=Name constraint=Constraint) ("tolerance" tolerance=Expression
		//("across" across=Expression "through")?)?
		public Group getGroup_1() { return cGroup_1; }

		//{expression::SubtypeIndicationExpression}
		public Action getSubtypeIndicationExpressionAction_1_0() { return cSubtypeIndicationExpressionAction_1_0; }

		//=> (mark=Name constraint=Constraint)
		public Group getGroup_1_1() { return cGroup_1_1; }

		//mark=Name constraint=Constraint
		public Group getGroup_1_1_0() { return cGroup_1_1_0; }

		//mark=Name
		public Assignment getMarkAssignment_1_1_0_0() { return cMarkAssignment_1_1_0_0; }

		//Name
		public RuleCall getMarkNameParserRuleCall_1_1_0_0_0() { return cMarkNameParserRuleCall_1_1_0_0_0; }

		//constraint=Constraint
		public Assignment getConstraintAssignment_1_1_0_1() { return cConstraintAssignment_1_1_0_1; }

		//Constraint
		public RuleCall getConstraintConstraintParserRuleCall_1_1_0_1_0() { return cConstraintConstraintParserRuleCall_1_1_0_1_0; }

		//("tolerance" tolerance=Expression ("across" across=Expression "through")?)?
		public Group getGroup_1_2() { return cGroup_1_2; }

		//"tolerance"
		public Keyword getToleranceKeyword_1_2_0() { return cToleranceKeyword_1_2_0; }

		//tolerance=Expression
		public Assignment getToleranceAssignment_1_2_1() { return cToleranceAssignment_1_2_1; }

		//Expression
		public RuleCall getToleranceExpressionParserRuleCall_1_2_1_0() { return cToleranceExpressionParserRuleCall_1_2_1_0; }

		//("across" across=Expression "through")?
		public Group getGroup_1_2_2() { return cGroup_1_2_2; }

		//"across"
		public Keyword getAcrossKeyword_1_2_2_0() { return cAcrossKeyword_1_2_2_0; }

		//across=Expression
		public Assignment getAcrossAssignment_1_2_2_1() { return cAcrossAssignment_1_2_2_1; }

		//Expression
		public RuleCall getAcrossExpressionParserRuleCall_1_2_2_1_0() { return cAcrossExpressionParserRuleCall_1_2_2_1_0; }

		//"through"
		public Keyword getThroughKeyword_1_2_2_2() { return cThroughKeyword_1_2_2_2; }

		//{expression::SubtypeIndicationExpression} => (mark=Name "tolerance") tolerance=Expression ("across" across=Expression
		//"through")?
		public Group getGroup_2() { return cGroup_2; }

		//{expression::SubtypeIndicationExpression}
		public Action getSubtypeIndicationExpressionAction_2_0() { return cSubtypeIndicationExpressionAction_2_0; }

		//=> (mark=Name "tolerance")
		public Group getGroup_2_1() { return cGroup_2_1; }

		//mark=Name "tolerance"
		public Group getGroup_2_1_0() { return cGroup_2_1_0; }

		//mark=Name
		public Assignment getMarkAssignment_2_1_0_0() { return cMarkAssignment_2_1_0_0; }

		//Name
		public RuleCall getMarkNameParserRuleCall_2_1_0_0_0() { return cMarkNameParserRuleCall_2_1_0_0_0; }

		//"tolerance"
		public Keyword getToleranceKeyword_2_1_0_1() { return cToleranceKeyword_2_1_0_1; }

		//tolerance=Expression
		public Assignment getToleranceAssignment_2_2() { return cToleranceAssignment_2_2; }

		//Expression
		public RuleCall getToleranceExpressionParserRuleCall_2_2_0() { return cToleranceExpressionParserRuleCall_2_2_0; }

		//("across" across=Expression "through")?
		public Group getGroup_2_3() { return cGroup_2_3; }

		//"across"
		public Keyword getAcrossKeyword_2_3_0() { return cAcrossKeyword_2_3_0; }

		//across=Expression
		public Assignment getAcrossAssignment_2_3_1() { return cAcrossAssignment_2_3_1; }

		//Expression
		public RuleCall getAcrossExpressionParserRuleCall_2_3_1_0() { return cAcrossExpressionParserRuleCall_2_3_1_0; }

		//"through"
		public Keyword getThroughKeyword_2_3_2() { return cThroughKeyword_2_3_2; }

		//Name
		public RuleCall getNameParserRuleCall_3() { return cNameParserRuleCall_3; }
	}

	public class SubtypeIndicationExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SubtypeIndicationExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cSubtypeIndicationExpressionAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Assignment cNameAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cNameNameParserRuleCall_0_1_0 = (RuleCall)cNameAssignment_0_1.eContents().get(0);
		private final Assignment cMarkAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cMarkNameParserRuleCall_0_2_0 = (RuleCall)cMarkAssignment_0_2.eContents().get(0);
		private final Assignment cConstraintAssignment_0_3 = (Assignment)cGroup_0.eContents().get(3);
		private final RuleCall cConstraintConstraintParserRuleCall_0_3_0 = (RuleCall)cConstraintAssignment_0_3.eContents().get(0);
		private final Group cGroup_0_4 = (Group)cGroup_0.eContents().get(4);
		private final Keyword cToleranceKeyword_0_4_0 = (Keyword)cGroup_0_4.eContents().get(0);
		private final Assignment cToleranceAssignment_0_4_1 = (Assignment)cGroup_0_4.eContents().get(1);
		private final RuleCall cToleranceExpressionParserRuleCall_0_4_1_0 = (RuleCall)cToleranceAssignment_0_4_1.eContents().get(0);
		private final Group cGroup_0_4_2 = (Group)cGroup_0_4.eContents().get(2);
		private final Keyword cAcrossKeyword_0_4_2_0 = (Keyword)cGroup_0_4_2.eContents().get(0);
		private final Assignment cAcrossAssignment_0_4_2_1 = (Assignment)cGroup_0_4_2.eContents().get(1);
		private final RuleCall cAcrossExpressionParserRuleCall_0_4_2_1_0 = (RuleCall)cAcrossAssignment_0_4_2_1.eContents().get(0);
		private final Keyword cThroughKeyword_0_4_2_2 = (Keyword)cGroup_0_4_2.eContents().get(2);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cSubtypeIndicationExpressionAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cGroup_1.eContents().get(1);
		private final Group cGroup_1_1_0 = (Group)cGroup_1_1.eContents().get(0);
		private final Assignment cMarkAssignment_1_1_0_0 = (Assignment)cGroup_1_1_0.eContents().get(0);
		private final RuleCall cMarkNameParserRuleCall_1_1_0_0_0 = (RuleCall)cMarkAssignment_1_1_0_0.eContents().get(0);
		private final Assignment cConstraintAssignment_1_1_0_1 = (Assignment)cGroup_1_1_0.eContents().get(1);
		private final RuleCall cConstraintConstraintParserRuleCall_1_1_0_1_0 = (RuleCall)cConstraintAssignment_1_1_0_1.eContents().get(0);
		private final Group cGroup_1_2 = (Group)cGroup_1.eContents().get(2);
		private final Keyword cToleranceKeyword_1_2_0 = (Keyword)cGroup_1_2.eContents().get(0);
		private final Assignment cToleranceAssignment_1_2_1 = (Assignment)cGroup_1_2.eContents().get(1);
		private final RuleCall cToleranceExpressionParserRuleCall_1_2_1_0 = (RuleCall)cToleranceAssignment_1_2_1.eContents().get(0);
		private final Group cGroup_1_2_2 = (Group)cGroup_1_2.eContents().get(2);
		private final Keyword cAcrossKeyword_1_2_2_0 = (Keyword)cGroup_1_2_2.eContents().get(0);
		private final Assignment cAcrossAssignment_1_2_2_1 = (Assignment)cGroup_1_2_2.eContents().get(1);
		private final RuleCall cAcrossExpressionParserRuleCall_1_2_2_1_0 = (RuleCall)cAcrossAssignment_1_2_2_1.eContents().get(0);
		private final Keyword cThroughKeyword_1_2_2_2 = (Keyword)cGroup_1_2_2.eContents().get(2);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Action cSubtypeIndicationExpressionAction_2_0 = (Action)cGroup_2.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Group cGroup_2_1_0 = (Group)cGroup_2_1.eContents().get(0);
		private final Assignment cMarkAssignment_2_1_0_0 = (Assignment)cGroup_2_1_0.eContents().get(0);
		private final RuleCall cMarkNameParserRuleCall_2_1_0_0_0 = (RuleCall)cMarkAssignment_2_1_0_0.eContents().get(0);
		private final Keyword cToleranceKeyword_2_1_0_1 = (Keyword)cGroup_2_1_0.eContents().get(1);
		private final Assignment cToleranceAssignment_2_2 = (Assignment)cGroup_2.eContents().get(2);
		private final RuleCall cToleranceExpressionParserRuleCall_2_2_0 = (RuleCall)cToleranceAssignment_2_2.eContents().get(0);
		private final Group cGroup_2_3 = (Group)cGroup_2.eContents().get(3);
		private final Keyword cAcrossKeyword_2_3_0 = (Keyword)cGroup_2_3.eContents().get(0);
		private final Assignment cAcrossAssignment_2_3_1 = (Assignment)cGroup_2_3.eContents().get(1);
		private final RuleCall cAcrossExpressionParserRuleCall_2_3_1_0 = (RuleCall)cAcrossAssignment_2_3_1.eContents().get(0);
		private final Keyword cThroughKeyword_2_3_2 = (Keyword)cGroup_2_3.eContents().get(2);
		private final RuleCall cNameExpressionParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//SubtypeIndicationExpression returns expression::Expression:
		//	{expression::SubtypeIndicationExpression} name=Name mark=Name constraint=Constraint? ("tolerance" tolerance=Expression
		//	("across" across=Expression "through")?)? | {expression::SubtypeIndicationExpression} => (mark=Name
		//	constraint=Constraint) ("tolerance" tolerance=Expression ("across" across=Expression "through")?)? |
		//	{expression::SubtypeIndicationExpression} => (mark=Name "tolerance") tolerance=Expression ("across" across=Expression
		//	"through")? | NameExpression;
		public ParserRule getRule() { return rule; }

		//{expression::SubtypeIndicationExpression} name=Name mark=Name constraint=Constraint? ("tolerance" tolerance=Expression
		//("across" across=Expression "through")?)? | {expression::SubtypeIndicationExpression} => (mark=Name
		//constraint=Constraint) ("tolerance" tolerance=Expression ("across" across=Expression "through")?)? |
		//{expression::SubtypeIndicationExpression} => (mark=Name "tolerance") tolerance=Expression ("across" across=Expression
		//"through")? | NameExpression
		public Alternatives getAlternatives() { return cAlternatives; }

		//{expression::SubtypeIndicationExpression} name=Name mark=Name constraint=Constraint? ("tolerance" tolerance=Expression
		//("across" across=Expression "through")?)?
		public Group getGroup_0() { return cGroup_0; }

		//{expression::SubtypeIndicationExpression}
		public Action getSubtypeIndicationExpressionAction_0_0() { return cSubtypeIndicationExpressionAction_0_0; }

		//name=Name
		public Assignment getNameAssignment_0_1() { return cNameAssignment_0_1; }

		//Name
		public RuleCall getNameNameParserRuleCall_0_1_0() { return cNameNameParserRuleCall_0_1_0; }

		//mark=Name
		public Assignment getMarkAssignment_0_2() { return cMarkAssignment_0_2; }

		//Name
		public RuleCall getMarkNameParserRuleCall_0_2_0() { return cMarkNameParserRuleCall_0_2_0; }

		//constraint=Constraint?
		public Assignment getConstraintAssignment_0_3() { return cConstraintAssignment_0_3; }

		//Constraint
		public RuleCall getConstraintConstraintParserRuleCall_0_3_0() { return cConstraintConstraintParserRuleCall_0_3_0; }

		//("tolerance" tolerance=Expression ("across" across=Expression "through")?)?
		public Group getGroup_0_4() { return cGroup_0_4; }

		//"tolerance"
		public Keyword getToleranceKeyword_0_4_0() { return cToleranceKeyword_0_4_0; }

		//tolerance=Expression
		public Assignment getToleranceAssignment_0_4_1() { return cToleranceAssignment_0_4_1; }

		//Expression
		public RuleCall getToleranceExpressionParserRuleCall_0_4_1_0() { return cToleranceExpressionParserRuleCall_0_4_1_0; }

		//("across" across=Expression "through")?
		public Group getGroup_0_4_2() { return cGroup_0_4_2; }

		//"across"
		public Keyword getAcrossKeyword_0_4_2_0() { return cAcrossKeyword_0_4_2_0; }

		//across=Expression
		public Assignment getAcrossAssignment_0_4_2_1() { return cAcrossAssignment_0_4_2_1; }

		//Expression
		public RuleCall getAcrossExpressionParserRuleCall_0_4_2_1_0() { return cAcrossExpressionParserRuleCall_0_4_2_1_0; }

		//"through"
		public Keyword getThroughKeyword_0_4_2_2() { return cThroughKeyword_0_4_2_2; }

		//{expression::SubtypeIndicationExpression} => (mark=Name constraint=Constraint) ("tolerance" tolerance=Expression
		//("across" across=Expression "through")?)?
		public Group getGroup_1() { return cGroup_1; }

		//{expression::SubtypeIndicationExpression}
		public Action getSubtypeIndicationExpressionAction_1_0() { return cSubtypeIndicationExpressionAction_1_0; }

		//=> (mark=Name constraint=Constraint)
		public Group getGroup_1_1() { return cGroup_1_1; }

		//mark=Name constraint=Constraint
		public Group getGroup_1_1_0() { return cGroup_1_1_0; }

		//mark=Name
		public Assignment getMarkAssignment_1_1_0_0() { return cMarkAssignment_1_1_0_0; }

		//Name
		public RuleCall getMarkNameParserRuleCall_1_1_0_0_0() { return cMarkNameParserRuleCall_1_1_0_0_0; }

		//constraint=Constraint
		public Assignment getConstraintAssignment_1_1_0_1() { return cConstraintAssignment_1_1_0_1; }

		//Constraint
		public RuleCall getConstraintConstraintParserRuleCall_1_1_0_1_0() { return cConstraintConstraintParserRuleCall_1_1_0_1_0; }

		//("tolerance" tolerance=Expression ("across" across=Expression "through")?)?
		public Group getGroup_1_2() { return cGroup_1_2; }

		//"tolerance"
		public Keyword getToleranceKeyword_1_2_0() { return cToleranceKeyword_1_2_0; }

		//tolerance=Expression
		public Assignment getToleranceAssignment_1_2_1() { return cToleranceAssignment_1_2_1; }

		//Expression
		public RuleCall getToleranceExpressionParserRuleCall_1_2_1_0() { return cToleranceExpressionParserRuleCall_1_2_1_0; }

		//("across" across=Expression "through")?
		public Group getGroup_1_2_2() { return cGroup_1_2_2; }

		//"across"
		public Keyword getAcrossKeyword_1_2_2_0() { return cAcrossKeyword_1_2_2_0; }

		//across=Expression
		public Assignment getAcrossAssignment_1_2_2_1() { return cAcrossAssignment_1_2_2_1; }

		//Expression
		public RuleCall getAcrossExpressionParserRuleCall_1_2_2_1_0() { return cAcrossExpressionParserRuleCall_1_2_2_1_0; }

		//"through"
		public Keyword getThroughKeyword_1_2_2_2() { return cThroughKeyword_1_2_2_2; }

		//{expression::SubtypeIndicationExpression} => (mark=Name "tolerance") tolerance=Expression ("across" across=Expression
		//"through")?
		public Group getGroup_2() { return cGroup_2; }

		//{expression::SubtypeIndicationExpression}
		public Action getSubtypeIndicationExpressionAction_2_0() { return cSubtypeIndicationExpressionAction_2_0; }

		//=> (mark=Name "tolerance")
		public Group getGroup_2_1() { return cGroup_2_1; }

		//mark=Name "tolerance"
		public Group getGroup_2_1_0() { return cGroup_2_1_0; }

		//mark=Name
		public Assignment getMarkAssignment_2_1_0_0() { return cMarkAssignment_2_1_0_0; }

		//Name
		public RuleCall getMarkNameParserRuleCall_2_1_0_0_0() { return cMarkNameParserRuleCall_2_1_0_0_0; }

		//"tolerance"
		public Keyword getToleranceKeyword_2_1_0_1() { return cToleranceKeyword_2_1_0_1; }

		//tolerance=Expression
		public Assignment getToleranceAssignment_2_2() { return cToleranceAssignment_2_2; }

		//Expression
		public RuleCall getToleranceExpressionParserRuleCall_2_2_0() { return cToleranceExpressionParserRuleCall_2_2_0; }

		//("across" across=Expression "through")?
		public Group getGroup_2_3() { return cGroup_2_3; }

		//"across"
		public Keyword getAcrossKeyword_2_3_0() { return cAcrossKeyword_2_3_0; }

		//across=Expression
		public Assignment getAcrossAssignment_2_3_1() { return cAcrossAssignment_2_3_1; }

		//Expression
		public RuleCall getAcrossExpressionParserRuleCall_2_3_1_0() { return cAcrossExpressionParserRuleCall_2_3_1_0; }

		//"through"
		public Keyword getThroughKeyword_2_3_2() { return cThroughKeyword_2_3_2; }

		//NameExpression
		public RuleCall getNameExpressionParserRuleCall_3() { return cNameExpressionParserRuleCall_3; }
	}

	public class SubnatureIndicationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SubnatureIndication");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cSubnatureIndicationExpressionAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Group cGroup_0_1 = (Group)cGroup_0.eContents().get(1);
		private final Group cGroup_0_1_0 = (Group)cGroup_0_1.eContents().get(0);
		private final Assignment cMarkAssignment_0_1_0_0 = (Assignment)cGroup_0_1_0.eContents().get(0);
		private final RuleCall cMarkNameParserRuleCall_0_1_0_0_0 = (RuleCall)cMarkAssignment_0_1_0_0.eContents().get(0);
		private final Assignment cConstraintAssignment_0_1_0_1 = (Assignment)cGroup_0_1_0.eContents().get(1);
		private final RuleCall cConstraintIndexConstraintParserRuleCall_0_1_0_1_0 = (RuleCall)cConstraintAssignment_0_1_0_1.eContents().get(0);
		private final Group cGroup_0_2 = (Group)cGroup_0.eContents().get(2);
		private final Keyword cToleranceKeyword_0_2_0 = (Keyword)cGroup_0_2.eContents().get(0);
		private final Assignment cToleranceAssignment_0_2_1 = (Assignment)cGroup_0_2.eContents().get(1);
		private final RuleCall cToleranceExpressionParserRuleCall_0_2_1_0 = (RuleCall)cToleranceAssignment_0_2_1.eContents().get(0);
		private final Group cGroup_0_2_2 = (Group)cGroup_0_2.eContents().get(2);
		private final Keyword cAcrossKeyword_0_2_2_0 = (Keyword)cGroup_0_2_2.eContents().get(0);
		private final Assignment cAcrossAssignment_0_2_2_1 = (Assignment)cGroup_0_2_2.eContents().get(1);
		private final RuleCall cAcrossExpressionParserRuleCall_0_2_2_1_0 = (RuleCall)cAcrossAssignment_0_2_2_1.eContents().get(0);
		private final Keyword cThroughKeyword_0_2_2_2 = (Keyword)cGroup_0_2_2.eContents().get(2);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cSubnatureIndicationExpressionAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cMarkAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cMarkNameParserRuleCall_1_1_0 = (RuleCall)cMarkAssignment_1_1.eContents().get(0);
		private final Keyword cToleranceKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		private final Assignment cToleranceAssignment_1_3 = (Assignment)cGroup_1.eContents().get(3);
		private final RuleCall cToleranceExpressionParserRuleCall_1_3_0 = (RuleCall)cToleranceAssignment_1_3.eContents().get(0);
		private final Group cGroup_1_4 = (Group)cGroup_1.eContents().get(4);
		private final Keyword cAcrossKeyword_1_4_0 = (Keyword)cGroup_1_4.eContents().get(0);
		private final Assignment cAcrossAssignment_1_4_1 = (Assignment)cGroup_1_4.eContents().get(1);
		private final RuleCall cAcrossExpressionParserRuleCall_1_4_1_0 = (RuleCall)cAcrossAssignment_1_4_1.eContents().get(0);
		private final Keyword cThroughKeyword_1_4_2 = (Keyword)cGroup_1_4.eContents().get(2);
		private final RuleCall cNameParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//SubnatureIndication returns nature::NatureReference:
		//	{expression::SubnatureIndicationExpression} => (mark=Name constraint=IndexConstraint) ("tolerance"
		//	tolerance=Expression ("across" across=Expression "through")?)? | {expression::SubnatureIndicationExpression} mark=Name
		//	"tolerance" tolerance=Expression ("across" across=Expression "through")? | Name;
		public ParserRule getRule() { return rule; }

		//{expression::SubnatureIndicationExpression} => (mark=Name constraint=IndexConstraint) ("tolerance" tolerance=Expression
		//("across" across=Expression "through")?)? | {expression::SubnatureIndicationExpression} mark=Name "tolerance"
		//tolerance=Expression ("across" across=Expression "through")? | Name
		public Alternatives getAlternatives() { return cAlternatives; }

		//{expression::SubnatureIndicationExpression} => (mark=Name constraint=IndexConstraint) ("tolerance" tolerance=Expression
		//("across" across=Expression "through")?)?
		public Group getGroup_0() { return cGroup_0; }

		//{expression::SubnatureIndicationExpression}
		public Action getSubnatureIndicationExpressionAction_0_0() { return cSubnatureIndicationExpressionAction_0_0; }

		//=> (mark=Name constraint=IndexConstraint)
		public Group getGroup_0_1() { return cGroup_0_1; }

		//mark=Name constraint=IndexConstraint
		public Group getGroup_0_1_0() { return cGroup_0_1_0; }

		//mark=Name
		public Assignment getMarkAssignment_0_1_0_0() { return cMarkAssignment_0_1_0_0; }

		//Name
		public RuleCall getMarkNameParserRuleCall_0_1_0_0_0() { return cMarkNameParserRuleCall_0_1_0_0_0; }

		//constraint=IndexConstraint
		public Assignment getConstraintAssignment_0_1_0_1() { return cConstraintAssignment_0_1_0_1; }

		//IndexConstraint
		public RuleCall getConstraintIndexConstraintParserRuleCall_0_1_0_1_0() { return cConstraintIndexConstraintParserRuleCall_0_1_0_1_0; }

		//("tolerance" tolerance=Expression ("across" across=Expression "through")?)?
		public Group getGroup_0_2() { return cGroup_0_2; }

		//"tolerance"
		public Keyword getToleranceKeyword_0_2_0() { return cToleranceKeyword_0_2_0; }

		//tolerance=Expression
		public Assignment getToleranceAssignment_0_2_1() { return cToleranceAssignment_0_2_1; }

		//Expression
		public RuleCall getToleranceExpressionParserRuleCall_0_2_1_0() { return cToleranceExpressionParserRuleCall_0_2_1_0; }

		//("across" across=Expression "through")?
		public Group getGroup_0_2_2() { return cGroup_0_2_2; }

		//"across"
		public Keyword getAcrossKeyword_0_2_2_0() { return cAcrossKeyword_0_2_2_0; }

		//across=Expression
		public Assignment getAcrossAssignment_0_2_2_1() { return cAcrossAssignment_0_2_2_1; }

		//Expression
		public RuleCall getAcrossExpressionParserRuleCall_0_2_2_1_0() { return cAcrossExpressionParserRuleCall_0_2_2_1_0; }

		//"through"
		public Keyword getThroughKeyword_0_2_2_2() { return cThroughKeyword_0_2_2_2; }

		//{expression::SubnatureIndicationExpression} mark=Name "tolerance" tolerance=Expression ("across" across=Expression
		//"through")?
		public Group getGroup_1() { return cGroup_1; }

		//{expression::SubnatureIndicationExpression}
		public Action getSubnatureIndicationExpressionAction_1_0() { return cSubnatureIndicationExpressionAction_1_0; }

		//mark=Name
		public Assignment getMarkAssignment_1_1() { return cMarkAssignment_1_1; }

		//Name
		public RuleCall getMarkNameParserRuleCall_1_1_0() { return cMarkNameParserRuleCall_1_1_0; }

		//"tolerance"
		public Keyword getToleranceKeyword_1_2() { return cToleranceKeyword_1_2; }

		//tolerance=Expression
		public Assignment getToleranceAssignment_1_3() { return cToleranceAssignment_1_3; }

		//Expression
		public RuleCall getToleranceExpressionParserRuleCall_1_3_0() { return cToleranceExpressionParserRuleCall_1_3_0; }

		//("across" across=Expression "through")?
		public Group getGroup_1_4() { return cGroup_1_4; }

		//"across"
		public Keyword getAcrossKeyword_1_4_0() { return cAcrossKeyword_1_4_0; }

		//across=Expression
		public Assignment getAcrossAssignment_1_4_1() { return cAcrossAssignment_1_4_1; }

		//Expression
		public RuleCall getAcrossExpressionParserRuleCall_1_4_1_0() { return cAcrossExpressionParserRuleCall_1_4_1_0; }

		//"through"
		public Keyword getThroughKeyword_1_4_2() { return cThroughKeyword_1_4_2; }

		//Name
		public RuleCall getNameParserRuleCall_2() { return cNameParserRuleCall_2; }
	}

	public class TargetElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Target");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cNameExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cAggregateParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Target returns expression::Expression:
		//	NameExpression | Aggregate;
		public ParserRule getRule() { return rule; }

		//NameExpression | Aggregate
		public Alternatives getAlternatives() { return cAlternatives; }

		//NameExpression
		public RuleCall getNameExpressionParserRuleCall_0() { return cNameExpressionParserRuleCall_0; }

		//Aggregate
		public RuleCall getAggregateParserRuleCall_1() { return cAggregateParserRuleCall_1; }
	}

	public class TerminalDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TerminalDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cTerminalKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameMultiIdentifierNameParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cNatureAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNatureSubnatureIndicationParserRuleCall_3_0 = (RuleCall)cNatureAssignment_3.eContents().get(0);
		private final Keyword cSemicolonKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//TerminalDeclaration returns declaration::TerminalDeclaration:
		//	"terminal" name=MultiIdentifierName ":" nature=SubnatureIndication ";";
		public ParserRule getRule() { return rule; }

		//"terminal" name=MultiIdentifierName ":" nature=SubnatureIndication ";"
		public Group getGroup() { return cGroup; }

		//"terminal"
		public Keyword getTerminalKeyword_0() { return cTerminalKeyword_0; }

		//name=MultiIdentifierName
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//MultiIdentifierName
		public RuleCall getNameMultiIdentifierNameParserRuleCall_1_0() { return cNameMultiIdentifierNameParserRuleCall_1_0; }

		//":"
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }

		//nature=SubnatureIndication
		public Assignment getNatureAssignment_3() { return cNatureAssignment_3; }

		//SubnatureIndication
		public RuleCall getNatureSubnatureIndicationParserRuleCall_3_0() { return cNatureSubnatureIndicationParserRuleCall_3_0; }

		//";"
		public Keyword getSemicolonKeyword_4() { return cSemicolonKeyword_4; }
	}

	public class TypeDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TypeDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cTypeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIdentifierNameParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cIsKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cIsAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cIsTypeDefinitionParserRuleCall_2_1_0 = (RuleCall)cIsAssignment_2_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//TypeDeclaration returns declaration::TypeDeclaration:
		//	"type" name=IdentifierName ("is" is=TypeDefinition)? ";";
		public ParserRule getRule() { return rule; }

		//"type" name=IdentifierName ("is" is=TypeDefinition)? ";"
		public Group getGroup() { return cGroup; }

		//"type"
		public Keyword getTypeKeyword_0() { return cTypeKeyword_0; }

		//name=IdentifierName
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//IdentifierName
		public RuleCall getNameIdentifierNameParserRuleCall_1_0() { return cNameIdentifierNameParserRuleCall_1_0; }

		//("is" is=TypeDefinition)?
		public Group getGroup_2() { return cGroup_2; }

		//"is"
		public Keyword getIsKeyword_2_0() { return cIsKeyword_2_0; }

		//is=TypeDefinition
		public Assignment getIsAssignment_2_1() { return cIsAssignment_2_1; }

		//TypeDefinition
		public RuleCall getIsTypeDefinitionParserRuleCall_2_1_0() { return cIsTypeDefinitionParserRuleCall_2_1_0; }

		//";"
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}

	public class TypeDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TypeDefinition");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cEnumerationTypeDefinitionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cCompositeTypeDefinitionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cAccessTypeDefinitionParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cFileTypeDefinitionParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cPhysicalTypeDefinitionParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cRangeTypeDefinitionParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		
		//TypeDefinition returns type::TypeDefinition:
		//	EnumerationTypeDefinition | CompositeTypeDefinition | AccessTypeDefinition | FileTypeDefinition |
		//	PhysicalTypeDefinition | RangeTypeDefinition;
		public ParserRule getRule() { return rule; }

		//EnumerationTypeDefinition | CompositeTypeDefinition | AccessTypeDefinition | FileTypeDefinition | PhysicalTypeDefinition
		//| RangeTypeDefinition
		public Alternatives getAlternatives() { return cAlternatives; }

		//EnumerationTypeDefinition
		public RuleCall getEnumerationTypeDefinitionParserRuleCall_0() { return cEnumerationTypeDefinitionParserRuleCall_0; }

		//CompositeTypeDefinition
		public RuleCall getCompositeTypeDefinitionParserRuleCall_1() { return cCompositeTypeDefinitionParserRuleCall_1; }

		//AccessTypeDefinition
		public RuleCall getAccessTypeDefinitionParserRuleCall_2() { return cAccessTypeDefinitionParserRuleCall_2; }

		//FileTypeDefinition
		public RuleCall getFileTypeDefinitionParserRuleCall_3() { return cFileTypeDefinitionParserRuleCall_3; }

		//PhysicalTypeDefinition
		public RuleCall getPhysicalTypeDefinitionParserRuleCall_4() { return cPhysicalTypeDefinitionParserRuleCall_4; }

		//RangeTypeDefinition
		public RuleCall getRangeTypeDefinitionParserRuleCall_5() { return cRangeTypeDefinitionParserRuleCall_5; }
	}

	public class RangeTypeDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RangeTypeDefinition");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cRangeTypeDefinitionAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Keyword cRangeKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Assignment cLeftAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cLeftSimpleExpressionParserRuleCall_0_2_0 = (RuleCall)cLeftAssignment_0_2.eContents().get(0);
		private final Assignment cDirectionAssignment_0_3 = (Assignment)cGroup_0.eContents().get(3);
		private final RuleCall cDirectionRangeDirectionEnumRuleCall_0_3_0 = (RuleCall)cDirectionAssignment_0_3.eContents().get(0);
		private final Assignment cRightAssignment_0_4 = (Assignment)cGroup_0.eContents().get(4);
		private final RuleCall cRightSimpleExpressionParserRuleCall_0_4_0 = (RuleCall)cRightAssignment_0_4.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cRangeTypeDefinitionAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cRangeKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Keyword cLessThanSignGreaterThanSignKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		
		//RangeTypeDefinition returns type::RangeTypeDefinition:
		//	{type::RangeTypeDefinition} "range" left=SimpleExpression direction=RangeDirection right=SimpleExpression |
		//	{type::RangeTypeDefinition} "range" "<>";
		public ParserRule getRule() { return rule; }

		//{type::RangeTypeDefinition} "range" left=SimpleExpression direction=RangeDirection right=SimpleExpression |
		//{type::RangeTypeDefinition} "range" "<>"
		public Alternatives getAlternatives() { return cAlternatives; }

		//{type::RangeTypeDefinition} "range" left=SimpleExpression direction=RangeDirection right=SimpleExpression
		public Group getGroup_0() { return cGroup_0; }

		//{type::RangeTypeDefinition}
		public Action getRangeTypeDefinitionAction_0_0() { return cRangeTypeDefinitionAction_0_0; }

		//"range"
		public Keyword getRangeKeyword_0_1() { return cRangeKeyword_0_1; }

		//left=SimpleExpression
		public Assignment getLeftAssignment_0_2() { return cLeftAssignment_0_2; }

		//SimpleExpression
		public RuleCall getLeftSimpleExpressionParserRuleCall_0_2_0() { return cLeftSimpleExpressionParserRuleCall_0_2_0; }

		//direction=RangeDirection
		public Assignment getDirectionAssignment_0_3() { return cDirectionAssignment_0_3; }

		//RangeDirection
		public RuleCall getDirectionRangeDirectionEnumRuleCall_0_3_0() { return cDirectionRangeDirectionEnumRuleCall_0_3_0; }

		//right=SimpleExpression
		public Assignment getRightAssignment_0_4() { return cRightAssignment_0_4; }

		//SimpleExpression
		public RuleCall getRightSimpleExpressionParserRuleCall_0_4_0() { return cRightSimpleExpressionParserRuleCall_0_4_0; }

		//{type::RangeTypeDefinition} "range" "<>"
		public Group getGroup_1() { return cGroup_1; }

		//{type::RangeTypeDefinition}
		public Action getRangeTypeDefinitionAction_1_0() { return cRangeTypeDefinitionAction_1_0; }

		//"range"
		public Keyword getRangeKeyword_1_1() { return cRangeKeyword_1_1; }

		//"<>"
		public Keyword getLessThanSignGreaterThanSignKeyword_1_2() { return cLessThanSignGreaterThanSignKeyword_1_2; }
	}

	public class PhysicalTypeDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PhysicalTypeDefinition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cGroup.eContents().get(0);
		private final Group cGroup_0_0 = (Group)cGroup_0.eContents().get(0);
		private final Keyword cRangeKeyword_0_0_0 = (Keyword)cGroup_0_0.eContents().get(0);
		private final Assignment cRangeAssignment_0_0_1 = (Assignment)cGroup_0_0.eContents().get(1);
		private final RuleCall cRangeRangeParserRuleCall_0_0_1_0 = (RuleCall)cRangeAssignment_0_0_1.eContents().get(0);
		private final Keyword cUnitsKeyword_0_0_2 = (Keyword)cGroup_0_0.eContents().get(2);
		private final Assignment cPrimaryAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cPrimaryIdentifierParserRuleCall_1_0 = (RuleCall)cPrimaryAssignment_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cSecondaryAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cSecondaryPhysicalTypeDefinitionSecondaryParserRuleCall_3_0 = (RuleCall)cSecondaryAssignment_3.eContents().get(0);
		private final Keyword cEndKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cUnitsKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final RuleCall cIdentifierParserRuleCall_6 = (RuleCall)cGroup.eContents().get(6);
		
		/// *
		// *  range left_bound to right_bound
		// *  units
		// *    primary_unit_name
		// *    (secondary_unit_name = number primary_unit_name)*
		// * end units type_name
		// * / PhysicalTypeDefinition returns type::PhysicalTypeDefinition:
		//	=> ("range" range=Range "units") primary=Identifier ";" secondary+=PhysicalTypeDefinitionSecondary* "end" "units"
		//	Identifier?;
		public ParserRule getRule() { return rule; }

		//=> ("range" range=Range "units") primary=Identifier ";" secondary+=PhysicalTypeDefinitionSecondary* "end" "units"
		//Identifier?
		public Group getGroup() { return cGroup; }

		//=> ("range" range=Range "units")
		public Group getGroup_0() { return cGroup_0; }

		//"range" range=Range "units"
		public Group getGroup_0_0() { return cGroup_0_0; }

		//"range"
		public Keyword getRangeKeyword_0_0_0() { return cRangeKeyword_0_0_0; }

		//range=Range
		public Assignment getRangeAssignment_0_0_1() { return cRangeAssignment_0_0_1; }

		//Range
		public RuleCall getRangeRangeParserRuleCall_0_0_1_0() { return cRangeRangeParserRuleCall_0_0_1_0; }

		//"units"
		public Keyword getUnitsKeyword_0_0_2() { return cUnitsKeyword_0_0_2; }

		//primary=Identifier
		public Assignment getPrimaryAssignment_1() { return cPrimaryAssignment_1; }

		//Identifier
		public RuleCall getPrimaryIdentifierParserRuleCall_1_0() { return cPrimaryIdentifierParserRuleCall_1_0; }

		//";"
		public Keyword getSemicolonKeyword_2() { return cSemicolonKeyword_2; }

		//secondary+=PhysicalTypeDefinitionSecondary*
		public Assignment getSecondaryAssignment_3() { return cSecondaryAssignment_3; }

		//PhysicalTypeDefinitionSecondary
		public RuleCall getSecondaryPhysicalTypeDefinitionSecondaryParserRuleCall_3_0() { return cSecondaryPhysicalTypeDefinitionSecondaryParserRuleCall_3_0; }

		//"end"
		public Keyword getEndKeyword_4() { return cEndKeyword_4; }

		//"units"
		public Keyword getUnitsKeyword_5() { return cUnitsKeyword_5; }

		//Identifier?
		public RuleCall getIdentifierParserRuleCall_6() { return cIdentifierParserRuleCall_6; }
	}

	public class PhysicalTypeDefinitionSecondaryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PhysicalTypeDefinitionSecondary");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIdentifierParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNumberAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNumberABSTRACT_LITERALTerminalRuleCall_2_0 = (RuleCall)cNumberAssignment_2.eContents().get(0);
		private final Assignment cOfAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cOfNameParserRuleCall_3_0 = (RuleCall)cOfAssignment_3.eContents().get(0);
		private final Keyword cSemicolonKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//PhysicalTypeDefinitionSecondary returns type::PhysicalTypeDefinitionSecondary:
		//	name=Identifier "=" number=ABSTRACT_LITERAL? of=Name ";";
		public ParserRule getRule() { return rule; }

		//name=Identifier "=" number=ABSTRACT_LITERAL? of=Name ";"
		public Group getGroup() { return cGroup; }

		//name=Identifier
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//Identifier
		public RuleCall getNameIdentifierParserRuleCall_0_0() { return cNameIdentifierParserRuleCall_0_0; }

		//"="
		public Keyword getEqualsSignKeyword_1() { return cEqualsSignKeyword_1; }

		//number=ABSTRACT_LITERAL?
		public Assignment getNumberAssignment_2() { return cNumberAssignment_2; }

		//ABSTRACT_LITERAL
		public RuleCall getNumberABSTRACT_LITERALTerminalRuleCall_2_0() { return cNumberABSTRACT_LITERALTerminalRuleCall_2_0; }

		//of=Name
		public Assignment getOfAssignment_3() { return cOfAssignment_3; }

		//Name
		public RuleCall getOfNameParserRuleCall_3_0() { return cOfNameParserRuleCall_3_0; }

		//";"
		public Keyword getSemicolonKeyword_4() { return cSemicolonKeyword_4; }
	}

	public class UnconstrainedArrayTypeDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnconstrainedArrayTypeDefinition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cArrayKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cIndexAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cIndexNameParserRuleCall_2_0 = (RuleCall)cIndexAssignment_2.eContents().get(0);
		private final Keyword cRangeKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cLessThanSignGreaterThanSignKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cCommaKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Assignment cIndexAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cIndexNameParserRuleCall_5_1_0 = (RuleCall)cIndexAssignment_5_1.eContents().get(0);
		private final Keyword cRangeKeyword_5_2 = (Keyword)cGroup_5.eContents().get(2);
		private final Keyword cLessThanSignGreaterThanSignKeyword_5_3 = (Keyword)cGroup_5.eContents().get(3);
		private final Keyword cRightParenthesisKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Keyword cOfKeyword_7 = (Keyword)cGroup.eContents().get(7);
		private final Assignment cTypeAssignment_8 = (Assignment)cGroup.eContents().get(8);
		private final RuleCall cTypeSubtypeIndicationParserRuleCall_8_0 = (RuleCall)cTypeAssignment_8.eContents().get(0);
		
		//UnconstrainedArrayTypeDefinition returns type::UnconstrainedArrayTypeDefinition:
		//	"array" "(" index+=Name "range" "<>" ("," index+=Name "range" "<>")* ")" "of" type=SubtypeIndication;
		public ParserRule getRule() { return rule; }

		//"array" "(" index+=Name "range" "<>" ("," index+=Name "range" "<>")* ")" "of" type=SubtypeIndication
		public Group getGroup() { return cGroup; }

		//"array"
		public Keyword getArrayKeyword_0() { return cArrayKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//index+=Name
		public Assignment getIndexAssignment_2() { return cIndexAssignment_2; }

		//Name
		public RuleCall getIndexNameParserRuleCall_2_0() { return cIndexNameParserRuleCall_2_0; }

		//"range"
		public Keyword getRangeKeyword_3() { return cRangeKeyword_3; }

		//"<>"
		public Keyword getLessThanSignGreaterThanSignKeyword_4() { return cLessThanSignGreaterThanSignKeyword_4; }

		//("," index+=Name "range" "<>")*
		public Group getGroup_5() { return cGroup_5; }

		//","
		public Keyword getCommaKeyword_5_0() { return cCommaKeyword_5_0; }

		//index+=Name
		public Assignment getIndexAssignment_5_1() { return cIndexAssignment_5_1; }

		//Name
		public RuleCall getIndexNameParserRuleCall_5_1_0() { return cIndexNameParserRuleCall_5_1_0; }

		//"range"
		public Keyword getRangeKeyword_5_2() { return cRangeKeyword_5_2; }

		//"<>"
		public Keyword getLessThanSignGreaterThanSignKeyword_5_3() { return cLessThanSignGreaterThanSignKeyword_5_3; }

		//")"
		public Keyword getRightParenthesisKeyword_6() { return cRightParenthesisKeyword_6; }

		//"of"
		public Keyword getOfKeyword_7() { return cOfKeyword_7; }

		//type=SubtypeIndication
		public Assignment getTypeAssignment_8() { return cTypeAssignment_8; }

		//SubtypeIndication
		public RuleCall getTypeSubtypeIndicationParserRuleCall_8_0() { return cTypeSubtypeIndicationParserRuleCall_8_0; }
	}

	public class ConstrainedArrayTypeDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ConstrainedArrayTypeDefinition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cArrayKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cConstraintAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cConstraintIndexConstraintParserRuleCall_1_0 = (RuleCall)cConstraintAssignment_1.eContents().get(0);
		private final Keyword cOfKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cTypeAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cTypeSubtypeIndicationParserRuleCall_3_0 = (RuleCall)cTypeAssignment_3.eContents().get(0);
		
		//ConstrainedArrayTypeDefinition returns type::ConstrainedArrayTypeDefinition:
		//	"array" constraint=IndexConstraint "of" type=SubtypeIndication;
		public ParserRule getRule() { return rule; }

		//"array" constraint=IndexConstraint "of" type=SubtypeIndication
		public Group getGroup() { return cGroup; }

		//"array"
		public Keyword getArrayKeyword_0() { return cArrayKeyword_0; }

		//constraint=IndexConstraint
		public Assignment getConstraintAssignment_1() { return cConstraintAssignment_1; }

		//IndexConstraint
		public RuleCall getConstraintIndexConstraintParserRuleCall_1_0() { return cConstraintIndexConstraintParserRuleCall_1_0; }

		//"of"
		public Keyword getOfKeyword_2() { return cOfKeyword_2; }

		//type=SubtypeIndication
		public Assignment getTypeAssignment_3() { return cTypeAssignment_3; }

		//SubtypeIndication
		public RuleCall getTypeSubtypeIndicationParserRuleCall_3_0() { return cTypeSubtypeIndicationParserRuleCall_3_0; }
	}

	public class UnconstrainedArrayNatureDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnconstrainedArrayNatureDefinition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cArrayKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cIndexAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cIndexNameParserRuleCall_2_0 = (RuleCall)cIndexAssignment_2.eContents().get(0);
		private final Keyword cRangeKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cLessThanSignGreaterThanSignKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cCommaKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Assignment cIndexAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cIndexNameParserRuleCall_5_1_0 = (RuleCall)cIndexAssignment_5_1.eContents().get(0);
		private final Keyword cRangeKeyword_5_2 = (Keyword)cGroup_5.eContents().get(2);
		private final Keyword cLessThanSignGreaterThanSignKeyword_5_3 = (Keyword)cGroup_5.eContents().get(3);
		private final Keyword cRightParenthesisKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Keyword cOfKeyword_7 = (Keyword)cGroup.eContents().get(7);
		private final Assignment cNatureAssignment_8 = (Assignment)cGroup.eContents().get(8);
		private final RuleCall cNatureSubnatureIndicationParserRuleCall_8_0 = (RuleCall)cNatureAssignment_8.eContents().get(0);
		
		//UnconstrainedArrayNatureDefinition returns nature::UnconstrainedArrayNatureDefinition:
		//	"array" "(" index+=Name "range" "<>" ("," index+=Name "range" "<>")* ")" "of" nature=SubnatureIndication;
		public ParserRule getRule() { return rule; }

		//"array" "(" index+=Name "range" "<>" ("," index+=Name "range" "<>")* ")" "of" nature=SubnatureIndication
		public Group getGroup() { return cGroup; }

		//"array"
		public Keyword getArrayKeyword_0() { return cArrayKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//index+=Name
		public Assignment getIndexAssignment_2() { return cIndexAssignment_2; }

		//Name
		public RuleCall getIndexNameParserRuleCall_2_0() { return cIndexNameParserRuleCall_2_0; }

		//"range"
		public Keyword getRangeKeyword_3() { return cRangeKeyword_3; }

		//"<>"
		public Keyword getLessThanSignGreaterThanSignKeyword_4() { return cLessThanSignGreaterThanSignKeyword_4; }

		//("," index+=Name "range" "<>")*
		public Group getGroup_5() { return cGroup_5; }

		//","
		public Keyword getCommaKeyword_5_0() { return cCommaKeyword_5_0; }

		//index+=Name
		public Assignment getIndexAssignment_5_1() { return cIndexAssignment_5_1; }

		//Name
		public RuleCall getIndexNameParserRuleCall_5_1_0() { return cIndexNameParserRuleCall_5_1_0; }

		//"range"
		public Keyword getRangeKeyword_5_2() { return cRangeKeyword_5_2; }

		//"<>"
		public Keyword getLessThanSignGreaterThanSignKeyword_5_3() { return cLessThanSignGreaterThanSignKeyword_5_3; }

		//")"
		public Keyword getRightParenthesisKeyword_6() { return cRightParenthesisKeyword_6; }

		//"of"
		public Keyword getOfKeyword_7() { return cOfKeyword_7; }

		//nature=SubnatureIndication
		public Assignment getNatureAssignment_8() { return cNatureAssignment_8; }

		//SubnatureIndication
		public RuleCall getNatureSubnatureIndicationParserRuleCall_8_0() { return cNatureSubnatureIndicationParserRuleCall_8_0; }
	}

	public class ConstrainedArrayNatureDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ConstrainedArrayNatureDefinition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cArrayKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cConstraintAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cConstraintIndexConstraintParserRuleCall_1_0 = (RuleCall)cConstraintAssignment_1.eContents().get(0);
		private final Keyword cOfKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cNatureAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNatureSubnatureIndicationParserRuleCall_3_0 = (RuleCall)cNatureAssignment_3.eContents().get(0);
		
		//ConstrainedArrayNatureDefinition returns nature::ConstrainedArrayNatureDefinition:
		//	"array" constraint=IndexConstraint "of" nature=SubnatureIndication;
		public ParserRule getRule() { return rule; }

		//"array" constraint=IndexConstraint "of" nature=SubnatureIndication
		public Group getGroup() { return cGroup; }

		//"array"
		public Keyword getArrayKeyword_0() { return cArrayKeyword_0; }

		//constraint=IndexConstraint
		public Assignment getConstraintAssignment_1() { return cConstraintAssignment_1; }

		//IndexConstraint
		public RuleCall getConstraintIndexConstraintParserRuleCall_1_0() { return cConstraintIndexConstraintParserRuleCall_1_0; }

		//"of"
		public Keyword getOfKeyword_2() { return cOfKeyword_2; }

		//nature=SubnatureIndication
		public Assignment getNatureAssignment_3() { return cNatureAssignment_3; }

		//SubnatureIndication
		public RuleCall getNatureSubnatureIndicationParserRuleCall_3_0() { return cNatureSubnatureIndicationParserRuleCall_3_0; }
	}

	public class WaitStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "WaitStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cWaitStatementAction_0 = (Action)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cLabelAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cLabelLabelParserRuleCall_1_0_0 = (RuleCall)cLabelAssignment_1_0.eContents().get(0);
		private final Keyword cColonKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Keyword cWaitKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cOnKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cSensitivityAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cSensitivityMultiNameParserRuleCall_3_1_0 = (RuleCall)cSensitivityAssignment_3_1.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cUntilKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cUntilAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cUntilExpressionParserRuleCall_4_1_0 = (RuleCall)cUntilAssignment_4_1.eContents().get(0);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cForKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Assignment cTimeAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cTimeExpressionParserRuleCall_5_1_0 = (RuleCall)cTimeAssignment_5_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		/// *
		// * wait until condition;
		// * wait on signal_list;
		// * wait for time;
		// * wait;
		// * / WaitStatement returns statement::WaitStatement:
		//	{statement::WaitStatement} (label=Label ":")? "wait" ("on" sensitivity=MultiName)? ("until" until=Expression)? ("for"
		//	time=Expression)? ";";
		public ParserRule getRule() { return rule; }

		//{statement::WaitStatement} (label=Label ":")? "wait" ("on" sensitivity=MultiName)? ("until" until=Expression)? ("for"
		//time=Expression)? ";"
		public Group getGroup() { return cGroup; }

		//{statement::WaitStatement}
		public Action getWaitStatementAction_0() { return cWaitStatementAction_0; }

		//(label=Label ":")?
		public Group getGroup_1() { return cGroup_1; }

		//label=Label
		public Assignment getLabelAssignment_1_0() { return cLabelAssignment_1_0; }

		//Label
		public RuleCall getLabelLabelParserRuleCall_1_0_0() { return cLabelLabelParserRuleCall_1_0_0; }

		//":"
		public Keyword getColonKeyword_1_1() { return cColonKeyword_1_1; }

		//"wait"
		public Keyword getWaitKeyword_2() { return cWaitKeyword_2; }

		//("on" sensitivity=MultiName)?
		public Group getGroup_3() { return cGroup_3; }

		//"on"
		public Keyword getOnKeyword_3_0() { return cOnKeyword_3_0; }

		//sensitivity=MultiName
		public Assignment getSensitivityAssignment_3_1() { return cSensitivityAssignment_3_1; }

		//MultiName
		public RuleCall getSensitivityMultiNameParserRuleCall_3_1_0() { return cSensitivityMultiNameParserRuleCall_3_1_0; }

		//("until" until=Expression)?
		public Group getGroup_4() { return cGroup_4; }

		//"until"
		public Keyword getUntilKeyword_4_0() { return cUntilKeyword_4_0; }

		//until=Expression
		public Assignment getUntilAssignment_4_1() { return cUntilAssignment_4_1; }

		//Expression
		public RuleCall getUntilExpressionParserRuleCall_4_1_0() { return cUntilExpressionParserRuleCall_4_1_0; }

		//("for" time=Expression)?
		public Group getGroup_5() { return cGroup_5; }

		//"for"
		public Keyword getForKeyword_5_0() { return cForKeyword_5_0; }

		//time=Expression
		public Assignment getTimeAssignment_5_1() { return cTimeAssignment_5_1; }

		//Expression
		public RuleCall getTimeExpressionParserRuleCall_5_1_0() { return cTimeExpressionParserRuleCall_5_1_0; }

		//";"
		public Keyword getSemicolonKeyword_6() { return cSemicolonKeyword_6; }
	}

	public class WaveformElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Waveform");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cWaveformExpressionExpressionAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cAfterKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cAfterAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cAfterExpressionParserRuleCall_1_2_0 = (RuleCall)cAfterAssignment_1_2.eContents().get(0);
		
		/// *
		// * value_expression [ after time_expression ]
		// * / Waveform returns expression::Expression:
		//	Expression ({expression::WaveformExpression.expression=current} "after" after=Expression)?;
		public ParserRule getRule() { return rule; }

		//Expression ({expression::WaveformExpression.expression=current} "after" after=Expression)?
		public Group getGroup() { return cGroup; }

		//Expression
		public RuleCall getExpressionParserRuleCall_0() { return cExpressionParserRuleCall_0; }

		//({expression::WaveformExpression.expression=current} "after" after=Expression)?
		public Group getGroup_1() { return cGroup_1; }

		//{expression::WaveformExpression.expression=current}
		public Action getWaveformExpressionExpressionAction_1_0() { return cWaveformExpressionExpressionAction_1_0; }

		//"after"
		public Keyword getAfterKeyword_1_1() { return cAfterKeyword_1_1; }

		//after=Expression
		public Assignment getAfterAssignment_1_2() { return cAfterAssignment_1_2; }

		//Expression
		public RuleCall getAfterExpressionParserRuleCall_1_2_0() { return cAfterExpressionParserRuleCall_1_2_0; }
	}

	public class NullExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NullExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cNullExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cNullKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//NullExpression returns expression::NullExpression:
		//	{expression::NullExpression} "null";
		public ParserRule getRule() { return rule; }

		//{expression::NullExpression} "null"
		public Group getGroup() { return cGroup; }

		//{expression::NullExpression}
		public Action getNullExpressionAction_0() { return cNullExpressionAction_0; }

		//"null"
		public Keyword getNullKeyword_1() { return cNullKeyword_1; }
	}

	public class BitStringNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BitStringName");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBitStringExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueBIT_STRING_LITERALTerminalRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		
		//BitStringName returns expression::BitStringExpression:
		//	{expression::BitStringExpression} value=BIT_STRING_LITERAL;
		public ParserRule getRule() { return rule; }

		//{expression::BitStringExpression} value=BIT_STRING_LITERAL
		public Group getGroup() { return cGroup; }

		//{expression::BitStringExpression}
		public Action getBitStringExpressionAction_0() { return cBitStringExpressionAction_0; }

		//value=BIT_STRING_LITERAL
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }

		//BIT_STRING_LITERAL
		public RuleCall getValueBIT_STRING_LITERALTerminalRuleCall_1_0() { return cValueBIT_STRING_LITERALTerminalRuleCall_1_0; }
	}

	public class ValueExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ValueExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cUnitValueExpressionAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Assignment cValueAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cValueABSTRACT_LITERALTerminalRuleCall_0_1_0 = (RuleCall)cValueAssignment_0_1.eContents().get(0);
		private final Assignment cUnitAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cUnitNameParserRuleCall_0_2_0 = (RuleCall)cUnitAssignment_0_2.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cValueExpressionAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cValueAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cValueABSTRACT_LITERALTerminalRuleCall_1_1_0 = (RuleCall)cValueAssignment_1_1.eContents().get(0);
		
		//ValueExpression returns expression::ValueExpression:
		//	{expression::UnitValueExpression} value=ABSTRACT_LITERAL unit=Name | {expression::ValueExpression}
		//	value=ABSTRACT_LITERAL;
		public ParserRule getRule() { return rule; }

		//{expression::UnitValueExpression} value=ABSTRACT_LITERAL unit=Name | {expression::ValueExpression}
		//value=ABSTRACT_LITERAL
		public Alternatives getAlternatives() { return cAlternatives; }

		//{expression::UnitValueExpression} value=ABSTRACT_LITERAL unit=Name
		public Group getGroup_0() { return cGroup_0; }

		//{expression::UnitValueExpression}
		public Action getUnitValueExpressionAction_0_0() { return cUnitValueExpressionAction_0_0; }

		//value=ABSTRACT_LITERAL
		public Assignment getValueAssignment_0_1() { return cValueAssignment_0_1; }

		//ABSTRACT_LITERAL
		public RuleCall getValueABSTRACT_LITERALTerminalRuleCall_0_1_0() { return cValueABSTRACT_LITERALTerminalRuleCall_0_1_0; }

		//unit=Name
		public Assignment getUnitAssignment_0_2() { return cUnitAssignment_0_2; }

		//Name
		public RuleCall getUnitNameParserRuleCall_0_2_0() { return cUnitNameParserRuleCall_0_2_0; }

		//{expression::ValueExpression} value=ABSTRACT_LITERAL
		public Group getGroup_1() { return cGroup_1; }

		//{expression::ValueExpression}
		public Action getValueExpressionAction_1_0() { return cValueExpressionAction_1_0; }

		//value=ABSTRACT_LITERAL
		public Assignment getValueAssignment_1_1() { return cValueAssignment_1_1; }

		//ABSTRACT_LITERAL
		public RuleCall getValueABSTRACT_LITERALTerminalRuleCall_1_1_0() { return cValueABSTRACT_LITERALTerminalRuleCall_1_1_0; }
	}

	public class DesignatorNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DesignatorName");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIdentifierNameParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cStringNameParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//DesignatorName returns Name:
		//	IdentifierName | StringName;
		public ParserRule getRule() { return rule; }

		//IdentifierName | StringName
		public Alternatives getAlternatives() { return cAlternatives; }

		//IdentifierName
		public RuleCall getIdentifierNameParserRuleCall_0() { return cIdentifierNameParserRuleCall_0; }

		//StringName
		public RuleCall getStringNameParserRuleCall_1() { return cStringNameParserRuleCall_1; }
	}

	public class DesignatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Designator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIdentifierParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cSTRINGTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Designator:
		//	Identifier | STRING;
		public ParserRule getRule() { return rule; }

		//Identifier | STRING
		public Alternatives getAlternatives() { return cAlternatives; }

		//Identifier
		public RuleCall getIdentifierParserRuleCall_0() { return cIdentifierParserRuleCall_0; }

		//STRING
		public RuleCall getSTRINGTerminalRuleCall_1() { return cSTRINGTerminalRuleCall_1; }
	}

	public class IdentifierElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Identifier");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cEXTENDED_IDENTIFIERTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Identifier:
		//	ID | EXTENDED_IDENTIFIER;
		public ParserRule getRule() { return rule; }

		//ID | EXTENDED_IDENTIFIER
		public Alternatives getAlternatives() { return cAlternatives; }

		//ID
		public RuleCall getIDTerminalRuleCall_0() { return cIDTerminalRuleCall_0; }

		//EXTENDED_IDENTIFIER
		public RuleCall getEXTENDED_IDENTIFIERTerminalRuleCall_1() { return cEXTENDED_IDENTIFIERTerminalRuleCall_1; }
	}
	
	
	public class SignalKindElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "SignalKind");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cREGISTEREnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cREGISTERRegisterKeyword_0_0 = (Keyword)cREGISTEREnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cBUSEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cBUSBusKeyword_1_0 = (Keyword)cBUSEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum SignalKind returns declaration::SignalKind:
		//	REGISTER="register" | BUS="bus";
		public EnumRule getRule() { return rule; }

		//REGISTER="register" | BUS="bus"
		public Alternatives getAlternatives() { return cAlternatives; }

		//REGISTER="register"
		public EnumLiteralDeclaration getREGISTEREnumLiteralDeclaration_0() { return cREGISTEREnumLiteralDeclaration_0; }

		//"register"
		public Keyword getREGISTERRegisterKeyword_0_0() { return cREGISTERRegisterKeyword_0_0; }

		//BUS="bus"
		public EnumLiteralDeclaration getBUSEnumLiteralDeclaration_1() { return cBUSEnumLiteralDeclaration_1; }

		//"bus"
		public Keyword getBUSBusKeyword_1_0() { return cBUSBusKeyword_1_0; }
	}

	public class RangeDirectionElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "RangeDirection");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cTOEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cTOToKeyword_0_0 = (Keyword)cTOEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cDOWNTOEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cDOWNTODowntoKeyword_1_0 = (Keyword)cDOWNTOEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum RangeDirection returns expression::RangeDirection:
		//	TO="to" | DOWNTO="downto";
		public EnumRule getRule() { return rule; }

		//TO="to" | DOWNTO="downto"
		public Alternatives getAlternatives() { return cAlternatives; }

		//TO="to"
		public EnumLiteralDeclaration getTOEnumLiteralDeclaration_0() { return cTOEnumLiteralDeclaration_0; }

		//"to"
		public Keyword getTOToKeyword_0_0() { return cTOToKeyword_0_0; }

		//DOWNTO="downto"
		public EnumLiteralDeclaration getDOWNTOEnumLiteralDeclaration_1() { return cDOWNTOEnumLiteralDeclaration_1; }

		//"downto"
		public Keyword getDOWNTODowntoKeyword_1_0() { return cDOWNTODowntoKeyword_1_0; }
	}

	public class ModeElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "Mode");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cINEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cINInKeyword_0_0 = (Keyword)cINEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cOUTEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cOUTOutKeyword_1_0 = (Keyword)cOUTEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cINOUTEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cINOUTInoutKeyword_2_0 = (Keyword)cINOUTEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cBUFFEREnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cBUFFERBufferKeyword_3_0 = (Keyword)cBUFFEREnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cLINKAGEEnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cLINKAGELinkageKeyword_4_0 = (Keyword)cLINKAGEEnumLiteralDeclaration_4.eContents().get(0);
		
		//enum Mode returns declaration::Mode:
		//	IN="in" | OUT="out" | INOUT="inout" | BUFFER="buffer" | LINKAGE="linkage";
		public EnumRule getRule() { return rule; }

		//IN="in" | OUT="out" | INOUT="inout" | BUFFER="buffer" | LINKAGE="linkage"
		public Alternatives getAlternatives() { return cAlternatives; }

		//IN="in"
		public EnumLiteralDeclaration getINEnumLiteralDeclaration_0() { return cINEnumLiteralDeclaration_0; }

		//"in"
		public Keyword getINInKeyword_0_0() { return cINInKeyword_0_0; }

		//OUT="out"
		public EnumLiteralDeclaration getOUTEnumLiteralDeclaration_1() { return cOUTEnumLiteralDeclaration_1; }

		//"out"
		public Keyword getOUTOutKeyword_1_0() { return cOUTOutKeyword_1_0; }

		//INOUT="inout"
		public EnumLiteralDeclaration getINOUTEnumLiteralDeclaration_2() { return cINOUTEnumLiteralDeclaration_2; }

		//"inout"
		public Keyword getINOUTInoutKeyword_2_0() { return cINOUTInoutKeyword_2_0; }

		//BUFFER="buffer"
		public EnumLiteralDeclaration getBUFFEREnumLiteralDeclaration_3() { return cBUFFEREnumLiteralDeclaration_3; }

		//"buffer"
		public Keyword getBUFFERBufferKeyword_3_0() { return cBUFFERBufferKeyword_3_0; }

		//LINKAGE="linkage"
		public EnumLiteralDeclaration getLINKAGEEnumLiteralDeclaration_4() { return cLINKAGEEnumLiteralDeclaration_4; }

		//"linkage"
		public Keyword getLINKAGELinkageKeyword_4_0() { return cLINKAGELinkageKeyword_4_0; }
	}

	public class UnaryOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "UnaryOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cABSEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cABSAbsKeyword_0_0 = (Keyword)cABSEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cNOTEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cNOTNotKeyword_1_0 = (Keyword)cNOTEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum UnaryOperator returns expression::UnaryOperator:
		//	ABS="abs" | NOT="not";
		public EnumRule getRule() { return rule; }

		//ABS="abs" | NOT="not"
		public Alternatives getAlternatives() { return cAlternatives; }

		//ABS="abs"
		public EnumLiteralDeclaration getABSEnumLiteralDeclaration_0() { return cABSEnumLiteralDeclaration_0; }

		//"abs"
		public Keyword getABSAbsKeyword_0_0() { return cABSAbsKeyword_0_0; }

		//NOT="not"
		public EnumLiteralDeclaration getNOTEnumLiteralDeclaration_1() { return cNOTEnumLiteralDeclaration_1; }

		//"not"
		public Keyword getNOTNotKeyword_1_0() { return cNOTNotKeyword_1_0; }
	}

	public class MultiplyingOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "MultiplyingOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cMULEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cMULAsteriskKeyword_0_0 = (Keyword)cMULEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cDIVEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cDIVSolidusKeyword_1_0 = (Keyword)cDIVEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cMODEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cMODModKeyword_2_0 = (Keyword)cMODEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cREMEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cREMRemKeyword_3_0 = (Keyword)cREMEnumLiteralDeclaration_3.eContents().get(0);
		
		//enum MultiplyingOperator returns expression::MultiplyingOperator:
		//	MUL="*" | DIV="/" | MOD="mod" | REM="rem";
		public EnumRule getRule() { return rule; }

		//MUL="*" | DIV="/" | MOD="mod" | REM="rem"
		public Alternatives getAlternatives() { return cAlternatives; }

		//MUL="*"
		public EnumLiteralDeclaration getMULEnumLiteralDeclaration_0() { return cMULEnumLiteralDeclaration_0; }

		//"*"
		public Keyword getMULAsteriskKeyword_0_0() { return cMULAsteriskKeyword_0_0; }

		//DIV="/"
		public EnumLiteralDeclaration getDIVEnumLiteralDeclaration_1() { return cDIVEnumLiteralDeclaration_1; }

		//"/"
		public Keyword getDIVSolidusKeyword_1_0() { return cDIVSolidusKeyword_1_0; }

		//MOD="mod"
		public EnumLiteralDeclaration getMODEnumLiteralDeclaration_2() { return cMODEnumLiteralDeclaration_2; }

		//"mod"
		public Keyword getMODModKeyword_2_0() { return cMODModKeyword_2_0; }

		//REM="rem"
		public EnumLiteralDeclaration getREMEnumLiteralDeclaration_3() { return cREMEnumLiteralDeclaration_3; }

		//"rem"
		public Keyword getREMRemKeyword_3_0() { return cREMRemKeyword_3_0; }
	}

	public class ShiftOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "ShiftOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cSLLEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cSLLSllKeyword_0_0 = (Keyword)cSLLEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cSRLEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cSRLSrlKeyword_1_0 = (Keyword)cSRLEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cSLAEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cSLASlaKeyword_2_0 = (Keyword)cSLAEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cSRAEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cSRASraKeyword_3_0 = (Keyword)cSRAEnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cROLEnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cROLRolKeyword_4_0 = (Keyword)cROLEnumLiteralDeclaration_4.eContents().get(0);
		private final EnumLiteralDeclaration cROREnumLiteralDeclaration_5 = (EnumLiteralDeclaration)cAlternatives.eContents().get(5);
		private final Keyword cRORRorKeyword_5_0 = (Keyword)cROREnumLiteralDeclaration_5.eContents().get(0);
		
		//enum ShiftOperator returns expression::ShiftOperator:
		//	SLL="sll" | SRL="srl" | SLA="sla" | SRA="sra" | ROL="rol" | ROR="ror";
		public EnumRule getRule() { return rule; }

		//SLL="sll" | SRL="srl" | SLA="sla" | SRA="sra" | ROL="rol" | ROR="ror"
		public Alternatives getAlternatives() { return cAlternatives; }

		//SLL="sll"
		public EnumLiteralDeclaration getSLLEnumLiteralDeclaration_0() { return cSLLEnumLiteralDeclaration_0; }

		//"sll"
		public Keyword getSLLSllKeyword_0_0() { return cSLLSllKeyword_0_0; }

		//SRL="srl"
		public EnumLiteralDeclaration getSRLEnumLiteralDeclaration_1() { return cSRLEnumLiteralDeclaration_1; }

		//"srl"
		public Keyword getSRLSrlKeyword_1_0() { return cSRLSrlKeyword_1_0; }

		//SLA="sla"
		public EnumLiteralDeclaration getSLAEnumLiteralDeclaration_2() { return cSLAEnumLiteralDeclaration_2; }

		//"sla"
		public Keyword getSLASlaKeyword_2_0() { return cSLASlaKeyword_2_0; }

		//SRA="sra"
		public EnumLiteralDeclaration getSRAEnumLiteralDeclaration_3() { return cSRAEnumLiteralDeclaration_3; }

		//"sra"
		public Keyword getSRASraKeyword_3_0() { return cSRASraKeyword_3_0; }

		//ROL="rol"
		public EnumLiteralDeclaration getROLEnumLiteralDeclaration_4() { return cROLEnumLiteralDeclaration_4; }

		//"rol"
		public Keyword getROLRolKeyword_4_0() { return cROLRolKeyword_4_0; }

		//ROR="ror"
		public EnumLiteralDeclaration getROREnumLiteralDeclaration_5() { return cROREnumLiteralDeclaration_5; }

		//"ror"
		public Keyword getRORRorKeyword_5_0() { return cRORRorKeyword_5_0; }
	}

	public class RelationalOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "RelationalOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cEQEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cEQEqualsSignKeyword_0_0 = (Keyword)cEQEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cNEQEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cNEQSolidusEqualsSignKeyword_1_0 = (Keyword)cNEQEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cLOWERTHANEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cLOWERTHANLessThanSignKeyword_2_0 = (Keyword)cLOWERTHANEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cLEEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cLELessThanSignEqualsSignKeyword_3_0 = (Keyword)cLEEnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cGREATERTHANEnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cGREATERTHANGreaterThanSignKeyword_4_0 = (Keyword)cGREATERTHANEnumLiteralDeclaration_4.eContents().get(0);
		private final EnumLiteralDeclaration cGEEnumLiteralDeclaration_5 = (EnumLiteralDeclaration)cAlternatives.eContents().get(5);
		private final Keyword cGEGreaterThanSignEqualsSignKeyword_5_0 = (Keyword)cGEEnumLiteralDeclaration_5.eContents().get(0);
		
		//enum RelationalOperator returns expression::RelationalOperator:
		//	EQ="=" | NEQ="/=" | LOWERTHAN="<" | LE="<=" | GREATERTHAN=">" | GE=">=";
		public EnumRule getRule() { return rule; }

		//EQ="=" | NEQ="/=" | LOWERTHAN="<" | LE="<=" | GREATERTHAN=">" | GE=">="
		public Alternatives getAlternatives() { return cAlternatives; }

		//EQ="="
		public EnumLiteralDeclaration getEQEnumLiteralDeclaration_0() { return cEQEnumLiteralDeclaration_0; }

		//"="
		public Keyword getEQEqualsSignKeyword_0_0() { return cEQEqualsSignKeyword_0_0; }

		//NEQ="/="
		public EnumLiteralDeclaration getNEQEnumLiteralDeclaration_1() { return cNEQEnumLiteralDeclaration_1; }

		//"/="
		public Keyword getNEQSolidusEqualsSignKeyword_1_0() { return cNEQSolidusEqualsSignKeyword_1_0; }

		//LOWERTHAN="<"
		public EnumLiteralDeclaration getLOWERTHANEnumLiteralDeclaration_2() { return cLOWERTHANEnumLiteralDeclaration_2; }

		//"<"
		public Keyword getLOWERTHANLessThanSignKeyword_2_0() { return cLOWERTHANLessThanSignKeyword_2_0; }

		//LE="<="
		public EnumLiteralDeclaration getLEEnumLiteralDeclaration_3() { return cLEEnumLiteralDeclaration_3; }

		//"<="
		public Keyword getLELessThanSignEqualsSignKeyword_3_0() { return cLELessThanSignEqualsSignKeyword_3_0; }

		//GREATERTHAN=">"
		public EnumLiteralDeclaration getGREATERTHANEnumLiteralDeclaration_4() { return cGREATERTHANEnumLiteralDeclaration_4; }

		//">"
		public Keyword getGREATERTHANGreaterThanSignKeyword_4_0() { return cGREATERTHANGreaterThanSignKeyword_4_0; }

		//GE=">="
		public EnumLiteralDeclaration getGEEnumLiteralDeclaration_5() { return cGEEnumLiteralDeclaration_5; }

		//">="
		public Keyword getGEGreaterThanSignEqualsSignKeyword_5_0() { return cGEGreaterThanSignEqualsSignKeyword_5_0; }
	}

	public class LogicalOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "LogicalOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cANDEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cANDAndKeyword_0_0 = (Keyword)cANDEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cOREnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cOROrKeyword_1_0 = (Keyword)cOREnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cNANDEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cNANDNandKeyword_2_0 = (Keyword)cNANDEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cNOREnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cNORNorKeyword_3_0 = (Keyword)cNOREnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cXOREnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cXORXorKeyword_4_0 = (Keyword)cXOREnumLiteralDeclaration_4.eContents().get(0);
		private final EnumLiteralDeclaration cXNOREnumLiteralDeclaration_5 = (EnumLiteralDeclaration)cAlternatives.eContents().get(5);
		private final Keyword cXNORXnorKeyword_5_0 = (Keyword)cXNOREnumLiteralDeclaration_5.eContents().get(0);
		
		//enum LogicalOperator returns expression::LogicalOperator:
		//	AND="and" | OR="or" | NAND="nand" | NOR="nor" | XOR="xor" | XNOR="xnor";
		public EnumRule getRule() { return rule; }

		//AND="and" | OR="or" | NAND="nand" | NOR="nor" | XOR="xor" | XNOR="xnor"
		public Alternatives getAlternatives() { return cAlternatives; }

		//AND="and"
		public EnumLiteralDeclaration getANDEnumLiteralDeclaration_0() { return cANDEnumLiteralDeclaration_0; }

		//"and"
		public Keyword getANDAndKeyword_0_0() { return cANDAndKeyword_0_0; }

		//OR="or"
		public EnumLiteralDeclaration getOREnumLiteralDeclaration_1() { return cOREnumLiteralDeclaration_1; }

		//"or"
		public Keyword getOROrKeyword_1_0() { return cOROrKeyword_1_0; }

		//NAND="nand"
		public EnumLiteralDeclaration getNANDEnumLiteralDeclaration_2() { return cNANDEnumLiteralDeclaration_2; }

		//"nand"
		public Keyword getNANDNandKeyword_2_0() { return cNANDNandKeyword_2_0; }

		//NOR="nor"
		public EnumLiteralDeclaration getNOREnumLiteralDeclaration_3() { return cNOREnumLiteralDeclaration_3; }

		//"nor"
		public Keyword getNORNorKeyword_3_0() { return cNORNorKeyword_3_0; }

		//XOR="xor"
		public EnumLiteralDeclaration getXOREnumLiteralDeclaration_4() { return cXOREnumLiteralDeclaration_4; }

		//"xor"
		public Keyword getXORXorKeyword_4_0() { return cXORXorKeyword_4_0; }

		//XNOR="xnor"
		public EnumLiteralDeclaration getXNOREnumLiteralDeclaration_5() { return cXNOREnumLiteralDeclaration_5; }

		//"xnor"
		public Keyword getXNORXnorKeyword_5_0() { return cXNORXnorKeyword_5_0; }
	}

	public class AddingOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "AddingOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cPLUSEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cPLUSPlusSignKeyword_0_0 = (Keyword)cPLUSEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cMINUSEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cMINUSHyphenMinusKeyword_1_0 = (Keyword)cMINUSEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cAMPERSANDEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cAMPERSANDAmpersandKeyword_2_0 = (Keyword)cAMPERSANDEnumLiteralDeclaration_2.eContents().get(0);
		
		//enum AddingOperator returns expression::AddingOperator:
		//	PLUS="+" | MINUS="-" | AMPERSAND="&";
		public EnumRule getRule() { return rule; }

		//PLUS="+" | MINUS="-" | AMPERSAND="&"
		public Alternatives getAlternatives() { return cAlternatives; }

		//PLUS="+"
		public EnumLiteralDeclaration getPLUSEnumLiteralDeclaration_0() { return cPLUSEnumLiteralDeclaration_0; }

		//"+"
		public Keyword getPLUSPlusSignKeyword_0_0() { return cPLUSPlusSignKeyword_0_0; }

		//MINUS="-"
		public EnumLiteralDeclaration getMINUSEnumLiteralDeclaration_1() { return cMINUSEnumLiteralDeclaration_1; }

		//"-"
		public Keyword getMINUSHyphenMinusKeyword_1_0() { return cMINUSHyphenMinusKeyword_1_0; }

		//AMPERSAND="&"
		public EnumLiteralDeclaration getAMPERSANDEnumLiteralDeclaration_2() { return cAMPERSANDEnumLiteralDeclaration_2; }

		//"&"
		public Keyword getAMPERSANDAmpersandKeyword_2_0() { return cAMPERSANDAmpersandKeyword_2_0; }
	}

	public class SignElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "Sign");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cPLUSEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cPLUSPlusSignKeyword_0_0 = (Keyword)cPLUSEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cMINUSEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cMINUSHyphenMinusKeyword_1_0 = (Keyword)cMINUSEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum Sign returns expression::Sign:
		//	PLUS="+" | MINUS="-";
		public EnumRule getRule() { return rule; }

		//PLUS="+" | MINUS="-"
		public Alternatives getAlternatives() { return cAlternatives; }

		//PLUS="+"
		public EnumLiteralDeclaration getPLUSEnumLiteralDeclaration_0() { return cPLUSEnumLiteralDeclaration_0; }

		//"+"
		public Keyword getPLUSPlusSignKeyword_0_0() { return cPLUSPlusSignKeyword_0_0; }

		//MINUS="-"
		public EnumLiteralDeclaration getMINUSEnumLiteralDeclaration_1() { return cMINUSEnumLiteralDeclaration_1; }

		//"-"
		public Keyword getMINUSHyphenMinusKeyword_1_0() { return cMINUSHyphenMinusKeyword_1_0; }
	}

	public class PurityElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "Purity");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cPUREEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cPUREPureKeyword_0_0 = (Keyword)cPUREEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cIMPUREEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cIMPUREImpureKeyword_1_0 = (Keyword)cIMPUREEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum Purity returns declaration::Purity:
		//	PURE="pure" | IMPURE="impure";
		public EnumRule getRule() { return rule; }

		//PURE="pure" | IMPURE="impure"
		public Alternatives getAlternatives() { return cAlternatives; }

		//PURE="pure"
		public EnumLiteralDeclaration getPUREEnumLiteralDeclaration_0() { return cPUREEnumLiteralDeclaration_0; }

		//"pure"
		public Keyword getPUREPureKeyword_0_0() { return cPUREPureKeyword_0_0; }

		//IMPURE="impure"
		public EnumLiteralDeclaration getIMPUREEnumLiteralDeclaration_1() { return cIMPUREEnumLiteralDeclaration_1; }

		//"impure"
		public Keyword getIMPUREImpureKeyword_1_0() { return cIMPUREImpureKeyword_1_0; }
	}

	public class EntityClassElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "EntityClass");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cENTITYEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cENTITYEntityKeyword_0_0 = (Keyword)cENTITYEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cARCHITECTUREEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cARCHITECTUREArchitectureKeyword_1_0 = (Keyword)cARCHITECTUREEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cCONFIGURATIONEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cCONFIGURATIONConfigurationKeyword_2_0 = (Keyword)cCONFIGURATIONEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cPROCEDUREEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cPROCEDUREProcedureKeyword_3_0 = (Keyword)cPROCEDUREEnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cFUNCTIONEnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cFUNCTIONFunctionKeyword_4_0 = (Keyword)cFUNCTIONEnumLiteralDeclaration_4.eContents().get(0);
		private final EnumLiteralDeclaration cPACKAGEEnumLiteralDeclaration_5 = (EnumLiteralDeclaration)cAlternatives.eContents().get(5);
		private final Keyword cPACKAGEPackageKeyword_5_0 = (Keyword)cPACKAGEEnumLiteralDeclaration_5.eContents().get(0);
		private final EnumLiteralDeclaration cTYPEEnumLiteralDeclaration_6 = (EnumLiteralDeclaration)cAlternatives.eContents().get(6);
		private final Keyword cTYPETypeKeyword_6_0 = (Keyword)cTYPEEnumLiteralDeclaration_6.eContents().get(0);
		private final EnumLiteralDeclaration cSUBTYPEEnumLiteralDeclaration_7 = (EnumLiteralDeclaration)cAlternatives.eContents().get(7);
		private final Keyword cSUBTYPESubtypeKeyword_7_0 = (Keyword)cSUBTYPEEnumLiteralDeclaration_7.eContents().get(0);
		private final EnumLiteralDeclaration cCONSTANTEnumLiteralDeclaration_8 = (EnumLiteralDeclaration)cAlternatives.eContents().get(8);
		private final Keyword cCONSTANTConstantKeyword_8_0 = (Keyword)cCONSTANTEnumLiteralDeclaration_8.eContents().get(0);
		private final EnumLiteralDeclaration cSIGNALEnumLiteralDeclaration_9 = (EnumLiteralDeclaration)cAlternatives.eContents().get(9);
		private final Keyword cSIGNALSignalKeyword_9_0 = (Keyword)cSIGNALEnumLiteralDeclaration_9.eContents().get(0);
		private final EnumLiteralDeclaration cVARIABLEEnumLiteralDeclaration_10 = (EnumLiteralDeclaration)cAlternatives.eContents().get(10);
		private final Keyword cVARIABLEVariableKeyword_10_0 = (Keyword)cVARIABLEEnumLiteralDeclaration_10.eContents().get(0);
		private final EnumLiteralDeclaration cCOMPONENTEnumLiteralDeclaration_11 = (EnumLiteralDeclaration)cAlternatives.eContents().get(11);
		private final Keyword cCOMPONENTComponentKeyword_11_0 = (Keyword)cCOMPONENTEnumLiteralDeclaration_11.eContents().get(0);
		private final EnumLiteralDeclaration cLABELEnumLiteralDeclaration_12 = (EnumLiteralDeclaration)cAlternatives.eContents().get(12);
		private final Keyword cLABELLabelKeyword_12_0 = (Keyword)cLABELEnumLiteralDeclaration_12.eContents().get(0);
		private final EnumLiteralDeclaration cLITERALEnumLiteralDeclaration_13 = (EnumLiteralDeclaration)cAlternatives.eContents().get(13);
		private final Keyword cLITERALLiteralKeyword_13_0 = (Keyword)cLITERALEnumLiteralDeclaration_13.eContents().get(0);
		private final EnumLiteralDeclaration cUNITSEnumLiteralDeclaration_14 = (EnumLiteralDeclaration)cAlternatives.eContents().get(14);
		private final Keyword cUNITSUnitsKeyword_14_0 = (Keyword)cUNITSEnumLiteralDeclaration_14.eContents().get(0);
		private final EnumLiteralDeclaration cGROUPEnumLiteralDeclaration_15 = (EnumLiteralDeclaration)cAlternatives.eContents().get(15);
		private final Keyword cGROUPGroupKeyword_15_0 = (Keyword)cGROUPEnumLiteralDeclaration_15.eContents().get(0);
		private final EnumLiteralDeclaration cFILEEnumLiteralDeclaration_16 = (EnumLiteralDeclaration)cAlternatives.eContents().get(16);
		private final Keyword cFILEFileKeyword_16_0 = (Keyword)cFILEEnumLiteralDeclaration_16.eContents().get(0);
		private final EnumLiteralDeclaration cNATUREEnumLiteralDeclaration_17 = (EnumLiteralDeclaration)cAlternatives.eContents().get(17);
		private final Keyword cNATURENatureKeyword_17_0 = (Keyword)cNATUREEnumLiteralDeclaration_17.eContents().get(0);
		private final EnumLiteralDeclaration cSUBNATUREEnumLiteralDeclaration_18 = (EnumLiteralDeclaration)cAlternatives.eContents().get(18);
		private final Keyword cSUBNATURESubnatureKeyword_18_0 = (Keyword)cSUBNATUREEnumLiteralDeclaration_18.eContents().get(0);
		private final EnumLiteralDeclaration cQUANTITYEnumLiteralDeclaration_19 = (EnumLiteralDeclaration)cAlternatives.eContents().get(19);
		private final Keyword cQUANTITYQuantityKeyword_19_0 = (Keyword)cQUANTITYEnumLiteralDeclaration_19.eContents().get(0);
		private final EnumLiteralDeclaration cTERMINALEnumLiteralDeclaration_20 = (EnumLiteralDeclaration)cAlternatives.eContents().get(20);
		private final Keyword cTERMINALTerminalKeyword_20_0 = (Keyword)cTERMINALEnumLiteralDeclaration_20.eContents().get(0);
		
		//enum EntityClass returns declaration::EntityClass:
		//	ENTITY="entity" | ARCHITECTURE="architecture" | CONFIGURATION="configuration" | PROCEDURE="procedure" |
		//	FUNCTION="function" | PACKAGE="package" | TYPE="type" | SUBTYPE="subtype" | CONSTANT="constant" | SIGNAL="signal" |
		//	VARIABLE="variable" | COMPONENT="component" | LABEL="label" | LITERAL="literal" | UNITS="units" | GROUP="group" |
		//	FILE="file" | NATURE="nature" | SUBNATURE="subnature" | QUANTITY="quantity" | TERMINAL="terminal";
		public EnumRule getRule() { return rule; }

		//ENTITY="entity" | ARCHITECTURE="architecture" | CONFIGURATION="configuration" | PROCEDURE="procedure" |
		//FUNCTION="function" | PACKAGE="package" | TYPE="type" | SUBTYPE="subtype" | CONSTANT="constant" | SIGNAL="signal" |
		//VARIABLE="variable" | COMPONENT="component" | LABEL="label" | LITERAL="literal" | UNITS="units" | GROUP="group" |
		//FILE="file" | NATURE="nature" | SUBNATURE="subnature" | QUANTITY="quantity" | TERMINAL="terminal"
		public Alternatives getAlternatives() { return cAlternatives; }

		//ENTITY="entity"
		public EnumLiteralDeclaration getENTITYEnumLiteralDeclaration_0() { return cENTITYEnumLiteralDeclaration_0; }

		//"entity"
		public Keyword getENTITYEntityKeyword_0_0() { return cENTITYEntityKeyword_0_0; }

		//ARCHITECTURE="architecture"
		public EnumLiteralDeclaration getARCHITECTUREEnumLiteralDeclaration_1() { return cARCHITECTUREEnumLiteralDeclaration_1; }

		//"architecture"
		public Keyword getARCHITECTUREArchitectureKeyword_1_0() { return cARCHITECTUREArchitectureKeyword_1_0; }

		//CONFIGURATION="configuration"
		public EnumLiteralDeclaration getCONFIGURATIONEnumLiteralDeclaration_2() { return cCONFIGURATIONEnumLiteralDeclaration_2; }

		//"configuration"
		public Keyword getCONFIGURATIONConfigurationKeyword_2_0() { return cCONFIGURATIONConfigurationKeyword_2_0; }

		//PROCEDURE="procedure"
		public EnumLiteralDeclaration getPROCEDUREEnumLiteralDeclaration_3() { return cPROCEDUREEnumLiteralDeclaration_3; }

		//"procedure"
		public Keyword getPROCEDUREProcedureKeyword_3_0() { return cPROCEDUREProcedureKeyword_3_0; }

		//FUNCTION="function"
		public EnumLiteralDeclaration getFUNCTIONEnumLiteralDeclaration_4() { return cFUNCTIONEnumLiteralDeclaration_4; }

		//"function"
		public Keyword getFUNCTIONFunctionKeyword_4_0() { return cFUNCTIONFunctionKeyword_4_0; }

		//PACKAGE="package"
		public EnumLiteralDeclaration getPACKAGEEnumLiteralDeclaration_5() { return cPACKAGEEnumLiteralDeclaration_5; }

		//"package"
		public Keyword getPACKAGEPackageKeyword_5_0() { return cPACKAGEPackageKeyword_5_0; }

		//TYPE="type"
		public EnumLiteralDeclaration getTYPEEnumLiteralDeclaration_6() { return cTYPEEnumLiteralDeclaration_6; }

		//"type"
		public Keyword getTYPETypeKeyword_6_0() { return cTYPETypeKeyword_6_0; }

		//SUBTYPE="subtype"
		public EnumLiteralDeclaration getSUBTYPEEnumLiteralDeclaration_7() { return cSUBTYPEEnumLiteralDeclaration_7; }

		//"subtype"
		public Keyword getSUBTYPESubtypeKeyword_7_0() { return cSUBTYPESubtypeKeyword_7_0; }

		//CONSTANT="constant"
		public EnumLiteralDeclaration getCONSTANTEnumLiteralDeclaration_8() { return cCONSTANTEnumLiteralDeclaration_8; }

		//"constant"
		public Keyword getCONSTANTConstantKeyword_8_0() { return cCONSTANTConstantKeyword_8_0; }

		//SIGNAL="signal"
		public EnumLiteralDeclaration getSIGNALEnumLiteralDeclaration_9() { return cSIGNALEnumLiteralDeclaration_9; }

		//"signal"
		public Keyword getSIGNALSignalKeyword_9_0() { return cSIGNALSignalKeyword_9_0; }

		//VARIABLE="variable"
		public EnumLiteralDeclaration getVARIABLEEnumLiteralDeclaration_10() { return cVARIABLEEnumLiteralDeclaration_10; }

		//"variable"
		public Keyword getVARIABLEVariableKeyword_10_0() { return cVARIABLEVariableKeyword_10_0; }

		//COMPONENT="component"
		public EnumLiteralDeclaration getCOMPONENTEnumLiteralDeclaration_11() { return cCOMPONENTEnumLiteralDeclaration_11; }

		//"component"
		public Keyword getCOMPONENTComponentKeyword_11_0() { return cCOMPONENTComponentKeyword_11_0; }

		//LABEL="label"
		public EnumLiteralDeclaration getLABELEnumLiteralDeclaration_12() { return cLABELEnumLiteralDeclaration_12; }

		//"label"
		public Keyword getLABELLabelKeyword_12_0() { return cLABELLabelKeyword_12_0; }

		//LITERAL="literal"
		public EnumLiteralDeclaration getLITERALEnumLiteralDeclaration_13() { return cLITERALEnumLiteralDeclaration_13; }

		//"literal"
		public Keyword getLITERALLiteralKeyword_13_0() { return cLITERALLiteralKeyword_13_0; }

		//UNITS="units"
		public EnumLiteralDeclaration getUNITSEnumLiteralDeclaration_14() { return cUNITSEnumLiteralDeclaration_14; }

		//"units"
		public Keyword getUNITSUnitsKeyword_14_0() { return cUNITSUnitsKeyword_14_0; }

		//GROUP="group"
		public EnumLiteralDeclaration getGROUPEnumLiteralDeclaration_15() { return cGROUPEnumLiteralDeclaration_15; }

		//"group"
		public Keyword getGROUPGroupKeyword_15_0() { return cGROUPGroupKeyword_15_0; }

		//FILE="file"
		public EnumLiteralDeclaration getFILEEnumLiteralDeclaration_16() { return cFILEEnumLiteralDeclaration_16; }

		//"file"
		public Keyword getFILEFileKeyword_16_0() { return cFILEFileKeyword_16_0; }

		//NATURE="nature"
		public EnumLiteralDeclaration getNATUREEnumLiteralDeclaration_17() { return cNATUREEnumLiteralDeclaration_17; }

		//"nature"
		public Keyword getNATURENatureKeyword_17_0() { return cNATURENatureKeyword_17_0; }

		//SUBNATURE="subnature"
		public EnumLiteralDeclaration getSUBNATUREEnumLiteralDeclaration_18() { return cSUBNATUREEnumLiteralDeclaration_18; }

		//"subnature"
		public Keyword getSUBNATURESubnatureKeyword_18_0() { return cSUBNATURESubnatureKeyword_18_0; }

		//QUANTITY="quantity"
		public EnumLiteralDeclaration getQUANTITYEnumLiteralDeclaration_19() { return cQUANTITYEnumLiteralDeclaration_19; }

		//"quantity"
		public Keyword getQUANTITYQuantityKeyword_19_0() { return cQUANTITYQuantityKeyword_19_0; }

		//TERMINAL="terminal"
		public EnumLiteralDeclaration getTERMINALEnumLiteralDeclaration_20() { return cTERMINALEnumLiteralDeclaration_20; }

		//"terminal"
		public Keyword getTERMINALTerminalKeyword_20_0() { return cTERMINALTerminalKeyword_20_0; }
	}
	
	private final ModelElements pModel;
	private final DesignUnitElements pDesignUnit;
	private final ModuleElements pModule;
	private final ArchitectureElements pArchitecture;
	private final PackageBodyElements pPackageBody;
	private final PackageElements pPackage;
	private final EntityElements pEntity;
	private final ConfigurationElements pConfiguration;
	private final UseClauseDeclarationElements pUseClauseDeclaration;
	private final BlockDeclarativeItemElements pBlockDeclarativeItem;
	private final ConfigurationDeclarativeItemElements pConfigurationDeclarativeItem;
	private final EntityDeclarativeItemElements pEntityDeclarativeItem;
	private final PackageBodyDeclarativeItemElements pPackageBodyDeclarativeItem;
	private final PackageDeclarativeItemElements pPackageDeclarativeItem;
	private final ProceduralDeclarativeItemElements pProceduralDeclarativeItem;
	private final ProcessDeclarativeItemElements pProcessDeclarativeItem;
	private final SubprogramDeclarativeItemElements pSubprogramDeclarativeItem;
	private final ArchitectureStatementElements pArchitectureStatement;
	private final AccessTypeDefinitionElements pAccessTypeDefinition;
	private final ArrayNatureDefinitionElements pArrayNatureDefinition;
	private final ArrayTypeDefinitionElements pArrayTypeDefinition;
	private final LabelElements pLabel;
	private final AssertionStatementElements pAssertionStatement;
	private final ConcurrentAssertionStatementElements pConcurrentAssertionStatement;
	private final ParameterElements pParameter;
	private final ChoicesElements pChoices;
	private final ChoiceElements pChoice;
	private final OpenElements pOpen;
	private final AttributeDeclarationElements pAttributeDeclaration;
	private final AttributeSpecificationElements pAttributeSpecification;
	private final AttributeDesignatorElements pAttributeDesignator;
	private final AttributeEntityElements pAttributeEntity;
	private final AttributeEntityDesignatorElements pAttributeEntityDesignator;
	private final NameSignatureElements pNameSignature;
	private final BlockConfigurationElements pBlockConfiguration;
	private final BlockStatementElements pBlockStatement;
	private final BreakStatementElements pBreakStatement;
	private final ConcurrentBreakStatementElements pConcurrentBreakStatement;
	private final BreakStatementItemElements pBreakStatementItem;
	private final CaseStatementElements pCaseStatement;
	private final CaseAlternativeElements pCaseAlternative;
	private final AllElements pAll;
	private final OthersElements pOthers;
	private final UnaffectedElements pUnaffected;
	private final ComponentConfigurationElements pComponentConfiguration;
	private final ComponentElements pComponent;
	private final ComponentInstantiationStatementElements pComponentInstantiationStatement;
	private final EntityInstantiationStatementElements pEntityInstantiationStatement;
	private final ConfigurationInstantiationStatementElements pConfigurationInstantiationStatement;
	private final CompositeNatureDefinitionElements pCompositeNatureDefinition;
	private final CompositeTypeDefinitionElements pCompositeTypeDefinition;
	private final SelectedSignalAssignmentStatementElements pSelectedSignalAssignmentStatement;
	private final ConditionalSignalAssignmentStatementElements pConditionalSignalAssignmentStatement;
	private final SequentialSignalAssignmentStatementElements pSequentialSignalAssignmentStatement;
	private final VariableAssignmentStatementElements pVariableAssignmentStatement;
	private final SimpleSimultaneousStatementElements pSimpleSimultaneousStatement;
	private final ConditionalWaveformElements pConditionalWaveform;
	private final WaveformsElements pWaveforms;
	private final ConfigurationItemElements pConfigurationItem;
	private final ConfigurationSpecificationElements pConfigurationSpecification;
	private final DelayMechanismElements pDelayMechanism;
	private final RejectMechanismElements pRejectMechanism;
	private final TransportMechanismElements pTransportMechanism;
	private final DisconnectionSpecificationElements pDisconnectionSpecification;
	private final MultiNameElements pMultiName;
	private final MultiIdentifierNameElements pMultiIdentifierName;
	private final InstantiationListElements pInstantiationList;
	private final EntityStatementElements pEntityStatement;
	private final EnumerationTypeDefinitionElements pEnumerationTypeDefinition;
	private final EnumerationLiteralElements pEnumerationLiteral;
	private final ExitStatementElements pExitStatement;
	private final ExpressionElements pExpression;
	private final RelationElements pRelation;
	private final ShiftExpressionElements pShiftExpression;
	private final SimpleExpressionElements pSimpleExpression;
	private final SignTermExpressionElements pSignTermExpression;
	private final TermExpressionElements pTermExpression;
	private final FactorElements pFactor;
	private final UnaryExpressionElements pUnaryExpression;
	private final SignFactorElements pSignFactor;
	private final SignUnaryExpressionElements pSignUnaryExpression;
	private final SignPrimaryElements pSignPrimary;
	private final PrimaryElements pPrimary;
	private final FileDeclarationElements pFileDeclaration;
	private final InterfaceFileDeclarationElements pInterfaceFileDeclaration;
	private final FileTypeDefinitionElements pFileTypeDefinition;
	private final GenerateStatementElements pGenerateStatement;
	private final GenerationSchemeElements pGenerationScheme;
	private final ForGenerationSchemeElements pForGenerationScheme;
	private final IfGenerationSchemeElements pIfGenerationScheme;
	private final GenericsElements pGenerics;
	private final GenericMapsElements pGenericMaps;
	private final GroupDeclarationElements pGroupDeclaration;
	private final GroupConstituentElements pGroupConstituent;
	private final GroupConstituentsElements pGroupConstituents;
	private final GroupTemplateDeclarationElements pGroupTemplateDeclaration;
	private final IfStatementElements pIfStatement;
	private final IfStatementTestElements pIfStatementTest;
	private final ConstraintElements pConstraint;
	private final RangeConstraintElements pRangeConstraint;
	private final IndexConstraintElements pIndexConstraint;
	private final GenericDeclarationElements pGenericDeclaration;
	private final PortDeclarationElements pPortDeclaration;
	private final FunctionParameterDeclarationElements pFunctionParameterDeclaration;
	private final ProcedureParameterDeclarationElements pProcedureParameterDeclaration;
	private final LoopStatementElements pLoopStatement;
	private final IterationSchemeElements pIterationScheme;
	private final WhileIterationSchemeElements pWhileIterationScheme;
	private final ForIterationSchemeElements pForIterationScheme;
	private final NameElements pName;
	private final NameExpressionElements pNameExpression;
	private final NamePrefixElements pNamePrefix;
	private final NamePrefixExpressionElements pNamePrefixExpression;
	private final NameSuffixElements pNameSuffix;
	private final StringNameElements pStringName;
	private final CharacterNameElements pCharacterName;
	private final IdentifierNameElements pIdentifierName;
	private final SelectedNameElements pSelectedName;
	private final AttributeNameElements pAttributeName;
	private final NatureDeclarationElements pNatureDeclaration;
	private final NatureDefinitionElements pNatureDefinition;
	private final ScalarNatureDefinitionElements pScalarNatureDefinition;
	private final NextStatementElements pNextStatement;
	private final PortsElements pPorts;
	private final PortMapsElements pPortMaps;
	private final ProcedureCallStatementElements pProcedureCallStatement;
	private final ConcurrentProcedureCallStatementElements pConcurrentProcedureCallStatement;
	private final ProcessStatementElements pProcessStatement;
	private final AllocatorExpressionElements pAllocatorExpression;
	private final RecordNatureDefinitionElements pRecordNatureDefinition;
	private final RecordNatureElementElements pRecordNatureElement;
	private final RecordTypeDefinitionElements pRecordTypeDefinition;
	private final RecordTypeElementElements pRecordTypeElement;
	private final ReportStatementElements pReportStatement;
	private final ReturnStatementElements pReturnStatement;
	private final SequentialStatementElements pSequentialStatement;
	private final NullStatementElements pNullStatement;
	private final SignalDeclarationElements pSignalDeclaration;
	private final VariableDeclarationElements pVariableDeclaration;
	private final ConstantDeclarationElements pConstantDeclaration;
	private final InterfaceSignalDeclarationElements pInterfaceSignalDeclaration;
	private final InterfaceVariableDeclarationElements pInterfaceVariableDeclaration;
	private final InterfaceConstantDeclarationElements pInterfaceConstantDeclaration;
	private final SignatureElements pSignature;
	private final SimultaneousAlternativeElements pSimultaneousAlternative;
	private final SimultaneousCaseStatementElements pSimultaneousCaseStatement;
	private final SimultaneousIfStatementElements pSimultaneousIfStatement;
	private final SimultaneousIfStatementTestElements pSimultaneousIfStatementTest;
	private final SimultaneousProceduralStatementElements pSimultaneousProceduralStatement;
	private final SimultaneousStatementElements pSimultaneousStatement;
	private final SpectrumElements pSpectrum;
	private final NoiseElements pNoise;
	private final QuantityDeclarationElements pQuantityDeclaration;
	private final QuantityAspectElements pQuantityAspect;
	private final BranchQuantityDeclarationElements pBranchQuantityDeclaration;
	private final FreeQuantityDeclarationElements pFreeQuantityDeclaration;
	private final SourceQuantityDeclarationElements pSourceQuantityDeclaration;
	private final SourceAspectElements pSourceAspect;
	private final LimitDeclarationElements pLimitDeclaration;
	private final SubnatureDeclarationElements pSubnatureDeclaration;
	private final SubprogramDeclarationElements pSubprogramDeclaration;
	private final ProcedureDeclarationElements pProcedureDeclaration;
	private final FunctionDeclarationElements pFunctionDeclaration;
	private final SubprogramBodyElements pSubprogramBody;
	private final SubtypeDeclarationElements pSubtypeDeclaration;
	private final AliasDeclarationElements pAliasDeclaration;
	private final RangeElements pRange;
	private final DiscreteRangeElements pDiscreteRange;
	private final AggregateElements pAggregate;
	private final SliceNameElements pSliceName;
	private final RangeSpecificationElements pRangeSpecification;
	private final SubtypeIndicationElements pSubtypeIndication;
	private final SubtypeIndicationExpressionElements pSubtypeIndicationExpression;
	private final SubnatureIndicationElements pSubnatureIndication;
	private final TargetElements pTarget;
	private final TerminalDeclarationElements pTerminalDeclaration;
	private final TypeDeclarationElements pTypeDeclaration;
	private final TypeDefinitionElements pTypeDefinition;
	private final RangeTypeDefinitionElements pRangeTypeDefinition;
	private final PhysicalTypeDefinitionElements pPhysicalTypeDefinition;
	private final PhysicalTypeDefinitionSecondaryElements pPhysicalTypeDefinitionSecondary;
	private final UnconstrainedArrayTypeDefinitionElements pUnconstrainedArrayTypeDefinition;
	private final ConstrainedArrayTypeDefinitionElements pConstrainedArrayTypeDefinition;
	private final UnconstrainedArrayNatureDefinitionElements pUnconstrainedArrayNatureDefinition;
	private final ConstrainedArrayNatureDefinitionElements pConstrainedArrayNatureDefinition;
	private final WaitStatementElements pWaitStatement;
	private final WaveformElements pWaveform;
	private final NullExpressionElements pNullExpression;
	private final BitStringNameElements pBitStringName;
	private final ValueExpressionElements pValueExpression;
	private final SignalKindElements unknownRuleSignalKind;
	private final RangeDirectionElements unknownRuleRangeDirection;
	private final ModeElements unknownRuleMode;
	private final UnaryOperatorElements unknownRuleUnaryOperator;
	private final MultiplyingOperatorElements unknownRuleMultiplyingOperator;
	private final ShiftOperatorElements unknownRuleShiftOperator;
	private final RelationalOperatorElements unknownRuleRelationalOperator;
	private final LogicalOperatorElements unknownRuleLogicalOperator;
	private final AddingOperatorElements unknownRuleAddingOperator;
	private final SignElements unknownRuleSign;
	private final PurityElements unknownRulePurity;
	private final EntityClassElements unknownRuleEntityClass;
	private final DesignatorNameElements pDesignatorName;
	private final DesignatorElements pDesignator;
	private final IdentifierElements pIdentifier;
	private final TerminalRule tABSTRACT_LITERAL;
	private final TerminalRule tBIT_STRING_LITERAL;
	private final TerminalRule tID;
	private final TerminalRule tEXTENDED_IDENTIFIER;
	private final TerminalRule tSTRING;
	private final TerminalRule tCHAR;
	private final TerminalRule tATTRIBUTE;
	private final TerminalRule tSL_COMMENT;
	private final TerminalRule tWS;
	private final TerminalRule tBASED_INTEGER_FRAGMENT;
	private final TerminalRule tLETTER_OR_DIGIT_FRAGMENT;
	private final TerminalRule tLETTER_FRAGMENT;
	private final TerminalRule tBASE_SPECIFIER_FRAGMENT;
	private final TerminalRule tEXPONENT_FRAGMENT;
	private final TerminalRule tINTEGER_FRAGMENT;
	private final TerminalRule tDIGIT_FRAGMENT;
	
	private final Grammar grammar;

	@Inject
	public VhdlGrammarAccess(GrammarProvider grammarProvider) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.pModel = new ModelElements();
		this.pDesignUnit = new DesignUnitElements();
		this.pModule = new ModuleElements();
		this.pArchitecture = new ArchitectureElements();
		this.pPackageBody = new PackageBodyElements();
		this.pPackage = new PackageElements();
		this.pEntity = new EntityElements();
		this.pConfiguration = new ConfigurationElements();
		this.pUseClauseDeclaration = new UseClauseDeclarationElements();
		this.pBlockDeclarativeItem = new BlockDeclarativeItemElements();
		this.pConfigurationDeclarativeItem = new ConfigurationDeclarativeItemElements();
		this.pEntityDeclarativeItem = new EntityDeclarativeItemElements();
		this.pPackageBodyDeclarativeItem = new PackageBodyDeclarativeItemElements();
		this.pPackageDeclarativeItem = new PackageDeclarativeItemElements();
		this.pProceduralDeclarativeItem = new ProceduralDeclarativeItemElements();
		this.pProcessDeclarativeItem = new ProcessDeclarativeItemElements();
		this.pSubprogramDeclarativeItem = new SubprogramDeclarativeItemElements();
		this.pArchitectureStatement = new ArchitectureStatementElements();
		this.pAccessTypeDefinition = new AccessTypeDefinitionElements();
		this.pArrayNatureDefinition = new ArrayNatureDefinitionElements();
		this.pArrayTypeDefinition = new ArrayTypeDefinitionElements();
		this.pLabel = new LabelElements();
		this.pAssertionStatement = new AssertionStatementElements();
		this.pConcurrentAssertionStatement = new ConcurrentAssertionStatementElements();
		this.pParameter = new ParameterElements();
		this.pChoices = new ChoicesElements();
		this.pChoice = new ChoiceElements();
		this.pOpen = new OpenElements();
		this.pAttributeDeclaration = new AttributeDeclarationElements();
		this.pAttributeSpecification = new AttributeSpecificationElements();
		this.pAttributeDesignator = new AttributeDesignatorElements();
		this.pAttributeEntity = new AttributeEntityElements();
		this.pAttributeEntityDesignator = new AttributeEntityDesignatorElements();
		this.pNameSignature = new NameSignatureElements();
		this.pBlockConfiguration = new BlockConfigurationElements();
		this.pBlockStatement = new BlockStatementElements();
		this.pBreakStatement = new BreakStatementElements();
		this.pConcurrentBreakStatement = new ConcurrentBreakStatementElements();
		this.pBreakStatementItem = new BreakStatementItemElements();
		this.pCaseStatement = new CaseStatementElements();
		this.pCaseAlternative = new CaseAlternativeElements();
		this.pAll = new AllElements();
		this.pOthers = new OthersElements();
		this.pUnaffected = new UnaffectedElements();
		this.pComponentConfiguration = new ComponentConfigurationElements();
		this.pComponent = new ComponentElements();
		this.pComponentInstantiationStatement = new ComponentInstantiationStatementElements();
		this.pEntityInstantiationStatement = new EntityInstantiationStatementElements();
		this.pConfigurationInstantiationStatement = new ConfigurationInstantiationStatementElements();
		this.pCompositeNatureDefinition = new CompositeNatureDefinitionElements();
		this.pCompositeTypeDefinition = new CompositeTypeDefinitionElements();
		this.pSelectedSignalAssignmentStatement = new SelectedSignalAssignmentStatementElements();
		this.pConditionalSignalAssignmentStatement = new ConditionalSignalAssignmentStatementElements();
		this.pSequentialSignalAssignmentStatement = new SequentialSignalAssignmentStatementElements();
		this.pVariableAssignmentStatement = new VariableAssignmentStatementElements();
		this.pSimpleSimultaneousStatement = new SimpleSimultaneousStatementElements();
		this.pConditionalWaveform = new ConditionalWaveformElements();
		this.pWaveforms = new WaveformsElements();
		this.pConfigurationItem = new ConfigurationItemElements();
		this.pConfigurationSpecification = new ConfigurationSpecificationElements();
		this.pDelayMechanism = new DelayMechanismElements();
		this.pRejectMechanism = new RejectMechanismElements();
		this.pTransportMechanism = new TransportMechanismElements();
		this.pDisconnectionSpecification = new DisconnectionSpecificationElements();
		this.pMultiName = new MultiNameElements();
		this.pMultiIdentifierName = new MultiIdentifierNameElements();
		this.pInstantiationList = new InstantiationListElements();
		this.pEntityStatement = new EntityStatementElements();
		this.pEnumerationTypeDefinition = new EnumerationTypeDefinitionElements();
		this.pEnumerationLiteral = new EnumerationLiteralElements();
		this.pExitStatement = new ExitStatementElements();
		this.pExpression = new ExpressionElements();
		this.pRelation = new RelationElements();
		this.pShiftExpression = new ShiftExpressionElements();
		this.pSimpleExpression = new SimpleExpressionElements();
		this.pSignTermExpression = new SignTermExpressionElements();
		this.pTermExpression = new TermExpressionElements();
		this.pFactor = new FactorElements();
		this.pUnaryExpression = new UnaryExpressionElements();
		this.pSignFactor = new SignFactorElements();
		this.pSignUnaryExpression = new SignUnaryExpressionElements();
		this.pSignPrimary = new SignPrimaryElements();
		this.pPrimary = new PrimaryElements();
		this.pFileDeclaration = new FileDeclarationElements();
		this.pInterfaceFileDeclaration = new InterfaceFileDeclarationElements();
		this.pFileTypeDefinition = new FileTypeDefinitionElements();
		this.pGenerateStatement = new GenerateStatementElements();
		this.pGenerationScheme = new GenerationSchemeElements();
		this.pForGenerationScheme = new ForGenerationSchemeElements();
		this.pIfGenerationScheme = new IfGenerationSchemeElements();
		this.pGenerics = new GenericsElements();
		this.pGenericMaps = new GenericMapsElements();
		this.pGroupDeclaration = new GroupDeclarationElements();
		this.pGroupConstituent = new GroupConstituentElements();
		this.pGroupConstituents = new GroupConstituentsElements();
		this.pGroupTemplateDeclaration = new GroupTemplateDeclarationElements();
		this.pIfStatement = new IfStatementElements();
		this.pIfStatementTest = new IfStatementTestElements();
		this.pConstraint = new ConstraintElements();
		this.pRangeConstraint = new RangeConstraintElements();
		this.pIndexConstraint = new IndexConstraintElements();
		this.pGenericDeclaration = new GenericDeclarationElements();
		this.pPortDeclaration = new PortDeclarationElements();
		this.pFunctionParameterDeclaration = new FunctionParameterDeclarationElements();
		this.pProcedureParameterDeclaration = new ProcedureParameterDeclarationElements();
		this.pLoopStatement = new LoopStatementElements();
		this.pIterationScheme = new IterationSchemeElements();
		this.pWhileIterationScheme = new WhileIterationSchemeElements();
		this.pForIterationScheme = new ForIterationSchemeElements();
		this.pName = new NameElements();
		this.pNameExpression = new NameExpressionElements();
		this.pNamePrefix = new NamePrefixElements();
		this.pNamePrefixExpression = new NamePrefixExpressionElements();
		this.pNameSuffix = new NameSuffixElements();
		this.pStringName = new StringNameElements();
		this.pCharacterName = new CharacterNameElements();
		this.pIdentifierName = new IdentifierNameElements();
		this.pSelectedName = new SelectedNameElements();
		this.pAttributeName = new AttributeNameElements();
		this.pNatureDeclaration = new NatureDeclarationElements();
		this.pNatureDefinition = new NatureDefinitionElements();
		this.pScalarNatureDefinition = new ScalarNatureDefinitionElements();
		this.pNextStatement = new NextStatementElements();
		this.pPorts = new PortsElements();
		this.pPortMaps = new PortMapsElements();
		this.pProcedureCallStatement = new ProcedureCallStatementElements();
		this.pConcurrentProcedureCallStatement = new ConcurrentProcedureCallStatementElements();
		this.pProcessStatement = new ProcessStatementElements();
		this.pAllocatorExpression = new AllocatorExpressionElements();
		this.pRecordNatureDefinition = new RecordNatureDefinitionElements();
		this.pRecordNatureElement = new RecordNatureElementElements();
		this.pRecordTypeDefinition = new RecordTypeDefinitionElements();
		this.pRecordTypeElement = new RecordTypeElementElements();
		this.pReportStatement = new ReportStatementElements();
		this.pReturnStatement = new ReturnStatementElements();
		this.pSequentialStatement = new SequentialStatementElements();
		this.pNullStatement = new NullStatementElements();
		this.pSignalDeclaration = new SignalDeclarationElements();
		this.pVariableDeclaration = new VariableDeclarationElements();
		this.pConstantDeclaration = new ConstantDeclarationElements();
		this.pInterfaceSignalDeclaration = new InterfaceSignalDeclarationElements();
		this.pInterfaceVariableDeclaration = new InterfaceVariableDeclarationElements();
		this.pInterfaceConstantDeclaration = new InterfaceConstantDeclarationElements();
		this.pSignature = new SignatureElements();
		this.pSimultaneousAlternative = new SimultaneousAlternativeElements();
		this.pSimultaneousCaseStatement = new SimultaneousCaseStatementElements();
		this.pSimultaneousIfStatement = new SimultaneousIfStatementElements();
		this.pSimultaneousIfStatementTest = new SimultaneousIfStatementTestElements();
		this.pSimultaneousProceduralStatement = new SimultaneousProceduralStatementElements();
		this.pSimultaneousStatement = new SimultaneousStatementElements();
		this.pSpectrum = new SpectrumElements();
		this.pNoise = new NoiseElements();
		this.pQuantityDeclaration = new QuantityDeclarationElements();
		this.pQuantityAspect = new QuantityAspectElements();
		this.pBranchQuantityDeclaration = new BranchQuantityDeclarationElements();
		this.pFreeQuantityDeclaration = new FreeQuantityDeclarationElements();
		this.pSourceQuantityDeclaration = new SourceQuantityDeclarationElements();
		this.pSourceAspect = new SourceAspectElements();
		this.pLimitDeclaration = new LimitDeclarationElements();
		this.pSubnatureDeclaration = new SubnatureDeclarationElements();
		this.pSubprogramDeclaration = new SubprogramDeclarationElements();
		this.pProcedureDeclaration = new ProcedureDeclarationElements();
		this.pFunctionDeclaration = new FunctionDeclarationElements();
		this.pSubprogramBody = new SubprogramBodyElements();
		this.pSubtypeDeclaration = new SubtypeDeclarationElements();
		this.pAliasDeclaration = new AliasDeclarationElements();
		this.pRange = new RangeElements();
		this.pDiscreteRange = new DiscreteRangeElements();
		this.pAggregate = new AggregateElements();
		this.pSliceName = new SliceNameElements();
		this.pRangeSpecification = new RangeSpecificationElements();
		this.pSubtypeIndication = new SubtypeIndicationElements();
		this.pSubtypeIndicationExpression = new SubtypeIndicationExpressionElements();
		this.pSubnatureIndication = new SubnatureIndicationElements();
		this.pTarget = new TargetElements();
		this.pTerminalDeclaration = new TerminalDeclarationElements();
		this.pTypeDeclaration = new TypeDeclarationElements();
		this.pTypeDefinition = new TypeDefinitionElements();
		this.pRangeTypeDefinition = new RangeTypeDefinitionElements();
		this.pPhysicalTypeDefinition = new PhysicalTypeDefinitionElements();
		this.pPhysicalTypeDefinitionSecondary = new PhysicalTypeDefinitionSecondaryElements();
		this.pUnconstrainedArrayTypeDefinition = new UnconstrainedArrayTypeDefinitionElements();
		this.pConstrainedArrayTypeDefinition = new ConstrainedArrayTypeDefinitionElements();
		this.pUnconstrainedArrayNatureDefinition = new UnconstrainedArrayNatureDefinitionElements();
		this.pConstrainedArrayNatureDefinition = new ConstrainedArrayNatureDefinitionElements();
		this.pWaitStatement = new WaitStatementElements();
		this.pWaveform = new WaveformElements();
		this.pNullExpression = new NullExpressionElements();
		this.pBitStringName = new BitStringNameElements();
		this.pValueExpression = new ValueExpressionElements();
		this.unknownRuleSignalKind = new SignalKindElements();
		this.unknownRuleRangeDirection = new RangeDirectionElements();
		this.unknownRuleMode = new ModeElements();
		this.unknownRuleUnaryOperator = new UnaryOperatorElements();
		this.unknownRuleMultiplyingOperator = new MultiplyingOperatorElements();
		this.unknownRuleShiftOperator = new ShiftOperatorElements();
		this.unknownRuleRelationalOperator = new RelationalOperatorElements();
		this.unknownRuleLogicalOperator = new LogicalOperatorElements();
		this.unknownRuleAddingOperator = new AddingOperatorElements();
		this.unknownRuleSign = new SignElements();
		this.unknownRulePurity = new PurityElements();
		this.unknownRuleEntityClass = new EntityClassElements();
		this.pDesignatorName = new DesignatorNameElements();
		this.pDesignator = new DesignatorElements();
		this.pIdentifier = new IdentifierElements();
		this.tABSTRACT_LITERAL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ABSTRACT_LITERAL");
		this.tBIT_STRING_LITERAL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "BIT_STRING_LITERAL");
		this.tID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ID");
		this.tEXTENDED_IDENTIFIER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "EXTENDED_IDENTIFIER");
		this.tSTRING = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "STRING");
		this.tCHAR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "CHAR");
		this.tATTRIBUTE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ATTRIBUTE");
		this.tSL_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "SL_COMMENT");
		this.tWS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "WS");
		this.tBASED_INTEGER_FRAGMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "BASED_INTEGER_FRAGMENT");
		this.tLETTER_OR_DIGIT_FRAGMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "LETTER_OR_DIGIT_FRAGMENT");
		this.tLETTER_FRAGMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "LETTER_FRAGMENT");
		this.tBASE_SPECIFIER_FRAGMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "BASE_SPECIFIER_FRAGMENT");
		this.tEXPONENT_FRAGMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "EXPONENT_FRAGMENT");
		this.tINTEGER_FRAGMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "INTEGER_FRAGMENT");
		this.tDIGIT_FRAGMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "DIGIT_FRAGMENT");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("net.mlanoe.language.vhdl.xtext.Vhdl".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	
	public Grammar getGrammar() {
		return grammar;
	}
	

	
	//Model:
	//	design+=DesignUnit*;
	public ModelElements getModelAccess() {
		return pModel;
	}
	
	public ParserRule getModelRule() {
		return getModelAccess().getRule();
	}

	//DesignUnit:
	//	("library" library+=Identifier ("," library+=Identifier)* ";" | "use" use+=Name ("," use+=Name)* ";")* module=Module;
	public DesignUnitElements getDesignUnitAccess() {
		return pDesignUnit;
	}
	
	public ParserRule getDesignUnitRule() {
		return getDesignUnitAccess().getRule();
	}

	//Module:
	//	Architecture | PackageBody | Entity | Configuration | Package;
	public ModuleElements getModuleAccess() {
		return pModule;
	}
	
	public ParserRule getModuleRule() {
		return getModuleAccess().getRule();
	}

	/// *
	// * architecture identifier of entity_name is
	// *    [ declarations]
	// * begin -- optional
	// *    [ statements]
	// * end architecture identifier ;  
	// * / Architecture:
	//	"architecture" name=IdentifierName "of" of=Name "is" declaration+=BlockDeclarativeItem* "begin"
	//	statement+=ArchitectureStatement* "end" "architecture"? Identifier? ";";
	public ArchitectureElements getArchitectureAccess() {
		return pArchitecture;
	}
	
	public ParserRule getArchitectureRule() {
		return getArchitectureAccess().getRule();
	}

	/// *
	// * package body identifier is
	// *     [ declarations, see allowed list below ]
	// *  end package body identifier ;
	// * / PackageBody:
	//	"package" "body" name=IdentifierName "is" declaration+=PackageBodyDeclarativeItem* "end" ("package" "body")?
	//	Identifier? ";";
	public PackageBodyElements getPackageBodyAccess() {
		return pPackageBody;
	}
	
	public ParserRule getPackageBodyRule() {
		return getPackageBodyAccess().getRule();
	}

	/// *
	// * package identifier is
	// *     [ declarations, see allowed list below ]
	// * end package identifier ;
	// * / Package:
	//	"package" name=IdentifierName "is" declaration+=PackageDeclarativeItem* "end" "package"? Identifier? ";";
	public PackageElements getPackageAccess() {
		return pPackage;
	}
	
	public ParserRule getPackageRule() {
		return getPackageAccess().getRule();
	}

	//Entity:
	//	"entity" name=IdentifierName "is" generic=Generics? port=Ports? declaration+=EntityDeclarativeItem* ("begin"
	//	statement+=EntityStatement*)? "end" "entity"? Identifier? ";";
	public EntityElements getEntityAccess() {
		return pEntity;
	}
	
	public ParserRule getEntityRule() {
		return getEntityAccess().getRule();
	}

	//Configuration returns configuration::Configuration:
	//	"configuration" name=IdentifierName "of" of=Name "is" declaration+=ConfigurationDeclarativeItem*
	//	block=BlockConfiguration "end" "configuration"? Identifier? ";";
	public ConfigurationElements getConfigurationAccess() {
		return pConfiguration;
	}
	
	public ParserRule getConfigurationRule() {
		return getConfigurationAccess().getRule();
	}

	//UseClauseDeclaration returns declaration::UseClauseDeclaration:
	//	"use" use=MultiName ";";
	public UseClauseDeclarationElements getUseClauseDeclarationAccess() {
		return pUseClauseDeclaration;
	}
	
	public ParserRule getUseClauseDeclarationRule() {
		return getUseClauseDeclarationAccess().getRule();
	}

	//BlockDeclarativeItem returns declaration::Declaration:
	//	SubprogramDeclaration | TypeDeclaration | SubtypeDeclaration | ConstantDeclaration | SignalDeclaration |
	//	VariableDeclaration | FileDeclaration | AliasDeclaration | Component | AttributeDeclaration | AttributeSpecification |
	//	ConfigurationSpecification | DisconnectionSpecification | LimitDeclaration | UseClauseDeclaration |
	//	GroupTemplateDeclaration | GroupDeclaration | NatureDeclaration | SubnatureDeclaration | QuantityDeclaration |
	//	TerminalDeclaration;
	public BlockDeclarativeItemElements getBlockDeclarativeItemAccess() {
		return pBlockDeclarativeItem;
	}
	
	public ParserRule getBlockDeclarativeItemRule() {
		return getBlockDeclarativeItemAccess().getRule();
	}

	//ConfigurationDeclarativeItem returns declaration::Declaration:
	//	UseClauseDeclaration | AttributeSpecification | GroupDeclaration;
	public ConfigurationDeclarativeItemElements getConfigurationDeclarativeItemAccess() {
		return pConfigurationDeclarativeItem;
	}
	
	public ParserRule getConfigurationDeclarativeItemRule() {
		return getConfigurationDeclarativeItemAccess().getRule();
	}

	//EntityDeclarativeItem returns declaration::Declaration:
	//	SubprogramDeclaration | TypeDeclaration | SubtypeDeclaration | ConstantDeclaration | SignalDeclaration |
	//	VariableDeclaration | FileDeclaration | AliasDeclaration | AttributeDeclaration | AttributeSpecification |
	//	DisconnectionSpecification | LimitDeclaration | UseClauseDeclaration | GroupTemplateDeclaration | GroupDeclaration |
	//	NatureDeclaration | SubnatureDeclaration | QuantityDeclaration | TerminalDeclaration;
	public EntityDeclarativeItemElements getEntityDeclarativeItemAccess() {
		return pEntityDeclarativeItem;
	}
	
	public ParserRule getEntityDeclarativeItemRule() {
		return getEntityDeclarativeItemAccess().getRule();
	}

	//PackageBodyDeclarativeItem returns declaration::Declaration:
	//	SubprogramDeclaration | TypeDeclaration | SubtypeDeclaration | ConstantDeclaration | VariableDeclaration |
	//	FileDeclaration | AliasDeclaration | UseClauseDeclaration | GroupTemplateDeclaration | GroupDeclaration;
	public PackageBodyDeclarativeItemElements getPackageBodyDeclarativeItemAccess() {
		return pPackageBodyDeclarativeItem;
	}
	
	public ParserRule getPackageBodyDeclarativeItemRule() {
		return getPackageBodyDeclarativeItemAccess().getRule();
	}

	//PackageDeclarativeItem returns declaration::Declaration:
	//	SubprogramDeclaration | TypeDeclaration | SubtypeDeclaration | ConstantDeclaration | SignalDeclaration |
	//	VariableDeclaration | FileDeclaration | AliasDeclaration | Component | AttributeDeclaration | AttributeSpecification |
	//	DisconnectionSpecification | UseClauseDeclaration | GroupTemplateDeclaration | GroupDeclaration | NatureDeclaration |
	//	SubnatureDeclaration | TerminalDeclaration;
	public PackageDeclarativeItemElements getPackageDeclarativeItemAccess() {
		return pPackageDeclarativeItem;
	}
	
	public ParserRule getPackageDeclarativeItemRule() {
		return getPackageDeclarativeItemAccess().getRule();
	}

	//ProceduralDeclarativeItem returns declaration::Declaration:
	//	SubprogramDeclaration | TypeDeclaration | SubtypeDeclaration | ConstantDeclaration | VariableDeclaration |
	//	AliasDeclaration | AttributeDeclaration | AttributeSpecification | UseClauseDeclaration | GroupTemplateDeclaration |
	//	GroupDeclaration;
	public ProceduralDeclarativeItemElements getProceduralDeclarativeItemAccess() {
		return pProceduralDeclarativeItem;
	}
	
	public ParserRule getProceduralDeclarativeItemRule() {
		return getProceduralDeclarativeItemAccess().getRule();
	}

	//ProcessDeclarativeItem returns declaration::Declaration:
	//	SubprogramDeclaration | TypeDeclaration | SubtypeDeclaration | ConstantDeclaration | VariableDeclaration |
	//	FileDeclaration | AliasDeclaration | AttributeDeclaration | AttributeSpecification | UseClauseDeclaration |
	//	GroupTemplateDeclaration | GroupDeclaration;
	public ProcessDeclarativeItemElements getProcessDeclarativeItemAccess() {
		return pProcessDeclarativeItem;
	}
	
	public ParserRule getProcessDeclarativeItemRule() {
		return getProcessDeclarativeItemAccess().getRule();
	}

	//SubprogramDeclarativeItem returns declaration::Declaration:
	//	SubprogramDeclaration | TypeDeclaration | SubtypeDeclaration | ConstantDeclaration | VariableDeclaration |
	//	FileDeclaration | AliasDeclaration | AttributeDeclaration | AttributeSpecification | UseClauseDeclaration |
	//	GroupTemplateDeclaration | GroupDeclaration;
	public SubprogramDeclarativeItemElements getSubprogramDeclarativeItemAccess() {
		return pSubprogramDeclarativeItem;
	}
	
	public ParserRule getSubprogramDeclarativeItemRule() {
		return getSubprogramDeclarativeItemAccess().getRule();
	}

	//ArchitectureStatement returns statement::Statement:
	//	ProcessStatement | ConfigurationInstantiationStatement | BlockStatement | ConcurrentAssertionStatement |
	//	SimultaneousProceduralStatement | SimultaneousCaseStatement | SimultaneousIfStatement | ConcurrentBreakStatement |
	//	EntityInstantiationStatement | ConcurrentProcedureCallStatement | SelectedSignalAssignmentStatement |
	//	ComponentInstantiationStatement | GenerateStatement | ConditionalSignalAssignmentStatement |
	//	SimpleSimultaneousStatement;
	public ArchitectureStatementElements getArchitectureStatementAccess() {
		return pArchitectureStatement;
	}
	
	public ParserRule getArchitectureStatementRule() {
		return getArchitectureStatementAccess().getRule();
	}

	/// *
	// * ACCESS subtype_indication;
	// * / AccessTypeDefinition returns type::AccessTypeDefinition:
	//	"access" type=SubtypeIndication;
	public AccessTypeDefinitionElements getAccessTypeDefinitionAccess() {
		return pAccessTypeDefinition;
	}
	
	public ParserRule getAccessTypeDefinitionRule() {
		return getAccessTypeDefinitionAccess().getRule();
	}

	//ArrayNatureDefinition returns nature::ArrayNatureDefinition:
	//	UnconstrainedArrayNatureDefinition | ConstrainedArrayNatureDefinition;
	public ArrayNatureDefinitionElements getArrayNatureDefinitionAccess() {
		return pArrayNatureDefinition;
	}
	
	public ParserRule getArrayNatureDefinitionRule() {
		return getArrayNatureDefinitionAccess().getRule();
	}

	//ArrayTypeDefinition returns type::ArrayTypeDefinition:
	//	UnconstrainedArrayTypeDefinition | ConstrainedArrayTypeDefinition;
	public ArrayTypeDefinitionElements getArrayTypeDefinitionAccess() {
		return pArrayTypeDefinition;
	}
	
	public ParserRule getArrayTypeDefinitionRule() {
		return getArrayTypeDefinitionAccess().getRule();
	}

	//Label:
	//	Identifier;
	public LabelElements getLabelAccess() {
		return pLabel;
	}
	
	public ParserRule getLabelRule() {
		return getLabelAccess().getRule();
	}

	/// *
	// * [ label: ] assert boolean_condition [ report string ] [ severity name ] ;
	// * / AssertionStatement returns statement::AssertionStatement:
	//	(label=Label ":")? "assert" condition=Expression ("report" report=Expression)? ("severity" severity=Expression)? ";";
	public AssertionStatementElements getAssertionStatementAccess() {
		return pAssertionStatement;
	}
	
	public ParserRule getAssertionStatementRule() {
		return getAssertionStatementAccess().getRule();
	}

	/// *
	// * [ label: ] [postponed] assert boolean_condition [ report string ] [ severity name ] ;
	// * / ConcurrentAssertionStatement returns statement::AssertionStatement:
	//	(label=Label ":")? postponed?="postponed"? "assert" condition=Expression ("report" report=Expression)? ("severity"
	//	severity=Expression)? ";";
	public ConcurrentAssertionStatementElements getConcurrentAssertionStatementAccess() {
		return pConcurrentAssertionStatement;
	}
	
	public ParserRule getConcurrentAssertionStatementRule() {
		return getConcurrentAssertionStatementAccess().getRule();
	}

	//Parameter returns expression::Expression:
	//	{expression::AssociationExpression} choice=Choices "=>" (expression=Expression | "open") | Expression | Open;
	public ParameterElements getParameterAccess() {
		return pParameter;
	}
	
	public ParserRule getParameterRule() {
		return getParameterAccess().getRule();
	}

	//Choices returns expression::Expression:
	//	Choice ({expression::MultiExpression.expression+=current} ("|" expression+=Choice)+)?;
	public ChoicesElements getChoicesAccess() {
		return pChoices;
	}
	
	public ParserRule getChoicesRule() {
		return getChoicesAccess().getRule();
	}

	//Choice returns expression::Expression:
	//	RangeSpecification | SubtypeIndicationExpression | SimpleExpression | Others;
	public ChoiceElements getChoiceAccess() {
		return pChoice;
	}
	
	public ParserRule getChoiceRule() {
		return getChoiceAccess().getRule();
	}

	//Open returns expression::OpenExpression:
	//	{expression::OpenExpression} "open";
	public OpenElements getOpenAccess() {
		return pOpen;
	}
	
	public ParserRule getOpenRule() {
		return getOpenAccess().getRule();
	}

	/// *
	// * attribute identifier : type_mark ;
	// * / AttributeDeclaration returns declaration::AttributeDeclaration:
	//	"attribute" name=IdentifierName ":" type=IdentifierName ";";
	public AttributeDeclarationElements getAttributeDeclarationAccess() {
		return pAttributeDeclaration;
	}
	
	public ParserRule getAttributeDeclarationRule() {
		return getAttributeDeclarationAccess().getRule();
	}

	/// *
	// * attribute_specification = "attribute" attribute_designator "of" entity_specification "is" expression ";"
	// *  entity_specification = entity_name_list ":" entity_class
	// * / AttributeSpecification returns declaration::AttributeSpecification:
	//	"attribute" name=AttributeDesignator "of" entity=AttributeEntity ":" class=EntityClass "is" is=Expression ";";
	public AttributeSpecificationElements getAttributeSpecificationAccess() {
		return pAttributeSpecification;
	}
	
	public ParserRule getAttributeSpecificationRule() {
		return getAttributeSpecificationAccess().getRule();
	}

	//AttributeDesignator returns Name:
	//	IdentifierName | {expression::IdentifierExpression} value="range" | {expression::IdentifierExpression} value="across"
	//	| {expression::IdentifierExpression} value="through" | {expression::IdentifierExpression} value="reference" |
	//	{expression::IdentifierExpression} value="tolerance";
	public AttributeDesignatorElements getAttributeDesignatorAccess() {
		return pAttributeDesignator;
	}
	
	public ParserRule getAttributeDesignatorRule() {
		return getAttributeDesignatorAccess().getRule();
	}

	/// *
	// * entity_name_list = entity_designator { "," entity_designator }
	// *                  | "others"
	// *                  | "all"
	// * / AttributeEntity returns MultiName:
	//	AttributeEntityDesignator ({NameList.name+=current} ("," name+=AttributeEntityDesignator)+)?;
	public AttributeEntityElements getAttributeEntityAccess() {
		return pAttributeEntity;
	}
	
	public ParserRule getAttributeEntityRule() {
		return getAttributeEntityAccess().getRule();
	}

	//AttributeEntityDesignator returns Name:
	//	IdentifierName ({expression::SignatureExpression.name=current} signature=Signature)? | CharacterName
	//	({expression::SignatureExpression.name=current} signature=Signature)? | StringName
	//	({expression::SignatureExpression.name=current} signature=Signature)? | Others | All;
	public AttributeEntityDesignatorElements getAttributeEntityDesignatorAccess() {
		return pAttributeEntityDesignator;
	}
	
	public ParserRule getAttributeEntityDesignatorRule() {
		return getAttributeEntityDesignatorAccess().getRule();
	}

	//NameSignature returns Name:
	//	Name ({expression::SignatureExpression.name=current} signature=Signature)?;
	public NameSignatureElements getNameSignatureAccess() {
		return pNameSignature;
	}
	
	public ParserRule getNameSignatureRule() {
		return getNameSignatureAccess().getRule();
	}

	//BlockConfiguration returns configuration::BlockConfiguration:
	//	"for" name=Name ("use" use+=Name ("," use+=Name)* ";")* item+=ConfigurationItem* "end" "for" ";";
	public BlockConfigurationElements getBlockConfigurationAccess() {
		return pBlockConfiguration;
	}
	
	public ParserRule getBlockConfigurationRule() {
		return getBlockConfigurationAccess().getRule();
	}

	/// *
	// * label : block [ ( guard expression ) ] [ is ]
	// *            [ generic clause [ generic map aspect ; ] ]
	// *            [ port clause [ port map aspect ; ] ]
	// *            [ block declarative items ]
	// *         begin
	// *            concurrent statements
	// *         end block [ label ] ;
	// * / BlockStatement returns statement::BlockStatement:
	//	label=Label ":" "block" ("(" guard=Expression ")")? "is"? (generic=Generics (genericMap=GenericMaps ";")?)?
	//	(port=Ports (portMap=PortMaps ";")?)? declaration+=BlockDeclarativeItem* "begin" statement+=ArchitectureStatement*
	//	"end" "block" Identifier? ";";
	public BlockStatementElements getBlockStatementAccess() {
		return pBlockStatement;
	}
	
	public ParserRule getBlockStatementRule() {
		return getBlockStatementAccess().getRule();
	}

	//BreakStatement returns statement::BreakStatement:
	//	{statement::BreakStatement} (label=Label ":")? "break" (break+=BreakStatementItem ("," break+=BreakStatementItem)*)?
	//	("when" when=Expression)? ";";
	public BreakStatementElements getBreakStatementAccess() {
		return pBreakStatement;
	}
	
	public ParserRule getBreakStatementRule() {
		return getBreakStatementAccess().getRule();
	}

	//ConcurrentBreakStatement returns statement::BreakStatement:
	//	{statement::BreakStatement} (label=Label ":")? "break" (break+=BreakStatementItem ("," break+=BreakStatementItem)*)?
	//	("on" sensitivity=MultiName)? ("when" when=Expression)? ";";
	public ConcurrentBreakStatementElements getConcurrentBreakStatementAccess() {
		return pConcurrentBreakStatement;
	}
	
	public ParserRule getConcurrentBreakStatementRule() {
		return getConcurrentBreakStatementAccess().getRule();
	}

	//BreakStatementItem returns statement::BreakStatementItem:
	//	("for" name=Name "use")? use=Name "=>" arrow=Expression;
	public BreakStatementItemElements getBreakStatementItemAccess() {
		return pBreakStatementItem;
	}
	
	public ParserRule getBreakStatementItemRule() {
		return getBreakStatementItemAccess().getRule();
	}

	/// *
	// * [ label: ] case  expression  is
	// *              when choice1 =>
	// *                 sequence-of-statements
	// *              when choice2 =>            \_ optional
	// *                 sequence-of-statements  /
	// *              ...
	// *
	// *              when others =>             \_ optional if all choices covered
	// *                 sequence-of-statements  /
	// *            end case [ label ] ;
	// * / CaseStatement returns statement::CaseStatement:
	//	(label=Label ":")? "case" case=Expression "is" when+=CaseAlternative+ "end" "case" Identifier? ";";
	public CaseStatementElements getCaseStatementAccess() {
		return pCaseStatement;
	}
	
	public ParserRule getCaseStatementRule() {
		return getCaseStatementAccess().getRule();
	}

	//CaseAlternative returns statement::CaseAlternative:
	//	"when" choice=Choices "=>" statement+=SequentialStatement*;
	public CaseAlternativeElements getCaseAlternativeAccess() {
		return pCaseAlternative;
	}
	
	public ParserRule getCaseAlternativeRule() {
		return getCaseAlternativeAccess().getRule();
	}

	//All returns expression::AllExpression:
	//	{expression::AllExpression} "all";
	public AllElements getAllAccess() {
		return pAll;
	}
	
	public ParserRule getAllRule() {
		return getAllAccess().getRule();
	}

	//Others returns expression::OthersExpression:
	//	{expression::OthersExpression} "others";
	public OthersElements getOthersAccess() {
		return pOthers;
	}
	
	public ParserRule getOthersRule() {
		return getOthersAccess().getRule();
	}

	//Unaffected returns expression::UnaffectedExpression:
	//	{expression::UnaffectedExpression} "unaffected";
	public UnaffectedElements getUnaffectedAccess() {
		return pUnaffected;
	}
	
	public ParserRule getUnaffectedRule() {
		return getUnaffectedAccess().getRule();
	}

	//ComponentConfiguration returns configuration::ComponentConfiguration:
	//	"for" list=InstantiationList ":" component=Name (("use" ("entity" entity=Name | "configuration" configuration=Name |
	//	"open"))? genericMap=GenericMaps? portMap=PortMaps? ";")? block=BlockConfiguration? "end" "for" ";";
	public ComponentConfigurationElements getComponentConfigurationAccess() {
		return pComponentConfiguration;
	}
	
	public ParserRule getComponentConfigurationRule() {
		return getComponentConfigurationAccess().getRule();
	}

	/// *
	// * component component_name is
	// *    generic ( generic_variable_declarations ) ; -- optional
	// *    port ( input_and_output_variable_declarations ) ;
	// * end component component_name ;
	// * / Component:
	//	"component" name=IdentifierName "is"? generic=Generics? port=Ports? "end" "component" Identifier? ";";
	public ComponentElements getComponentAccess() {
		return pComponent;
	}
	
	public ParserRule getComponentRule() {
		return getComponentAccess().getRule();
	}

	/// *
	// * part_name: entity  library_name.entity_name(architecture_name)
	// *            port map ( actual arguments ) ; 
	// *
	// *            optional (architecture_name)
	// * part_name: component_name
	// *            port map ( actual arguments ) ;
	// * / ComponentInstantiationStatement returns statement::ComponentInstantiationStatement:
	//	label=Label ":" "component"? name=Name genericMap=GenericMaps? portMap=PortMaps? ";";
	public ComponentInstantiationStatementElements getComponentInstantiationStatementAccess() {
		return pComponentInstantiationStatement;
	}
	
	public ParserRule getComponentInstantiationStatementRule() {
		return getComponentInstantiationStatementAccess().getRule();
	}

	//EntityInstantiationStatement returns statement::EntityInstantiationStatement:
	//	label=Label ":" "entity" name=Name genericMap=GenericMaps? portMap=PortMaps? ";";
	public EntityInstantiationStatementElements getEntityInstantiationStatementAccess() {
		return pEntityInstantiationStatement;
	}
	
	public ParserRule getEntityInstantiationStatementRule() {
		return getEntityInstantiationStatementAccess().getRule();
	}

	//ConfigurationInstantiationStatement returns statement::ConfigurationInstantiationStatement:
	//	label=Label ":" "configuration" name=Name genericMap=GenericMaps? portMap=PortMaps? ";";
	public ConfigurationInstantiationStatementElements getConfigurationInstantiationStatementAccess() {
		return pConfigurationInstantiationStatement;
	}
	
	public ParserRule getConfigurationInstantiationStatementRule() {
		return getConfigurationInstantiationStatementAccess().getRule();
	}

	//CompositeNatureDefinition returns nature::CompositeNatureDefinition:
	//	ArrayNatureDefinition | RecordNatureDefinition;
	public CompositeNatureDefinitionElements getCompositeNatureDefinitionAccess() {
		return pCompositeNatureDefinition;
	}
	
	public ParserRule getCompositeNatureDefinitionRule() {
		return getCompositeNatureDefinitionAccess().getRule();
	}

	//CompositeTypeDefinition returns type::CompositeTypeDefinition:
	//	ArrayTypeDefinition | RecordTypeDefinition;
	public CompositeTypeDefinitionElements getCompositeTypeDefinitionAccess() {
		return pCompositeTypeDefinition;
	}
	
	public ParserRule getCompositeTypeDefinitionRule() {
		return getCompositeTypeDefinitionAccess().getRule();
	}

	/// *
	// * [ label : ] [ postponed ] selected_signal_assignment_statement ;
	// *
	// * with expression select target <=
	// *            waveform when choice [, waveform when choice ] ;
	// * / SelectedSignalAssignmentStatement returns statement::SelectedSignalAssignmentStatement:
	//	(label=Label ":")? postponed?="postponed"? "with" selected=Expression "select" target=Target "<=" guarded?="guarded"?
	//	delay=DelayMechanism? waveform+=ConditionalWaveform ("," waveform+=ConditionalWaveform)* ";";
	public SelectedSignalAssignmentStatementElements getSelectedSignalAssignmentStatementAccess() {
		return pSelectedSignalAssignmentStatement;
	}
	
	public ParserRule getSelectedSignalAssignmentStatementRule() {
		return getSelectedSignalAssignmentStatementAccess().getRule();
	}

	/// *
	// * [ label : ] [ postponed ] conditional_signal_assignment_statement ;
	// *
	// * target <= waveform when choice; -- choice is a boolean expression
	// * target <= waveform when choice else waveform;
	// * / ConditionalSignalAssignmentStatement returns statement::ConditionalSignalAssignmentStatement:
	//	(label=Label ":")? postponed?="postponed"? target=Target "<=" guarded?="guarded"? delay=DelayMechanism?
	//	waveform+=ConditionalWaveform ("else" waveform+=ConditionalWaveform)* ";";
	public ConditionalSignalAssignmentStatementElements getConditionalSignalAssignmentStatementAccess() {
		return pConditionalSignalAssignmentStatement;
	}
	
	public ParserRule getConditionalSignalAssignmentStatementRule() {
		return getConditionalSignalAssignmentStatementAccess().getRule();
	}

	/// *
	// * sequential signal assignment statement
	// *
	// * [ label : ] target "<=" [ "guarded" ] [ delay_mechanism ] waveform ";".
	// * / SequentialSignalAssignmentStatement returns statement::SequentialSignalAssignmentStatement:
	//	(label=Label ":")? postponed?="postponed"? target=Target "<=" guarded?="guarded"? delay=DelayMechanism?
	//	waveform=Waveforms ";";
	public SequentialSignalAssignmentStatementElements getSequentialSignalAssignmentStatementAccess() {
		return pSequentialSignalAssignmentStatement;
	}
	
	public ParserRule getSequentialSignalAssignmentStatementRule() {
		return getSequentialSignalAssignmentStatementAccess().getRule();
	}

	/// *
	// * [ label: ] target := expression ;
	// * / VariableAssignmentStatement returns statement::VariableAssignmentStatement:
	//	=> ((label=Label ":")? target=Target ":=") initial=Expression ";";
	public VariableAssignmentStatementElements getVariableAssignmentStatementAccess() {
		return pVariableAssignmentStatement;
	}
	
	public ParserRule getVariableAssignmentStatementRule() {
		return getVariableAssignmentStatementAccess().getRule();
	}

	//SimpleSimultaneousStatement returns statement::SimpleSimultaneousStatement:
	//	=> ((label=Label ":")? left=SimpleExpression "==") right=SimpleExpression ("tolerance" tolerance=Expression)? ";";
	public SimpleSimultaneousStatementElements getSimpleSimultaneousStatementAccess() {
		return pSimpleSimultaneousStatement;
	}
	
	public ParserRule getSimpleSimultaneousStatementRule() {
		return getSimpleSimultaneousStatementAccess().getRule();
	}

	//ConditionalWaveform returns expression::Expression:
	//	Waveforms ({expression::ConditionalWaveformExpression.expression=current} "when" choice=Choices)?;
	public ConditionalWaveformElements getConditionalWaveformAccess() {
		return pConditionalWaveform;
	}
	
	public ParserRule getConditionalWaveformRule() {
		return getConditionalWaveformAccess().getRule();
	}

	//Waveforms returns expression::Expression:
	//	Unaffected | Waveform ({expression::MultiExpression.expression+=current} ("," expression+=Waveform)+)?;
	public WaveformsElements getWaveformsAccess() {
		return pWaveforms;
	}
	
	public ParserRule getWaveformsRule() {
		return getWaveformsAccess().getRule();
	}

	//ConfigurationItem returns configuration::ConfigurationItem:
	//	BlockConfiguration | ComponentConfiguration;
	public ConfigurationItemElements getConfigurationItemAccess() {
		return pConfigurationItem;
	}
	
	public ParserRule getConfigurationItemRule() {
		return getConfigurationItemAccess().getRule();
	}

	//ConfigurationSpecification returns declaration::ConfigurationSpecification:
	//	"for" list=InstantiationList ":" component=Name ("use" ("entity" entity=Name | "configuration" configuration=Name |
	//	"open"))? genericMap=GenericMaps? portMap=PortMaps? ";";
	public ConfigurationSpecificationElements getConfigurationSpecificationAccess() {
		return pConfigurationSpecification;
	}
	
	public ParserRule getConfigurationSpecificationRule() {
		return getConfigurationSpecificationAccess().getRule();
	}

	//DelayMechanism returns statement::DelayMechanism:
	//	TransportMechanism | RejectMechanism;
	public DelayMechanismElements getDelayMechanismAccess() {
		return pDelayMechanism;
	}
	
	public ParserRule getDelayMechanismRule() {
		return getDelayMechanismAccess().getRule();
	}

	//RejectMechanism returns statement::RejectMechanism:
	//	{statement::RejectMechanism} ("reject" reject=Expression)? "inertial";
	public RejectMechanismElements getRejectMechanismAccess() {
		return pRejectMechanism;
	}
	
	public ParserRule getRejectMechanismRule() {
		return getRejectMechanismAccess().getRule();
	}

	//TransportMechanism returns statement::TransportMechanism:
	//	{statement::TransportMechanism} "transport";
	public TransportMechanismElements getTransportMechanismAccess() {
		return pTransportMechanism;
	}
	
	public ParserRule getTransportMechanismRule() {
		return getTransportMechanismAccess().getRule();
	}

	/// *
	// * disconnection_specification = "disconnect" guarded_signal_specification "after" time_expression ";".
	// *
	// * guarded_signal_specification = guarded_signal_list ":" type_mark.
	// * / DisconnectionSpecification returns declaration::DisconnectionSpecification:
	//	"disconnect" disconnect=MultiName ":" type=Name "after" after=Expression ";";
	public DisconnectionSpecificationElements getDisconnectionSpecificationAccess() {
		return pDisconnectionSpecification;
	}
	
	public ParserRule getDisconnectionSpecificationRule() {
		return getDisconnectionSpecificationAccess().getRule();
	}

	//MultiName:
	//	Name ({NameList.name+=current} ("," name+=Name)+)?;
	public MultiNameElements getMultiNameAccess() {
		return pMultiName;
	}
	
	public ParserRule getMultiNameRule() {
		return getMultiNameAccess().getRule();
	}

	//MultiIdentifierName returns MultiName:
	//	IdentifierName ({NameList.name+=current} ("," name+=IdentifierName)+)?;
	public MultiIdentifierNameElements getMultiIdentifierNameAccess() {
		return pMultiIdentifierName;
	}
	
	public ParserRule getMultiIdentifierNameRule() {
		return getMultiIdentifierNameAccess().getRule();
	}

	//InstantiationList returns MultiName:
	//	MultiIdentifierName | Others | All;
	public InstantiationListElements getInstantiationListAccess() {
		return pInstantiationList;
	}
	
	public ParserRule getInstantiationListRule() {
		return getInstantiationListAccess().getRule();
	}

	//EntityStatement returns statement::Statement:
	//	ConcurrentAssertionStatement | ProcessStatement | ConcurrentProcedureCallStatement;
	public EntityStatementElements getEntityStatementAccess() {
		return pEntityStatement;
	}
	
	public ParserRule getEntityStatementRule() {
		return getEntityStatementAccess().getRule();
	}

	//EnumerationTypeDefinition returns type::EnumerationTypeDefinition:
	//	"(" literal+=EnumerationLiteral ("," literal+=EnumerationLiteral)* ")";
	public EnumerationTypeDefinitionElements getEnumerationTypeDefinitionAccess() {
		return pEnumerationTypeDefinition;
	}
	
	public ParserRule getEnumerationTypeDefinitionRule() {
		return getEnumerationTypeDefinitionAccess().getRule();
	}

	//EnumerationLiteral returns type::EnumerationLiteral:
	//	IdentifierName | CharacterName;
	public EnumerationLiteralElements getEnumerationLiteralAccess() {
		return pEnumerationLiteral;
	}
	
	public ParserRule getEnumerationLiteralRule() {
		return getEnumerationLiteralAccess().getRule();
	}

	/// *
	// * [ label: ] exit [ label2 ] [ when condition ] ;
	// * / ExitStatement returns statement::ExitStatement:
	//	{statement::ExitStatement} (label=Label ":")? "exit" exit=Identifier? ("when" when=Expression)? ";";
	public ExitStatementElements getExitStatementAccess() {
		return pExitStatement;
	}
	
	public ParserRule getExitStatementRule() {
		return getExitStatementAccess().getRule();
	}

	/// *
	// * Addition returns Expression:
	// * Multiplication ({Addition.left=current} '+' right=Multiplication)*;
	// * / Expression returns expression::Expression:
	//	Relation ({expression::LogicalExpression.left=current} operator=LogicalOperator right=Relation)*;
	public ExpressionElements getExpressionAccess() {
		return pExpression;
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}

	//Relation returns expression::Expression:
	//	ShiftExpression ({expression::RelationalExpression.left=current} operator=RelationalOperator right=ShiftExpression)?;
	public RelationElements getRelationAccess() {
		return pRelation;
	}
	
	public ParserRule getRelationRule() {
		return getRelationAccess().getRule();
	}

	//ShiftExpression returns expression::Expression:
	//	SimpleExpression ({expression::ShiftExpression.left=current} operator=ShiftOperator right=SimpleExpression)?;
	public ShiftExpressionElements getShiftExpressionAccess() {
		return pShiftExpression;
	}
	
	public ParserRule getShiftExpressionRule() {
		return getShiftExpressionAccess().getRule();
	}

	//SimpleExpression returns expression::Expression:
	//	TermExpression ({expression::AddingExpression.left=current} operator=AddingOperator right=TermExpression)* |
	//	SignTermExpression ({expression::AddingExpression.left=current} operator=AddingOperator right=TermExpression)*;
	public SimpleExpressionElements getSimpleExpressionAccess() {
		return pSimpleExpression;
	}
	
	public ParserRule getSimpleExpressionRule() {
		return getSimpleExpressionAccess().getRule();
	}

	//SignTermExpression returns expression::Expression:
	//	SignFactor ({expression::MultiplyingExpression.left=current} operator=MultiplyingOperator right=Factor)*;
	public SignTermExpressionElements getSignTermExpressionAccess() {
		return pSignTermExpression;
	}
	
	public ParserRule getSignTermExpressionRule() {
		return getSignTermExpressionAccess().getRule();
	}

	//TermExpression returns expression::Expression:
	//	Factor ({expression::MultiplyingExpression.left=current} operator=MultiplyingOperator right=Factor)*;
	public TermExpressionElements getTermExpressionAccess() {
		return pTermExpression;
	}
	
	public ParserRule getTermExpressionRule() {
		return getTermExpressionAccess().getRule();
	}

	//Factor returns expression::Expression:
	//	Primary ({expression::PowerExpression.left=current} "**" right=Primary)? | UnaryExpression;
	public FactorElements getFactorAccess() {
		return pFactor;
	}
	
	public ParserRule getFactorRule() {
		return getFactorAccess().getRule();
	}

	//UnaryExpression returns expression::Expression:
	//	{expression::UnaryExpression} operator=UnaryOperator expression=Primary;
	public UnaryExpressionElements getUnaryExpressionAccess() {
		return pUnaryExpression;
	}
	
	public ParserRule getUnaryExpressionRule() {
		return getUnaryExpressionAccess().getRule();
	}

	//SignFactor returns expression::Expression:
	//	SignPrimary ({expression::PowerExpression.left=current} "**" right=Primary)? | SignUnaryExpression;
	public SignFactorElements getSignFactorAccess() {
		return pSignFactor;
	}
	
	public ParserRule getSignFactorRule() {
		return getSignFactorAccess().getRule();
	}

	//SignUnaryExpression returns expression::Expression:
	//	{expression::SignExpression} sign=Sign expression=UnaryExpression;
	public SignUnaryExpressionElements getSignUnaryExpressionAccess() {
		return pSignUnaryExpression;
	}
	
	public ParserRule getSignUnaryExpressionRule() {
		return getSignUnaryExpressionAccess().getRule();
	}

	//SignPrimary returns expression::Expression:
	//	{expression::SignExpression} sign=Sign expression=Primary;
	public SignPrimaryElements getSignPrimaryAccess() {
		return pSignPrimary;
	}
	
	public ParserRule getSignPrimaryRule() {
		return getSignPrimaryAccess().getRule();
	}

	//Primary returns expression::Expression:
	//	AllocatorExpression | NameExpression | NullExpression | BitStringName | CharacterName | ValueExpression | Aggregate;
	public PrimaryElements getPrimaryAccess() {
		return pPrimary;
	}
	
	public ParserRule getPrimaryRule() {
		return getPrimaryAccess().getRule();
	}

	//FileDeclaration returns declaration::FileDeclaration:
	//	"file" name=MultiIdentifierName ":" type=SubtypeIndication (("open" open=Expression)? "is" is=Expression)? ";";
	public FileDeclarationElements getFileDeclarationAccess() {
		return pFileDeclaration;
	}
	
	public ParserRule getFileDeclarationRule() {
		return getFileDeclarationAccess().getRule();
	}

	//InterfaceFileDeclaration returns declaration::FileDeclaration:
	//	"file" name=MultiIdentifierName ":" type=SubtypeIndication;
	public InterfaceFileDeclarationElements getInterfaceFileDeclarationAccess() {
		return pInterfaceFileDeclaration;
	}
	
	public ParserRule getInterfaceFileDeclarationRule() {
		return getInterfaceFileDeclarationAccess().getRule();
	}

	//FileTypeDefinition returns type::FileTypeDefinition:
	//	"file" "of" type=Name;
	public FileTypeDefinitionElements getFileTypeDefinitionAccess() {
		return pFileTypeDefinition;
	}
	
	public ParserRule getFileTypeDefinitionRule() {
		return getFileTypeDefinitionAccess().getRule();
	}

	/// *
	// * label: for variable in range generate    -- label required
	// *            block declarative items  \__ optional   
	// *         begin                       /
	// *            concurrent statements          -- using variable
	// *         end generate label ;
	// *
	// *  label: if condition generate            -- label required
	// *            block declarative items  \__ optional   
	// *         begin                       /
	// *            concurrent statements
	// *         end generate label ;
	// * / GenerateStatement returns statement::GenerateStatement:
	//	label=Label ":" scheme=GenerationScheme "generate" (declaration+=BlockDeclarativeItem* "begin")?
	//	statement+=ArchitectureStatement* "end" "generate" Identifier? ";";
	public GenerateStatementElements getGenerateStatementAccess() {
		return pGenerateStatement;
	}
	
	public ParserRule getGenerateStatementRule() {
		return getGenerateStatementAccess().getRule();
	}

	//GenerationScheme returns statement::GenerationScheme:
	//	ForGenerationScheme | IfGenerationScheme;
	public GenerationSchemeElements getGenerationSchemeAccess() {
		return pGenerationScheme;
	}
	
	public ParserRule getGenerationSchemeRule() {
		return getGenerationSchemeAccess().getRule();
	}

	//ForGenerationScheme returns statement::ForGenerationScheme:
	//	"for" variable=Identifier "in" in=DiscreteRange;
	public ForGenerationSchemeElements getForGenerationSchemeAccess() {
		return pForGenerationScheme;
	}
	
	public ParserRule getForGenerationSchemeRule() {
		return getForGenerationSchemeAccess().getRule();
	}

	//IfGenerationScheme returns statement::IfGenerationScheme:
	//	"if" condition=Expression;
	public IfGenerationSchemeElements getIfGenerationSchemeAccess() {
		return pIfGenerationScheme;
	}
	
	public ParserRule getIfGenerationSchemeRule() {
		return getIfGenerationSchemeAccess().getRule();
	}

	//Generics:
	//	"generic" "(" declaration+=GenericDeclaration (";" declaration+=GenericDeclaration)* ")" ";";
	public GenericsElements getGenericsAccess() {
		return pGenerics;
	}
	
	public ParserRule getGenericsRule() {
		return getGenericsAccess().getRule();
	}

	//GenericMaps:
	//	"generic" "map" "(" generic+=Parameter ("," generic+=Parameter)* ")";
	public GenericMapsElements getGenericMapsAccess() {
		return pGenericMaps;
	}
	
	public ParserRule getGenericMapsRule() {
		return getGenericMapsAccess().getRule();
	}

	/// *
	// * group identifier : group_template_name ( group_member [, group member] ) ;
	// * / GroupDeclaration returns declaration::GroupDeclaration:
	//	"group" name=IdentifierName ":" is=Name "(" member=GroupConstituents ")" ";";
	public GroupDeclarationElements getGroupDeclarationAccess() {
		return pGroupDeclaration;
	}
	
	public ParserRule getGroupDeclarationRule() {
		return getGroupDeclarationAccess().getRule();
	}

	//GroupConstituent returns Name:
	//	Name | CharacterName;
	public GroupConstituentElements getGroupConstituentAccess() {
		return pGroupConstituent;
	}
	
	public ParserRule getGroupConstituentRule() {
		return getGroupConstituentAccess().getRule();
	}

	//GroupConstituents returns MultiName:
	//	GroupConstituent ({NameList.name+=current} ("," name+=GroupConstituent)+)?;
	public GroupConstituentsElements getGroupConstituentsAccess() {
		return pGroupConstituents;
	}
	
	public ParserRule getGroupConstituentsRule() {
		return getGroupConstituentsAccess().getRule();
	}

	//GroupTemplateDeclaration returns declaration::GroupTemplateDeclaration:
	//	"group" name=IdentifierName "is" "(" entry+=EntityClass "<>"? ("," entry+=EntityClass "<>"?)* ")" ";";
	public GroupTemplateDeclarationElements getGroupTemplateDeclarationAccess() {
		return pGroupTemplateDeclaration;
	}
	
	public ParserRule getGroupTemplateDeclarationRule() {
		return getGroupTemplateDeclarationAccess().getRule();
	}

	/// *
	// * [ label: ] if  condition1  then
	// *                 sequence-of-statements
	// *             elsif  condition2  then      \_ optional
	// *                  sequence-of-statements  /
	// *             elsif  condition3  then      \_ optional
	// *                  sequence-of-statements  /
	// *             ...
	// * 
	// *             else                         \_ optional
	// *                  sequence-of-statements  /
	// *             end if [ label ] ;
	// * / IfStatement returns statement::IfStatement:
	//	(label=Label ":")? "if" test+=IfStatementTest ("elsif" test+=IfStatementTest)* ("else"
	//	statement+=SequentialStatement*)? "end" "if" Identifier? ";";
	public IfStatementElements getIfStatementAccess() {
		return pIfStatement;
	}
	
	public ParserRule getIfStatementRule() {
		return getIfStatementAccess().getRule();
	}

	//IfStatementTest returns statement::IfStatementTest:
	//	condition=Expression "then" statement+=SequentialStatement*;
	public IfStatementTestElements getIfStatementTestAccess() {
		return pIfStatementTest;
	}
	
	public ParserRule getIfStatementTestRule() {
		return getIfStatementTestAccess().getRule();
	}

	//Constraint returns expression::Expression:
	//	RangeConstraint | IndexConstraint;
	public ConstraintElements getConstraintAccess() {
		return pConstraint;
	}
	
	public ParserRule getConstraintRule() {
		return getConstraintAccess().getRule();
	}

	//RangeConstraint returns expression::Expression:
	//	"range" Range;
	public RangeConstraintElements getRangeConstraintAccess() {
		return pRangeConstraint;
	}
	
	public ParserRule getRangeConstraintRule() {
		return getRangeConstraintAccess().getRule();
	}

	//IndexConstraint returns expression::Expression:
	//	"(" DiscreteRange ({expression::MultiExpression.expression+=current} ("," expression+=DiscreteRange)+)? ")";
	public IndexConstraintElements getIndexConstraintAccess() {
		return pIndexConstraint;
	}
	
	public ParserRule getIndexConstraintRule() {
		return getIndexConstraintAccess().getRule();
	}

	//GenericDeclaration returns declaration::Declaration:
	//	InterfaceConstantDeclaration;
	public GenericDeclarationElements getGenericDeclarationAccess() {
		return pGenericDeclaration;
	}
	
	public ParserRule getGenericDeclarationRule() {
		return getGenericDeclarationAccess().getRule();
	}

	//PortDeclaration returns declaration::Declaration:
	//	InterfaceSignalDeclaration;
	public PortDeclarationElements getPortDeclarationAccess() {
		return pPortDeclaration;
	}
	
	public ParserRule getPortDeclarationRule() {
		return getPortDeclarationAccess().getRule();
	}

	//FunctionParameterDeclaration returns declaration::Declaration:
	//	InterfaceConstantDeclaration | InterfaceSignalDeclaration | InterfaceVariableDeclaration | InterfaceFileDeclaration;
	public FunctionParameterDeclarationElements getFunctionParameterDeclarationAccess() {
		return pFunctionParameterDeclaration;
	}
	
	public ParserRule getFunctionParameterDeclarationRule() {
		return getFunctionParameterDeclarationAccess().getRule();
	}

	//ProcedureParameterDeclaration returns declaration::Declaration:
	//	InterfaceVariableDeclaration | InterfaceSignalDeclaration | InterfaceConstantDeclaration | InterfaceFileDeclaration;
	public ProcedureParameterDeclarationElements getProcedureParameterDeclarationAccess() {
		return pProcedureParameterDeclaration;
	}
	
	public ParserRule getProcedureParameterDeclarationRule() {
		return getProcedureParameterDeclarationAccess().getRule();
	}

	/// *
	// * [ label: ] loop
	// *                  sequence-of-statements -- use exit statement to get out
	// *             end loop [ label ] ;
	// * 
	// *  [ label: ] for variable in range loop
	// *                  sequence-of-statements
	// *             end loop [ label ] ;
	// * 
	// *  [ label: ] while  condition  loop
	// *                  sequence-of-statements
	// *             end loop [ label ] ;
	// * / LoopStatement returns statement::LoopStatement:
	//	{statement::LoopStatement} (label=Label ":")? iteration=IterationScheme? "loop" statement+=SequentialStatement* "end"
	//	"loop" Identifier? ";";
	public LoopStatementElements getLoopStatementAccess() {
		return pLoopStatement;
	}
	
	public ParserRule getLoopStatementRule() {
		return getLoopStatementAccess().getRule();
	}

	//IterationScheme returns statement::IterationScheme:
	//	WhileIterationScheme | ForIterationScheme;
	public IterationSchemeElements getIterationSchemeAccess() {
		return pIterationScheme;
	}
	
	public ParserRule getIterationSchemeRule() {
		return getIterationSchemeAccess().getRule();
	}

	//WhileIterationScheme returns statement::WhileIterationScheme:
	//	"while" condition=Expression;
	public WhileIterationSchemeElements getWhileIterationSchemeAccess() {
		return pWhileIterationScheme;
	}
	
	public ParserRule getWhileIterationSchemeRule() {
		return getWhileIterationSchemeAccess().getRule();
	}

	//ForIterationScheme returns statement::ForIterationScheme:
	//	"for" variable=Identifier "in" in=DiscreteRange;
	public ForIterationSchemeElements getForIterationSchemeAccess() {
		return pForIterationScheme;
	}
	
	public ParserRule getForIterationSchemeRule() {
		return getForIterationSchemeAccess().getRule();
	}

	//Name:
	//	NamePrefix ({expression::NameExpression.element+=current} element+=NameSuffix+)?;
	public NameElements getNameAccess() {
		return pName;
	}
	
	public ParserRule getNameRule() {
		return getNameAccess().getRule();
	}

	//NameExpression returns expression::Expression:
	//	{expression::NameExpression} element+=NamePrefix element+=NameSuffix+ | NamePrefixExpression;
	public NameExpressionElements getNameExpressionAccess() {
		return pNameExpression;
	}
	
	public ParserRule getNameExpressionRule() {
		return getNameExpressionAccess().getRule();
	}

	//NamePrefix returns Name:
	//	IdentifierName | StringName | All | Others;
	public NamePrefixElements getNamePrefixAccess() {
		return pNamePrefix;
	}
	
	public ParserRule getNamePrefixRule() {
		return getNamePrefixAccess().getRule();
	}

	//NamePrefixExpression returns expression::Expression:
	//	IdentifierName | StringName | All | Others;
	public NamePrefixExpressionElements getNamePrefixExpressionAccess() {
		return pNamePrefixExpression;
	}
	
	public ParserRule getNamePrefixExpressionRule() {
		return getNamePrefixExpressionAccess().getRule();
	}

	/// * 
	// * prefixed operator:
	// *   SelectedName: prefix = Prefix '.' suffix = Suffix
	// *   AttributeName: prefix = Prefix (signature = Signature )? '\'' AttributeDesignator ( '(' expression = Expression ')' )?	
	// *   IndexedName: prefix = Prefix '(' index += Expression ( ',' index += Expression )* ')'
	// *   SliceName: prefix = Prefix '(' range = DiscreteRange ')'
	// * / NameSuffix returns Name:
	//	SelectedName | AttributeName | Aggregate | SliceName;
	public NameSuffixElements getNameSuffixAccess() {
		return pNameSuffix;
	}
	
	public ParserRule getNameSuffixRule() {
		return getNameSuffixAccess().getRule();
	}

	//StringName returns expression::StringExpression:
	//	{expression::StringExpression} value=STRING;
	public StringNameElements getStringNameAccess() {
		return pStringName;
	}
	
	public ParserRule getStringNameRule() {
		return getStringNameAccess().getRule();
	}

	//CharacterName returns expression::CharacterExpression:
	//	{expression::CharacterExpression} value=CHAR;
	public CharacterNameElements getCharacterNameAccess() {
		return pCharacterName;
	}
	
	public ParserRule getCharacterNameRule() {
		return getCharacterNameAccess().getRule();
	}

	//IdentifierName returns expression::IdentifierExpression:
	//	{expression::IdentifierExpression} value=Identifier;
	public IdentifierNameElements getIdentifierNameAccess() {
		return pIdentifierName;
	}
	
	public ParserRule getIdentifierNameRule() {
		return getIdentifierNameAccess().getRule();
	}

	//SelectedName returns Name:
	//	"." (IdentifierName | CharacterName | StringName | All);
	public SelectedNameElements getSelectedNameAccess() {
		return pSelectedName;
	}
	
	public ParserRule getSelectedNameRule() {
		return getSelectedNameAccess().getRule();
	}

	//AttributeName returns expression::AttributeExpression:
	//	{expression::AttributeExpression} signature=Signature? value=ATTRIBUTE;
	public AttributeNameElements getAttributeNameAccess() {
		return pAttributeName;
	}
	
	public ParserRule getAttributeNameRule() {
		return getAttributeNameAccess().getRule();
	}

	//NatureDeclaration returns declaration::NatureDeclaration:
	//	"nature" name=IdentifierName "is" is=NatureDefinition ";";
	public NatureDeclarationElements getNatureDeclarationAccess() {
		return pNatureDeclaration;
	}
	
	public ParserRule getNatureDeclarationRule() {
		return getNatureDeclarationAccess().getRule();
	}

	//NatureDefinition returns nature::NatureDefinition:
	//	ScalarNatureDefinition | CompositeNatureDefinition;
	public NatureDefinitionElements getNatureDefinitionAccess() {
		return pNatureDefinition;
	}
	
	public ParserRule getNatureDefinitionRule() {
		return getNatureDefinitionAccess().getRule();
	}

	//ScalarNatureDefinition returns nature::ScalarNatureDefinition:
	//	name=Name "across" across=Name "through" through=Name "reference";
	public ScalarNatureDefinitionElements getScalarNatureDefinitionAccess() {
		return pScalarNatureDefinition;
	}
	
	public ParserRule getScalarNatureDefinitionRule() {
		return getScalarNatureDefinitionAccess().getRule();
	}

	/// *
	// * [ label: ] next [ label2 ] [ when condition ] ;
	// * / NextStatement returns statement::NextStatement:
	//	{statement::NextStatement} (label=Label ":")? "next" next=Identifier? ("when" when=Expression)? ";";
	public NextStatementElements getNextStatementAccess() {
		return pNextStatement;
	}
	
	public ParserRule getNextStatementRule() {
		return getNextStatementAccess().getRule();
	}

	//Ports:
	//	"port" "(" declaration+=PortDeclaration (";" declaration+=PortDeclaration)* ")" ";";
	public PortsElements getPortsAccess() {
		return pPorts;
	}
	
	public ParserRule getPortsRule() {
		return getPortsAccess().getRule();
	}

	//PortMaps:
	//	"port" "map" "(" port+=Parameter ("," port+=Parameter)* ")";
	public PortMapsElements getPortMapsAccess() {
		return pPortMaps;
	}
	
	public ParserRule getPortMapsRule() {
		return getPortMapsAccess().getRule();
	}

	//ProcedureCallStatement returns statement::ProcedureCallStatement:
	//	(label=Label ":")? procedure=Name ";";
	public ProcedureCallStatementElements getProcedureCallStatementAccess() {
		return pProcedureCallStatement;
	}
	
	public ParserRule getProcedureCallStatementRule() {
		return getProcedureCallStatementAccess().getRule();
	}

	//ConcurrentProcedureCallStatement returns statement::ProcedureCallStatement:
	//	(label=Label ":")? postponed?="postponed" procedure=Name ";";
	public ConcurrentProcedureCallStatementElements getConcurrentProcedureCallStatementAccess() {
		return pConcurrentProcedureCallStatement;
	}
	
	public ParserRule getConcurrentProcedureCallStatementRule() {
		return getConcurrentProcedureCallStatementAccess().getRule();
	}

	/// *
	// * label : process [ ( sensitivity_list ) ] [ is ]
	// *            [ process_declarative_items ]
	// *         begin
	// *            sequential statements
	// *         end process [ label ] ;
	// * / ProcessStatement returns statement::ProcessStatement:
	//	{statement::ProcessStatement} (label=Label ":")? postponed?="postponed"? "process" ("("
	//	sensitivity=MultiIdentifierName ")")? "is"? declaration+=ProcessDeclarativeItem* "begin"
	//	statement+=SequentialStatement* "end" "postponed"? "process" Identifier? ";";
	public ProcessStatementElements getProcessStatementAccess() {
		return pProcessStatement;
	}
	
	public ParserRule getProcessStatementRule() {
		return getProcessStatementAccess().getRule();
	}

	/// *
	// * allocator = "new" subtype_indication
	// *	         | "new" qualified_expression
	// * / AllocatorExpression returns expression::AllocatorExpression:
	//	"new" type=SubtypeIndication;
	public AllocatorExpressionElements getAllocatorExpressionAccess() {
		return pAllocatorExpression;
	}
	
	public ParserRule getAllocatorExpressionRule() {
		return getAllocatorExpressionAccess().getRule();
	}

	//RecordNatureDefinition returns nature::RecordNatureDefinition:
	//	"record" record+=RecordNatureElement+ "end" "record" Identifier?;
	public RecordNatureDefinitionElements getRecordNatureDefinitionAccess() {
		return pRecordNatureDefinition;
	}
	
	public ParserRule getRecordNatureDefinitionRule() {
		return getRecordNatureDefinitionAccess().getRule();
	}

	//RecordNatureElement returns nature::RecordNatureElement:
	//	name=MultiIdentifierName ":" nature=SubnatureIndication ";";
	public RecordNatureElementElements getRecordNatureElementAccess() {
		return pRecordNatureElement;
	}
	
	public ParserRule getRecordNatureElementRule() {
		return getRecordNatureElementAccess().getRule();
	}

	//RecordTypeDefinition returns type::RecordTypeDefinition:
	//	"record" declaration+=RecordTypeElement+ "end" "record" Identifier?;
	public RecordTypeDefinitionElements getRecordTypeDefinitionAccess() {
		return pRecordTypeDefinition;
	}
	
	public ParserRule getRecordTypeDefinitionRule() {
		return getRecordTypeDefinitionAccess().getRule();
	}

	//RecordTypeElement returns type::RecordTypeElement:
	//	name=MultiIdentifierName ":" type=SubtypeIndication ";";
	public RecordTypeElementElements getRecordTypeElementAccess() {
		return pRecordTypeElement;
	}
	
	public ParserRule getRecordTypeElementRule() {
		return getRecordTypeElementAccess().getRule();
	}

	/// *
	// * [ label: ] report string [ severity name ] ;
	// * / ReportStatement returns statement::ReportStatement:
	//	(label=Label ":")? "report" report=Expression ("severity" severity=Expression)? ";";
	public ReportStatementElements getReportStatementAccess() {
		return pReportStatement;
	}
	
	public ParserRule getReportStatementRule() {
		return getReportStatementAccess().getRule();
	}

	/// *
	// * [ label: ] return [ expression ] ;
	// * / ReturnStatement returns statement::ReturnStatement:
	//	{statement::ReturnStatement} (label=Label ":")? "return" expression=Expression? ";";
	public ReturnStatementElements getReturnStatementAccess() {
		return pReturnStatement;
	}
	
	public ParserRule getReturnStatementRule() {
		return getReturnStatementAccess().getRule();
	}

	//SequentialStatement returns statement::Statement:
	//	WaitStatement | AssertionStatement | ReportStatement | IfStatement | CaseStatement | LoopStatement | NextStatement |
	//	ExitStatement | ReturnStatement | NullStatement | BreakStatement | ProcedureCallStatement |
	//	VariableAssignmentStatement | SequentialSignalAssignmentStatement;
	public SequentialStatementElements getSequentialStatementAccess() {
		return pSequentialStatement;
	}
	
	public ParserRule getSequentialStatementRule() {
		return getSequentialStatementAccess().getRule();
	}

	//NullStatement returns statement::ExpressionStatement:
	//	{statement::ExpressionStatement} (label=Label ":")? expression=NullExpression ";";
	public NullStatementElements getNullStatementAccess() {
		return pNullStatement;
	}
	
	public ParserRule getNullStatementRule() {
		return getNullStatementAccess().getRule();
	}

	//SignalDeclaration returns declaration::SignalDeclaration:
	//	"signal" name=MultiIdentifierName ":" type=SubtypeIndication kind=SignalKind? (":=" initial=Expression)? ";";
	public SignalDeclarationElements getSignalDeclarationAccess() {
		return pSignalDeclaration;
	}
	
	public ParserRule getSignalDeclarationRule() {
		return getSignalDeclarationAccess().getRule();
	}

	//VariableDeclaration returns declaration::VariableDeclaration:
	//	shared?="shared"? "variable" name=MultiIdentifierName ":" type=SubtypeIndication (":=" initial=Expression)? ";";
	public VariableDeclarationElements getVariableDeclarationAccess() {
		return pVariableDeclaration;
	}
	
	public ParserRule getVariableDeclarationRule() {
		return getVariableDeclarationAccess().getRule();
	}

	//ConstantDeclaration returns declaration::ConstantDeclaration:
	//	"constant" name=MultiIdentifierName ":" type=SubtypeIndication (":=" initial=Expression)? ";";
	public ConstantDeclarationElements getConstantDeclarationAccess() {
		return pConstantDeclaration;
	}
	
	public ParserRule getConstantDeclarationRule() {
		return getConstantDeclarationAccess().getRule();
	}

	//InterfaceSignalDeclaration returns declaration::SignalDeclaration:
	//	"signal"? name=MultiIdentifierName ":" mode=Mode? type=SubtypeIndication kind=SignalKind? (":=" initial=Expression)?;
	public InterfaceSignalDeclarationElements getInterfaceSignalDeclarationAccess() {
		return pInterfaceSignalDeclaration;
	}
	
	public ParserRule getInterfaceSignalDeclarationRule() {
		return getInterfaceSignalDeclarationAccess().getRule();
	}

	//InterfaceVariableDeclaration returns declaration::VariableDeclaration:
	//	"variable"? name=MultiIdentifierName ":" mode=Mode? type=SubtypeIndication (":=" initial=Expression)?;
	public InterfaceVariableDeclarationElements getInterfaceVariableDeclarationAccess() {
		return pInterfaceVariableDeclaration;
	}
	
	public ParserRule getInterfaceVariableDeclarationRule() {
		return getInterfaceVariableDeclarationAccess().getRule();
	}

	//InterfaceConstantDeclaration returns declaration::ConstantDeclaration:
	//	"constant"? name=MultiIdentifierName ":" "in"? type=SubtypeIndication (":=" initial=Expression)?;
	public InterfaceConstantDeclarationElements getInterfaceConstantDeclarationAccess() {
		return pInterfaceConstantDeclaration;
	}
	
	public ParserRule getInterfaceConstantDeclarationRule() {
		return getInterfaceConstantDeclarationAccess().getRule();
	}

	/// *
	// * signature = [ [ type_mark { "," type_mark } ] [ "return" type_mark ] ].
	// * / Signature:
	//	{Signature} "[" (parameter+=Name ("," parameter+=Name)*)? ("return" return=Name)? "]";
	public SignatureElements getSignatureAccess() {
		return pSignature;
	}
	
	public ParserRule getSignatureRule() {
		return getSignatureAccess().getRule();
	}

	//SimultaneousAlternative returns statement::CaseAlternative:
	//	"when" choice=Choices "=>" statement+=SimultaneousStatement*;
	public SimultaneousAlternativeElements getSimultaneousAlternativeAccess() {
		return pSimultaneousAlternative;
	}
	
	public ParserRule getSimultaneousAlternativeRule() {
		return getSimultaneousAlternativeAccess().getRule();
	}

	//SimultaneousCaseStatement returns statement::SimultaneousCaseStatement:
	//	(label=Label ":")? "case" case=Expression "use" when+=SimultaneousAlternative+ "end" "case" Identifier? ";";
	public SimultaneousCaseStatementElements getSimultaneousCaseStatementAccess() {
		return pSimultaneousCaseStatement;
	}
	
	public ParserRule getSimultaneousCaseStatementRule() {
		return getSimultaneousCaseStatementAccess().getRule();
	}

	//SimultaneousIfStatement returns statement::SimultaneousIfStatement:
	//	(label=Label ":")? "if" test+=SimultaneousIfStatementTest "use" ("elsif" test+=SimultaneousIfStatementTest)* ("else"
	//	statement+=SimultaneousStatement*)? "end" "use" Identifier? ";";
	public SimultaneousIfStatementElements getSimultaneousIfStatementAccess() {
		return pSimultaneousIfStatement;
	}
	
	public ParserRule getSimultaneousIfStatementRule() {
		return getSimultaneousIfStatementAccess().getRule();
	}

	//SimultaneousIfStatementTest returns statement::IfStatementTest:
	//	condition=Expression "use" statement+=SimultaneousStatement*;
	public SimultaneousIfStatementTestElements getSimultaneousIfStatementTestAccess() {
		return pSimultaneousIfStatementTest;
	}
	
	public ParserRule getSimultaneousIfStatementTestRule() {
		return getSimultaneousIfStatementTestAccess().getRule();
	}

	//SimultaneousProceduralStatement returns statement::SimultaneousProceduralStatement:
	//	{statement::SimultaneousProceduralStatement} (label=Label ":")? "procedural" "is"?
	//	declaration+=ProceduralDeclarativeItem* "begin" statement+=SequentialStatement* "end" "procedural" Identifier? ";";
	public SimultaneousProceduralStatementElements getSimultaneousProceduralStatementAccess() {
		return pSimultaneousProceduralStatement;
	}
	
	public ParserRule getSimultaneousProceduralStatementRule() {
		return getSimultaneousProceduralStatementAccess().getRule();
	}

	//SimultaneousStatement returns statement::Statement:
	//	SimpleSimultaneousStatement | SimultaneousIfStatement | SimultaneousCaseStatement | SimultaneousProceduralStatement |
	//	NullStatement;
	public SimultaneousStatementElements getSimultaneousStatementAccess() {
		return pSimultaneousStatement;
	}
	
	public ParserRule getSimultaneousStatementRule() {
		return getSimultaneousStatementAccess().getRule();
	}

	//Spectrum returns ams::Spectrum:
	//	"spectrum" left=SimpleExpression "," right=SimpleExpression;
	public SpectrumElements getSpectrumAccess() {
		return pSpectrum;
	}
	
	public ParserRule getSpectrumRule() {
		return getSpectrumAccess().getRule();
	}

	//Noise returns ams::Noise:
	//	"noise" noise=SimpleExpression;
	public NoiseElements getNoiseAccess() {
		return pNoise;
	}
	
	public ParserRule getNoiseRule() {
		return getNoiseAccess().getRule();
	}

	//QuantityDeclaration returns declaration::QuantityDeclaration:
	//	BranchQuantityDeclaration | FreeQuantityDeclaration | SourceQuantityDeclaration;
	public QuantityDeclarationElements getQuantityDeclarationAccess() {
		return pQuantityDeclaration;
	}
	
	public ParserRule getQuantityDeclarationRule() {
		return getQuantityDeclarationAccess().getRule();
	}

	/// * 
	// * across_aspect: identifier_list ( tolerance_aspect )? ( VARASGN expression )? ACROSS;
	// * / QuantityAspect returns ams::QuantityAspect:
	//	name=MultiIdentifierName ("tolerance" tolerance=Expression)? (":=" expression=Expression)?;
	public QuantityAspectElements getQuantityAspectAccess() {
		return pQuantityAspect;
	}
	
	public ParserRule getQuantityAspectRule() {
		return getQuantityAspectAccess().getRule();
	}

	//BranchQuantityDeclaration returns declaration::BranchQuantityDeclaration:
	//	"quantity" (across=QuantityAspect "across")? (through=QuantityAspect "through")? left=Name ("to" right=Name)? ";";
	public BranchQuantityDeclarationElements getBranchQuantityDeclarationAccess() {
		return pBranchQuantityDeclaration;
	}
	
	public ParserRule getBranchQuantityDeclarationRule() {
		return getBranchQuantityDeclarationAccess().getRule();
	}

	//FreeQuantityDeclaration returns declaration::FreeQuantityDeclaration:
	//	"quantity" name=MultiIdentifierName ":" type=SubtypeIndication (":=" quantity=Expression)? ";";
	public FreeQuantityDeclarationElements getFreeQuantityDeclarationAccess() {
		return pFreeQuantityDeclaration;
	}
	
	public ParserRule getFreeQuantityDeclarationRule() {
		return getFreeQuantityDeclarationAccess().getRule();
	}

	//SourceQuantityDeclaration returns declaration::SourceQuantityDeclaration:
	//	"quantity" name=MultiIdentifierName ":" type=SubtypeIndication source=SourceAspect ";";
	public SourceQuantityDeclarationElements getSourceQuantityDeclarationAccess() {
		return pSourceQuantityDeclaration;
	}
	
	public ParserRule getSourceQuantityDeclarationRule() {
		return getSourceQuantityDeclarationAccess().getRule();
	}

	//SourceAspect returns ams::SourceAspect:
	//	Spectrum | Noise;
	public SourceAspectElements getSourceAspectAccess() {
		return pSourceAspect;
	}
	
	public ParserRule getSourceAspectRule() {
		return getSourceAspectAccess().getRule();
	}

	//LimitDeclaration returns declaration::LimitDeclaration:
	//	"limit" name=MultiName ":" type=Name "with" value=Expression ";";
	public LimitDeclarationElements getLimitDeclarationAccess() {
		return pLimitDeclaration;
	}
	
	public ParserRule getLimitDeclarationRule() {
		return getLimitDeclarationAccess().getRule();
	}

	//SubnatureDeclaration returns declaration::SubnatureDeclaration:
	//	"subnature" name=IdentifierName "is" nature=SubnatureIndication ";";
	public SubnatureDeclarationElements getSubnatureDeclarationAccess() {
		return pSubnatureDeclaration;
	}
	
	public ParserRule getSubnatureDeclarationRule() {
		return getSubnatureDeclarationAccess().getRule();
	}

	//SubprogramDeclaration returns declaration::SubprogramDeclaration:
	//	ProcedureDeclaration | FunctionDeclaration;
	public SubprogramDeclarationElements getSubprogramDeclarationAccess() {
		return pSubprogramDeclaration;
	}
	
	public ParserRule getSubprogramDeclarationRule() {
		return getSubprogramDeclarationAccess().getRule();
	}

	//ProcedureDeclaration returns declaration::ProcedureDeclaration:
	//	{declaration::ProcedureDeclaration} "procedure" name=DesignatorName ("(" parameter+=ProcedureParameterDeclaration (";"
	//	parameter+=ProcedureParameterDeclaration)* ")")? body=SubprogramBody? ";";
	public ProcedureDeclarationElements getProcedureDeclarationAccess() {
		return pProcedureDeclaration;
	}
	
	public ParserRule getProcedureDeclarationRule() {
		return getProcedureDeclarationAccess().getRule();
	}

	//FunctionDeclaration returns declaration::FunctionDeclaration:
	//	{declaration::FunctionDeclaration} purity=Purity? "function" name=DesignatorName ("("
	//	parameter+=FunctionParameterDeclaration (";" parameter+=FunctionParameterDeclaration)* ")")? "return" type=Name
	//	body=SubprogramBody? ";";
	public FunctionDeclarationElements getFunctionDeclarationAccess() {
		return pFunctionDeclaration;
	}
	
	public ParserRule getFunctionDeclarationRule() {
		return getFunctionDeclarationAccess().getRule();
	}

	//SubprogramBody returns declaration::SubprogramBody:
	//	{declaration::SubprogramBody} "is" declaration+=SubprogramDeclarativeItem* "begin" statement+=SequentialStatement*
	//	"end" ("procedure" | "function")? Designator?;
	public SubprogramBodyElements getSubprogramBodyAccess() {
		return pSubprogramBody;
	}
	
	public ParserRule getSubprogramBodyRule() {
		return getSubprogramBodyAccess().getRule();
	}

	//SubtypeDeclaration returns declaration::SubtypeDeclaration:
	//	"subtype" name=IdentifierName "is" type=SubtypeIndication ";";
	public SubtypeDeclarationElements getSubtypeDeclarationAccess() {
		return pSubtypeDeclaration;
	}
	
	public ParserRule getSubtypeDeclarationRule() {
		return getSubtypeDeclarationAccess().getRule();
	}

	//AliasDeclaration returns declaration::AliasDeclaration:
	//	"alias" name=DesignatorName (":" alias=SubtypeIndication)? "is" is=NameSignature ";";
	public AliasDeclarationElements getAliasDeclarationAccess() {
		return pAliasDeclaration;
	}
	
	public ParserRule getAliasDeclarationRule() {
		return getAliasDeclarationAccess().getRule();
	}

	//Range returns expression::Expression:
	//	SimpleExpression ({expression::RangeExpression.left=current} direction=RangeDirection right=SimpleExpression)?;
	public RangeElements getRangeAccess() {
		return pRange;
	}
	
	public ParserRule getRangeRule() {
		return getRangeAccess().getRule();
	}

	/// *
	// * discrete_range = discrete_subtype_indication
	// *	              | range
	// * / DiscreteRange returns expression::Expression:
	//	RangeSpecification | SubtypeIndicationExpression;
	public DiscreteRangeElements getDiscreteRangeAccess() {
		return pDiscreteRange;
	}
	
	public ParserRule getDiscreteRangeRule() {
		return getDiscreteRangeAccess().getRule();
	}

	/// *
	// * aggregate = "(" element_association { "," element_association } ")".
	// *
	// * Associations with elements' simple names are allowed in record aggregates only.
	// * Associations with simple expressions or discrete ranges as choices are allowed only in array aggregates.
	// * Each element of the value defined by an aggregate must be represented once and only once in the aggregate.
	// * Aggregates containing the single element association must always be specified 
	// * using named association in order to distinguish them from parenthesized expressions.
	// * The others choice can be only the last in an aggregate.
	// * / Aggregate returns expression::AggregateExpression:
	//	{expression::AggregateExpression} "(" (expression+=Parameter ("," expression+=Parameter)*)? ")";
	public AggregateElements getAggregateAccess() {
		return pAggregate;
	}
	
	public ParserRule getAggregateRule() {
		return getAggregateAccess().getRule();
	}

	//SliceName returns Name:
	//	"(" RangeSpecification ")";
	public SliceNameElements getSliceNameAccess() {
		return pSliceName;
	}
	
	public ParserRule getSliceNameRule() {
		return getSliceNameAccess().getRule();
	}

	//RangeSpecification returns expression::RangeExpression:
	//	{expression::RangeExpression} => (left=SimpleExpression direction=RangeDirection) right=SimpleExpression;
	public RangeSpecificationElements getRangeSpecificationAccess() {
		return pRangeSpecification;
	}
	
	public ParserRule getRangeSpecificationRule() {
		return getRangeSpecificationAccess().getRule();
	}

	/// *
	// * NAME_PATTERN (NAME_PATTERN)? = [ resolution_indication ] type_mark [ constraint ].
	// * / SubtypeIndication returns type::TypeReference:
	//	{expression::SubtypeIndicationExpression} name=Name mark=Name constraint=Constraint? ("tolerance" tolerance=Expression
	//	("across" across=Expression "through")?)? | {expression::SubtypeIndicationExpression} => (mark=Name
	//	constraint=Constraint) ("tolerance" tolerance=Expression ("across" across=Expression "through")?)? |
	//	{expression::SubtypeIndicationExpression} => (mark=Name "tolerance") tolerance=Expression ("across" across=Expression
	//	"through")? | Name;
	public SubtypeIndicationElements getSubtypeIndicationAccess() {
		return pSubtypeIndication;
	}
	
	public ParserRule getSubtypeIndicationRule() {
		return getSubtypeIndicationAccess().getRule();
	}

	//SubtypeIndicationExpression returns expression::Expression:
	//	{expression::SubtypeIndicationExpression} name=Name mark=Name constraint=Constraint? ("tolerance" tolerance=Expression
	//	("across" across=Expression "through")?)? | {expression::SubtypeIndicationExpression} => (mark=Name
	//	constraint=Constraint) ("tolerance" tolerance=Expression ("across" across=Expression "through")?)? |
	//	{expression::SubtypeIndicationExpression} => (mark=Name "tolerance") tolerance=Expression ("across" across=Expression
	//	"through")? | NameExpression;
	public SubtypeIndicationExpressionElements getSubtypeIndicationExpressionAccess() {
		return pSubtypeIndicationExpression;
	}
	
	public ParserRule getSubtypeIndicationExpressionRule() {
		return getSubtypeIndicationExpressionAccess().getRule();
	}

	//SubnatureIndication returns nature::NatureReference:
	//	{expression::SubnatureIndicationExpression} => (mark=Name constraint=IndexConstraint) ("tolerance"
	//	tolerance=Expression ("across" across=Expression "through")?)? | {expression::SubnatureIndicationExpression} mark=Name
	//	"tolerance" tolerance=Expression ("across" across=Expression "through")? | Name;
	public SubnatureIndicationElements getSubnatureIndicationAccess() {
		return pSubnatureIndication;
	}
	
	public ParserRule getSubnatureIndicationRule() {
		return getSubnatureIndicationAccess().getRule();
	}

	//Target returns expression::Expression:
	//	NameExpression | Aggregate;
	public TargetElements getTargetAccess() {
		return pTarget;
	}
	
	public ParserRule getTargetRule() {
		return getTargetAccess().getRule();
	}

	//TerminalDeclaration returns declaration::TerminalDeclaration:
	//	"terminal" name=MultiIdentifierName ":" nature=SubnatureIndication ";";
	public TerminalDeclarationElements getTerminalDeclarationAccess() {
		return pTerminalDeclaration;
	}
	
	public ParserRule getTerminalDeclarationRule() {
		return getTerminalDeclarationAccess().getRule();
	}

	//TypeDeclaration returns declaration::TypeDeclaration:
	//	"type" name=IdentifierName ("is" is=TypeDefinition)? ";";
	public TypeDeclarationElements getTypeDeclarationAccess() {
		return pTypeDeclaration;
	}
	
	public ParserRule getTypeDeclarationRule() {
		return getTypeDeclarationAccess().getRule();
	}

	//TypeDefinition returns type::TypeDefinition:
	//	EnumerationTypeDefinition | CompositeTypeDefinition | AccessTypeDefinition | FileTypeDefinition |
	//	PhysicalTypeDefinition | RangeTypeDefinition;
	public TypeDefinitionElements getTypeDefinitionAccess() {
		return pTypeDefinition;
	}
	
	public ParserRule getTypeDefinitionRule() {
		return getTypeDefinitionAccess().getRule();
	}

	//RangeTypeDefinition returns type::RangeTypeDefinition:
	//	{type::RangeTypeDefinition} "range" left=SimpleExpression direction=RangeDirection right=SimpleExpression |
	//	{type::RangeTypeDefinition} "range" "<>";
	public RangeTypeDefinitionElements getRangeTypeDefinitionAccess() {
		return pRangeTypeDefinition;
	}
	
	public ParserRule getRangeTypeDefinitionRule() {
		return getRangeTypeDefinitionAccess().getRule();
	}

	/// *
	// *  range left_bound to right_bound
	// *  units
	// *    primary_unit_name
	// *    (secondary_unit_name = number primary_unit_name)*
	// * end units type_name
	// * / PhysicalTypeDefinition returns type::PhysicalTypeDefinition:
	//	=> ("range" range=Range "units") primary=Identifier ";" secondary+=PhysicalTypeDefinitionSecondary* "end" "units"
	//	Identifier?;
	public PhysicalTypeDefinitionElements getPhysicalTypeDefinitionAccess() {
		return pPhysicalTypeDefinition;
	}
	
	public ParserRule getPhysicalTypeDefinitionRule() {
		return getPhysicalTypeDefinitionAccess().getRule();
	}

	//PhysicalTypeDefinitionSecondary returns type::PhysicalTypeDefinitionSecondary:
	//	name=Identifier "=" number=ABSTRACT_LITERAL? of=Name ";";
	public PhysicalTypeDefinitionSecondaryElements getPhysicalTypeDefinitionSecondaryAccess() {
		return pPhysicalTypeDefinitionSecondary;
	}
	
	public ParserRule getPhysicalTypeDefinitionSecondaryRule() {
		return getPhysicalTypeDefinitionSecondaryAccess().getRule();
	}

	//UnconstrainedArrayTypeDefinition returns type::UnconstrainedArrayTypeDefinition:
	//	"array" "(" index+=Name "range" "<>" ("," index+=Name "range" "<>")* ")" "of" type=SubtypeIndication;
	public UnconstrainedArrayTypeDefinitionElements getUnconstrainedArrayTypeDefinitionAccess() {
		return pUnconstrainedArrayTypeDefinition;
	}
	
	public ParserRule getUnconstrainedArrayTypeDefinitionRule() {
		return getUnconstrainedArrayTypeDefinitionAccess().getRule();
	}

	//ConstrainedArrayTypeDefinition returns type::ConstrainedArrayTypeDefinition:
	//	"array" constraint=IndexConstraint "of" type=SubtypeIndication;
	public ConstrainedArrayTypeDefinitionElements getConstrainedArrayTypeDefinitionAccess() {
		return pConstrainedArrayTypeDefinition;
	}
	
	public ParserRule getConstrainedArrayTypeDefinitionRule() {
		return getConstrainedArrayTypeDefinitionAccess().getRule();
	}

	//UnconstrainedArrayNatureDefinition returns nature::UnconstrainedArrayNatureDefinition:
	//	"array" "(" index+=Name "range" "<>" ("," index+=Name "range" "<>")* ")" "of" nature=SubnatureIndication;
	public UnconstrainedArrayNatureDefinitionElements getUnconstrainedArrayNatureDefinitionAccess() {
		return pUnconstrainedArrayNatureDefinition;
	}
	
	public ParserRule getUnconstrainedArrayNatureDefinitionRule() {
		return getUnconstrainedArrayNatureDefinitionAccess().getRule();
	}

	//ConstrainedArrayNatureDefinition returns nature::ConstrainedArrayNatureDefinition:
	//	"array" constraint=IndexConstraint "of" nature=SubnatureIndication;
	public ConstrainedArrayNatureDefinitionElements getConstrainedArrayNatureDefinitionAccess() {
		return pConstrainedArrayNatureDefinition;
	}
	
	public ParserRule getConstrainedArrayNatureDefinitionRule() {
		return getConstrainedArrayNatureDefinitionAccess().getRule();
	}

	/// *
	// * wait until condition;
	// * wait on signal_list;
	// * wait for time;
	// * wait;
	// * / WaitStatement returns statement::WaitStatement:
	//	{statement::WaitStatement} (label=Label ":")? "wait" ("on" sensitivity=MultiName)? ("until" until=Expression)? ("for"
	//	time=Expression)? ";";
	public WaitStatementElements getWaitStatementAccess() {
		return pWaitStatement;
	}
	
	public ParserRule getWaitStatementRule() {
		return getWaitStatementAccess().getRule();
	}

	/// *
	// * value_expression [ after time_expression ]
	// * / Waveform returns expression::Expression:
	//	Expression ({expression::WaveformExpression.expression=current} "after" after=Expression)?;
	public WaveformElements getWaveformAccess() {
		return pWaveform;
	}
	
	public ParserRule getWaveformRule() {
		return getWaveformAccess().getRule();
	}

	//NullExpression returns expression::NullExpression:
	//	{expression::NullExpression} "null";
	public NullExpressionElements getNullExpressionAccess() {
		return pNullExpression;
	}
	
	public ParserRule getNullExpressionRule() {
		return getNullExpressionAccess().getRule();
	}

	//BitStringName returns expression::BitStringExpression:
	//	{expression::BitStringExpression} value=BIT_STRING_LITERAL;
	public BitStringNameElements getBitStringNameAccess() {
		return pBitStringName;
	}
	
	public ParserRule getBitStringNameRule() {
		return getBitStringNameAccess().getRule();
	}

	//ValueExpression returns expression::ValueExpression:
	//	{expression::UnitValueExpression} value=ABSTRACT_LITERAL unit=Name | {expression::ValueExpression}
	//	value=ABSTRACT_LITERAL;
	public ValueExpressionElements getValueExpressionAccess() {
		return pValueExpression;
	}
	
	public ParserRule getValueExpressionRule() {
		return getValueExpressionAccess().getRule();
	}

	//enum SignalKind returns declaration::SignalKind:
	//	REGISTER="register" | BUS="bus";
	public SignalKindElements getSignalKindAccess() {
		return unknownRuleSignalKind;
	}
	
	public EnumRule getSignalKindRule() {
		return getSignalKindAccess().getRule();
	}

	//enum RangeDirection returns expression::RangeDirection:
	//	TO="to" | DOWNTO="downto";
	public RangeDirectionElements getRangeDirectionAccess() {
		return unknownRuleRangeDirection;
	}
	
	public EnumRule getRangeDirectionRule() {
		return getRangeDirectionAccess().getRule();
	}

	//enum Mode returns declaration::Mode:
	//	IN="in" | OUT="out" | INOUT="inout" | BUFFER="buffer" | LINKAGE="linkage";
	public ModeElements getModeAccess() {
		return unknownRuleMode;
	}
	
	public EnumRule getModeRule() {
		return getModeAccess().getRule();
	}

	//enum UnaryOperator returns expression::UnaryOperator:
	//	ABS="abs" | NOT="not";
	public UnaryOperatorElements getUnaryOperatorAccess() {
		return unknownRuleUnaryOperator;
	}
	
	public EnumRule getUnaryOperatorRule() {
		return getUnaryOperatorAccess().getRule();
	}

	//enum MultiplyingOperator returns expression::MultiplyingOperator:
	//	MUL="*" | DIV="/" | MOD="mod" | REM="rem";
	public MultiplyingOperatorElements getMultiplyingOperatorAccess() {
		return unknownRuleMultiplyingOperator;
	}
	
	public EnumRule getMultiplyingOperatorRule() {
		return getMultiplyingOperatorAccess().getRule();
	}

	//enum ShiftOperator returns expression::ShiftOperator:
	//	SLL="sll" | SRL="srl" | SLA="sla" | SRA="sra" | ROL="rol" | ROR="ror";
	public ShiftOperatorElements getShiftOperatorAccess() {
		return unknownRuleShiftOperator;
	}
	
	public EnumRule getShiftOperatorRule() {
		return getShiftOperatorAccess().getRule();
	}

	//enum RelationalOperator returns expression::RelationalOperator:
	//	EQ="=" | NEQ="/=" | LOWERTHAN="<" | LE="<=" | GREATERTHAN=">" | GE=">=";
	public RelationalOperatorElements getRelationalOperatorAccess() {
		return unknownRuleRelationalOperator;
	}
	
	public EnumRule getRelationalOperatorRule() {
		return getRelationalOperatorAccess().getRule();
	}

	//enum LogicalOperator returns expression::LogicalOperator:
	//	AND="and" | OR="or" | NAND="nand" | NOR="nor" | XOR="xor" | XNOR="xnor";
	public LogicalOperatorElements getLogicalOperatorAccess() {
		return unknownRuleLogicalOperator;
	}
	
	public EnumRule getLogicalOperatorRule() {
		return getLogicalOperatorAccess().getRule();
	}

	//enum AddingOperator returns expression::AddingOperator:
	//	PLUS="+" | MINUS="-" | AMPERSAND="&";
	public AddingOperatorElements getAddingOperatorAccess() {
		return unknownRuleAddingOperator;
	}
	
	public EnumRule getAddingOperatorRule() {
		return getAddingOperatorAccess().getRule();
	}

	//enum Sign returns expression::Sign:
	//	PLUS="+" | MINUS="-";
	public SignElements getSignAccess() {
		return unknownRuleSign;
	}
	
	public EnumRule getSignRule() {
		return getSignAccess().getRule();
	}

	//enum Purity returns declaration::Purity:
	//	PURE="pure" | IMPURE="impure";
	public PurityElements getPurityAccess() {
		return unknownRulePurity;
	}
	
	public EnumRule getPurityRule() {
		return getPurityAccess().getRule();
	}

	//enum EntityClass returns declaration::EntityClass:
	//	ENTITY="entity" | ARCHITECTURE="architecture" | CONFIGURATION="configuration" | PROCEDURE="procedure" |
	//	FUNCTION="function" | PACKAGE="package" | TYPE="type" | SUBTYPE="subtype" | CONSTANT="constant" | SIGNAL="signal" |
	//	VARIABLE="variable" | COMPONENT="component" | LABEL="label" | LITERAL="literal" | UNITS="units" | GROUP="group" |
	//	FILE="file" | NATURE="nature" | SUBNATURE="subnature" | QUANTITY="quantity" | TERMINAL="terminal";
	public EntityClassElements getEntityClassAccess() {
		return unknownRuleEntityClass;
	}
	
	public EnumRule getEntityClassRule() {
		return getEntityClassAccess().getRule();
	}

	//DesignatorName returns Name:
	//	IdentifierName | StringName;
	public DesignatorNameElements getDesignatorNameAccess() {
		return pDesignatorName;
	}
	
	public ParserRule getDesignatorNameRule() {
		return getDesignatorNameAccess().getRule();
	}

	//Designator:
	//	Identifier | STRING;
	public DesignatorElements getDesignatorAccess() {
		return pDesignator;
	}
	
	public ParserRule getDesignatorRule() {
		return getDesignatorAccess().getRule();
	}

	//Identifier:
	//	ID | EXTENDED_IDENTIFIER;
	public IdentifierElements getIdentifierAccess() {
		return pIdentifier;
	}
	
	public ParserRule getIdentifierRule() {
		return getIdentifierAccess().getRule();
	}

	//terminal ABSTRACT_LITERAL:
	//	INTEGER_FRAGMENT (("." INTEGER_FRAGMENT)? | "#" BASED_INTEGER_FRAGMENT ("." BASED_INTEGER_FRAGMENT)? "#")
	//	EXPONENT_FRAGMENT?;
	public TerminalRule getABSTRACT_LITERALRule() {
		return tABSTRACT_LITERAL;
	} 

	//terminal BIT_STRING_LITERAL:
	//	INTEGER_FRAGMENT? BASE_SPECIFIER_FRAGMENT STRING;
	public TerminalRule getBIT_STRING_LITERALRule() {
		return tBIT_STRING_LITERAL;
	} 

	//terminal ID:
	//	"^"? LETTER_FRAGMENT ("_" | LETTER_OR_DIGIT_FRAGMENT)*;
	public TerminalRule getIDRule() {
		return tID;
	} 

	//terminal EXTENDED_IDENTIFIER:
	//	"\\" ("\\" ("b" | "t" | "n" | "f" | "r" | "\"" | "\'" | "\\") | !("\\" | "\r" | "\n"))+ "\\";
	public TerminalRule getEXTENDED_IDENTIFIERRule() {
		return tEXTENDED_IDENTIFIER;
	} 

	//terminal STRING:
	//	"\"" ("\\" ("b" | "t" | "n" | "f" | "r" | "\"" | "\'" | "\\") | !("\\" | "\"" | "\r" | "\n"))* "\"";
	public TerminalRule getSTRINGRule() {
		return tSTRING;
	} 

	//terminal CHAR:
	//	"\'a\'" | "\'b\'" | "\'c\'" | "\'d\'" | "\'e\'" | "\'f\'" | "\'g\'" | "\'h\'" | "\'i\'" | "\'j\'" | "\'k\'" | "\'l\'"
	//	| "\'m\'" | "\'n\'" | "\'o\'" | "\'p\'" | "\'q\'" | "\'r\'" | "\'s\'" | "\'t\'" | "\'u\'" | "\'v\'" | "\'w\'" |
	//	"\'x\'" | "\'y\'" | "\'z\'" | "\'A\'" | "\'B\'" | "\'C\'" | "\'D\'" | "\'E\'" | "\'F\'" | "\'G\'" | "\'H\'" | "\'I\'"
	//	| "\'J\'" | "\'K\'" | "\'L\'" | "\'M\'" | "\'N\'" | "\'O\'" | "\'P\'" | "\'Q\'" | "\'R\'" | "\'S\'" | "\'T\'" |
	//	"\'U\'" | "\'V\'" | "\'W\'" | "\'X\'" | "\'Y\'" | "\'Z\'" | "\'0\'" | "\'1\'" | "\'2\'" | "\'3\'" | "\'4\'" | "\'5\'"
	//	| "\'6\'" | "\'7\'" | "\'8\'" | "\'9\'" | "\'&\'" | "\'\'\'" | "\'(\'" | "\')\'" | "\'+\'" | "\',\'" | "\'-\'" |
	//	"\'.\'" | "\'/\'" | "\':\'" | "\';\'" | "\'<\'" | "\'=\'" | "\'>\'" | "\'|\'" | "\' \'" | "\'#\'" | "\'[\'" | "\']\'"
	//	| "\'_\'" | "\'*\'" | "\'\"\'" | "\'!\'" | "\'$\'" | "\'%\'" | "\'@\'" | "\'?\'" | "\'^\'" | "\'`\'" | "\'{\'" |
	//	"\'}\'" | "\'~\'" | "\'\'" | "\'\'" | "\'\'" | "\'\'" | "\'\'" | "\'\'" | "\'\'" | "\'\'" | "\'\'" | "\'\'"
	//	| "\'\'" | "\'\'" | "\'\'" | "\'\'" | "\'\'" | "\'\'" | "\'\'" | "\'\'" | "\'\'" | "\'\'" | "\'\'" | "\'\'"
	//	| "\'\'" | "\'\'" | "\'\'" | "\'\'" | "\'\'" | "\'\'" | "\'\'" | "\'\'" | "\'\'" | "\'\'" | "\'\'" |
	//	"\'\'" | "\'\'" | "\'\'" | "\'\'" | "\'\'" | "\'\'" | "\'\'" | "\'\'" | "\'\'" | "\'\'" | "\'\'" | "\'\'"
	//	| "\'\'" | "\'\'" | "\'\'" | "\'\'" | "\'\'" | "\'\'" | "\'\'" | "\'\'" | "\'\'" | "\'\'" | "\'\'" |
	//	"\'\'" | "\'\'" | "\'\'" | "\'\'" | "\'\'" | "\'\'" | "\'\'" | "\'\'" | "\'\'" | "\'\'" | "\'\'" | "\'\'"
	//	| "\'\'" | "\'\'" | "\'\'" | "\'\'" | "\'\'" | "\'\'" | "\'\'" | "\'\'" | "\'\'" | "\'\'" | "\'\'" |
	//	"\'\'" | "\'\'" | "\'\'" | "\'\'" | "\'\'" | "\'\'" | "\'\'" | "\'\'" | "\'\'" | "\'\'" | "\'\'" | "\'\'"
	//	| "\'\'" | "\'\'" | "\'\'" | "\'\'" | "\'\'";
	public TerminalRule getCHARRule() {
		return tCHAR;
	} 

	//terminal ATTRIBUTE:
	//	"\'" LETTER_FRAGMENT ("_" | LETTER_OR_DIGIT_FRAGMENT)*;
	public TerminalRule getATTRIBUTERule() {
		return tATTRIBUTE;
	} 

	//terminal SL_COMMENT:
	//	"--" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return tSL_COMMENT;
	} 

	//terminal WS:
	//	(" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return tWS;
	} 

	//terminal fragment BASED_INTEGER_FRAGMENT:
	//	LETTER_OR_DIGIT_FRAGMENT ("_" | LETTER_OR_DIGIT_FRAGMENT)*;
	public TerminalRule getBASED_INTEGER_FRAGMENTRule() {
		return tBASED_INTEGER_FRAGMENT;
	} 

	//terminal fragment LETTER_OR_DIGIT_FRAGMENT:
	//	LETTER_FRAGMENT | DIGIT_FRAGMENT;
	public TerminalRule getLETTER_OR_DIGIT_FRAGMENTRule() {
		return tLETTER_OR_DIGIT_FRAGMENT;
	} 

	//terminal fragment LETTER_FRAGMENT:
	//	"a".."z" | "A".."Z";
	public TerminalRule getLETTER_FRAGMENTRule() {
		return tLETTER_FRAGMENT;
	} 

	//terminal fragment BASE_SPECIFIER_FRAGMENT:
	//	"B" | "O" | "X" | "UB" | "UO" | "UX" | "SB" | "SO" | "SX" | "D" | "b" | "o" | "x" | "ub" | "uo" | "ux" | "sb" | "so" |
	//	"sx" | "d";
	public TerminalRule getBASE_SPECIFIER_FRAGMENTRule() {
		return tBASE_SPECIFIER_FRAGMENT;
	} 

	//terminal fragment EXPONENT_FRAGMENT:
	//	("E" | "e") ("+" | "-")? INTEGER_FRAGMENT;
	public TerminalRule getEXPONENT_FRAGMENTRule() {
		return tEXPONENT_FRAGMENT;
	} 

	//terminal fragment INTEGER_FRAGMENT:
	//	DIGIT_FRAGMENT ("_" | DIGIT_FRAGMENT)*;
	public TerminalRule getINTEGER_FRAGMENTRule() {
		return tINTEGER_FRAGMENT;
	} 

	//terminal fragment DIGIT_FRAGMENT:
	//	"0".."9";
	public TerminalRule getDIGIT_FRAGMENTRule() {
		return tDIGIT_FRAGMENT;
	} 
}
